{"themeConfig":{"themeName":"Expert-Next","postPageSize":10,"archivesPageSize":20,"siteName":"RiftRays's Blog","siteDescription":"年轻且优秀 积极且颓废","footerInfo":"Your time is limited, so don't waste it living someone else's life ... Stay Hungry. Stay Foolish.","showFeatureImage":false,"domain":"https://riftrays.github.io","postUrlFormat":"SHORT_ID","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD HH:mm:ss","feedFullText":false,"feedCount":10,"archivesPath":"archives","postPath":"","tagPath":""},"posts":[{"abstract":"","content":"私服 简介 Maven私服（Maven Repository Manager）是一种用于管理和缓存Maven构建依赖的工具。它充当了本地和中央远程仓库之间的中间层，为开发团队提供了更高效、可靠的构建过程。私服可以帮助团队在内部维护和共享构建依赖，从而加快项目构建速度，并减轻对公共中央仓库的依赖，提高项目构建的可靠性。 优点 加快构建速度：私服允许团队在内部缓存项目所需的依赖，减少了对外部中央仓库的访问，从而提高了构建速度。 离线构建：私服允许团队在没有网络连接时继续构建项目，因为所需的依赖已经被缓存在私服中。 版本控制：私服可以确保项目使用特定版本的依赖，从而提高项目的稳定性。 安全性：私服允许团队在内部管理构建依赖，减少了对外部不可信仓库的依赖，提高了构建的安全性。 私服仓库分类 Maven私服仓库分类，主要是指根据存储内容和访问权限将私服仓库划分为不同的类型。一般来说，私服仓库可以分为以下几类： Proxy Repository（代理仓库） 代理仓库是私服与公共中央仓库之间的中间层。它可以缓存从公共中央仓库下载的依赖，从而在项目构建过程中加快依赖下载速度，并降低对中央仓库的网络依赖。代理仓库会自动向上游中央仓库发起请求，并将下载的依赖保存在本地，以便后续项目构建时直接从私服仓库获取依赖。 代码示例：创建一个代理仓库的配置，在项目的pom.xml文件中添加如下代码： &lt;project&gt; &lt;!-- 其他配置 --&gt; &lt;repositories&gt; &lt;!-- 定义代理仓库 --&gt; &lt;repository&gt; &lt;id&gt;maven-central-proxy&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/repository/maven-central/&lt;/url&gt; &lt;!-- 设置为true表示该仓库是代理仓库 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 其他配置 --&gt; &lt;/project&gt; 在上述配置中，maven-central-proxy是代理仓库的ID，http://localhost:8081/nexus/repository/maven-central/是代理仓库的URL地址。 Hosted Repository（托管仓库） 托管仓库是私服中用于存储内部开发项目的依赖的仓库。它允许开发团队发布自己的Maven项目，以便其他项目可以访问和使用这些依赖。在托管仓库中，开发者可以将自己的项目构件发布到私服，并且其他项目可以通过私服获取这些构件。 代码示例：在Sonatype Nexus控制台中创建一个托管仓库。 在Sonatype Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Hosted)&quot;作为仓库类型，然后按照向导设置仓库的属性。 Group Repository（组合仓库） 组合仓库是私服中的虚拟仓库，它可以将多个代理仓库和托管仓库组合在一起，并将它们呈现为单一的仓库。组合仓库允许开发者在项目中只配置一个仓库，但实际上可以从多个实际仓库中获取依赖。 代码示例：在Sonatype Nexus控制台中创建一个组合仓库。 在Sonatype Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Group)&quot;作为仓库类型，然后按照向导设置组合仓库的属性，并选择包含的实际仓库。 Snapshot Repository（快照仓库） 快照仓库用于存储项目的快照版本，即开发过程中的不稳定版本。快照版本通常用于频繁发布和测试最新的功能和改进，而不用每次都发布稳定的版本。快照仓库允许开发者发布和获取这些不稳定版本的依赖。 代码示例：在Sonatype Nexus控制台中创建一个快照仓库。 在Sonatype Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Hosted)&quot;作为仓库类型，并勾选&quot;Support Snapshots&quot;选项，然后按照向导设置仓库的属性。 搭建Maven私服 搭建Maven私服有多种选择，其中最常用的是Sonatype Nexus和JFrog Artifactory。在本示例中，我们将使用Sonatype Nexus搭建Maven私服。 步骤一：下载Sonatype Nexus 首先，你需要下载Sonatype Nexus，可以从官方网站下载：https://www.sonatype.com/nexus-repository-oss。 直达链接：https://help.sonatype.com/repomanager3/product-information/download 步骤二：安装Sonatype Nexus 解压下载的压缩包，并进入解压后的目录。然后，执行以下命令启动Sonatype Nexus： linux : ./bin/nexus run windows: nexus.exe /run nexus 步骤三：访问Sonatype Nexus控制台 在浏览器中访问 http://localhost:8081，进入Sonatype Nexus控制台。初始访问时，你需要设置管理员密码。然后开启匿名访问。 步骤四：配置Maven私服 登录Sonatype Nexus控制台后，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Maven Repositories&quot;。 在&quot;Maven Repositories&quot;页面，你可以创建和管理私服中的Maven仓库。默认情况下，Sonatype Nexus已经预先配置了几个仓库。 maven-central：中央远程仓库，用于缓存从中央仓库下载的依赖。 maven-public：用于发布Maven项目的公共仓库。 maven-snapshots：用于发布快照版本的仓库。 你可以根据需要添加新的仓库，例如，创建一个私有仓库用于存储内部项目的依赖。 步骤五：配置Maven项目使用私服 为了让Maven项目使用你搭建的私服，你需要在项目的pom.xml文件中添加私服的配置。 &lt;project&gt; &lt;!-- 其他配置 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;your-repo-id&lt;/id&gt; &lt;url&gt;http://your-nexus-url/repository/your-repo-id/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 其他配置 --&gt; &lt;/project&gt; 上述配置中，your-repo-id是你在Sonatype Nexus控制台中创建的仓库ID，http://your-nexus-url/repository/your-repo-id/是你私服的URL地址。 当Maven项目构建时，Maven会从私服中下载依赖，从而加快构建速度并减轻对中央仓库的依赖。 示例代码 下面是一个示例的pom.xml文件，展示了如何配置Maven私服： &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;my-maven-project&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 配置私服仓库 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;my-private-repo&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/repository/my-private-repo/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 依赖配置 --&gt; &lt;dependencies&gt; &lt;!-- 这里可以使用私服的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;my-private-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 其他配置 --&gt; &lt;/project&gt; 上述示例中，my-private-repo是在Sonatype Nexus中创建的私有仓库，用于存储my-private-library这个依赖。 Nexus基础配置 当涉及到Nexus的相关配置时，我们将主要关注以下方面： 修改基础配置信息：包括修改Nexus管理员密码、更改默认端口、配置SSL证书等。 修改服务器运行配置信息：包括调整JVM内存参数、配置运行时用户、更改数据存储位置等。 创建和管理Maven仓库：包括创建代理仓库、托管仓库、组合仓库和快照仓库，以及配置仓库的属性。 权限管理和用户配置：包括创建用户、分配角色和权限，以控制用户对Nexus的访问和操作。 仓库访问策略配置：包括配置代理仓库的缓存策略、设置快照仓库的过期策略等。 修改基础配置信息 修改Nexus管理员密码 默认情况下，Nexus的管理员账号是admin，密码是admin123。为了增强安全性，我们应该在首次登录后尽快修改管理员密码。 代码实现：在Nexus控制台中修改管理员密码。 首次登录Nexus控制台，在页面右上角点击&quot;Sign In&quot;。 登录后，点击页面右上角的用户图标，选择&quot;Change Password&quot;。 输入当前密码和新密码，然后点击&quot;Save&quot;保存修改。 更改默认端口 Nexus默认使用8081端口进行访问。如果8081端口已经被占用或者你想要更改端口号，可以通过修改配置文件来实现。 代码实现：修改nexus.properties配置文件。 打开Nexus安装目录下的nexus.properties文件。 找到并修改以下行，将端口号修改为你想要的端口号： application-port=8081 保存文件，并重新启动Nexus使配置生效。 配置SSL证书 如果你想要在Nexus中启用HTTPS，你需要配置SSL证书。 代码实现：在Nexus控制台中配置SSL证书。 在Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;General&quot;。 在&quot;General&quot;页面中，找到&quot;SSL&quot;部分，配置SSL证书相关信息。 修改服务器运行配置信息 调整JVM内存参数 根据Nexus的使用情况，可能需要调整JVM内存参数，以确保Nexus有足够的内存进行运行。 代码实现：修改nexus.vmoptions文件。 打开Nexus安装目录下的bin/nexus.vmoptions文件。 修改以下行来调整JVM内存参数： -Xms2g # 设置JVM最小内存为2GB -Xmx4g # 设置JVM最大内存为4GB 保存文件，并重新启动Nexus使配置生效。 配置运行时用户 为了安全性考虑，你可以将Nexus的运行时用户从默认的nexus用户更改为其他用户。 代码实现：修改nexus.rc文件（适用于Linux系统）。 打开Nexus安装目录下的bin/nexus.rc文件。 修改以下行来配置运行时用户： run_as_user=&quot;your_user&quot; 将your_user替换为你想要使用的运行时用户。 保存文件，并重新启动Nexus使配置生效。 更改数据存储位置 默认情况下，Nexus的数据存储在Nexus安装目录下的sonatype-work文件夹。你可以将数据存储位置更改为其他路径，以便更好地管理和备份数据。 代码实现：修改nexus.properties配置文件。 打开Nexus安装目录下的nexus.properties文件。 找到并修改以下行，将数据存储位置修改为你想要的路径： nexus-work=${bundleBasedir}/../sonatype-work/nexus 保存文件，并重新启动Nexus使配置生效。 当涉及Nexus的配置时，我们已经讨论了修改基础配置信息和服务器运行配置信息。现在，我们将继续讨论创建和管理Maven仓库，以及权限管理和用户配置。 当涉及Nexus的配置时，我们已经讨论了修改基础配置信息和服务器运行配置信息。现在，我们将继续讨论创建和管理Maven仓库，以及权限管理和用户配置。 创建和管理Maven仓库 创建代理仓库 代理仓库充当Nexus与公共中央仓库之间的中间层，可以缓存从公共中央仓库下载的依赖，从而提高构建速度。 代码实现：在Nexus控制台中创建代理仓库。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Proxy)&quot;作为仓库类型。 按照向导设置代理仓库的属性，包括仓库名称、仓库ID、远程仓库URL等。 点击&quot;Create Repository&quot;创建代理仓库。 创建托管仓库 托管仓库用于存储内部开发项目的依赖，允许开发团队发布自己的Maven项目，并供其他项目访问和使用这些依赖。 代码实现：在Nexus控制台中创建托管仓库。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Hosted)&quot;作为仓库类型。 按照向导设置托管仓库的属性，包括仓库名称、仓库ID等。 点击&quot;Create Repository&quot;创建托管仓库。 创建组合仓库 组合仓库是私服中的虚拟仓库，可以将多个实际仓库组合在一起，呈现为单一的仓库。 代码实现：在Nexus控制台中创建组合仓库。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Group)&quot;作为仓库类型。 按照向导设置组合仓库的属性，包括仓库名称、仓库ID等。 在&quot;Member Repositories&quot;部分，选择要包含在组合仓库中的实际仓库。 点击&quot;Create Repository&quot;创建组合仓库。 创建快照仓库 快照仓库用于存储项目的快照版本，即开发过程中的不稳定版本。 代码实现：在Nexus控制台中创建快照仓库。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，点击&quot;Create Repository&quot;。 选择&quot;Maven (Hosted)&quot;作为仓库类型。 在向导中勾选&quot;Support Snapshots&quot;选项，表示这是一个快照仓库。 按照向导设置快照仓库的属性，包括仓库名称、仓库ID等。 点击&quot;Create Repository&quot;创建快照仓库。 权限管理和用户配置 权限管理和用户配置允许你控制用户对Nexus的访问和操作。你可以创建用户、分配角色和权限，来限制或开放不同用户的权限。 代码实现：在Nexus控制台中进行权限管理和用户配置。 登录Nexus控制台，点击左侧导航栏的&quot;Security&quot;，然后选择&quot;Users&quot;。 在右侧的&quot;Users&quot;页面，点击&quot;Create User&quot;创建新用户。 输入用户名和密码，并选择相应的角色。角色决定了用户在Nexus中的权限。 点击&quot;Create User&quot;创建用户。 在&quot;Roles&quot;页面，你可以定义自定义角色并分配相应的权限。 点击&quot;Create Role&quot;创建新角色。 为角色指定权限，例如访问特定仓库、发布构件等。 将角色分配给相应的用户，以控制其权限。 仓库访问策略配置 仓库访问策略配置是指在Nexus中配置不同类型仓库的访问策略，用于控制用户对仓库的访问和使用权限。通过合理设置仓库访问策略，可以确保仓库的安全性和稳定性，同时满足项目的需求。 在Nexus中，主要有以下几种仓库访问策略： 代理仓库访问策略 托管仓库访问策略 组合仓库访问策略 快照仓库访问策略 代理仓库访问策略 代理仓库是用于代理公共中央仓库的中间仓库，通过代理仓库，Nexus可以缓存从公共中央仓库下载的依赖，从而提高构建速度。在配置代理仓库的访问策略时，我们可以设置缓存策略和连接超时等参数。 代码实现：在Nexus控制台中配置代理仓库的访问策略。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，找到已创建的代理仓库，点击仓库名称进入详情页。 在仓库详情页中，点击&quot;Configuration&quot;选项卡。 在&quot;Repository Policy&quot;部分，可以设置缓存策略，如&quot;Always&quot;表示始终缓存远程仓库中的构件，&quot;Never&quot;表示不缓存构件，&quot;Per-Request&quot;表示根据请求缓存构件。 在&quot;Connection&quot;部分，可以设置连接超时等参数，确保与远程仓库的通信稳定。 完成设置后，点击&quot;Save&quot;保存配置。 托管仓库访问策略 托管仓库是用于存储内部开发项目的依赖，可以发布和管理自己的Maven项目。在配置托管仓库的访问策略时，我们可以设置发布策略和删除策略。 代码实现：在Nexus控制台中配置托管仓库的访问策略。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，找到已创建的托管仓库，点击仓库名称进入详情页。 在仓库详情页中，点击&quot;Configuration&quot;选项卡。 在&quot;Repository Policy&quot;部分，可以设置发布策略，如&quot;Allow Redeploy&quot;表示允许覆盖已发布的构件，&quot;Read Only&quot;表示只读模式不允许发布。 在&quot;Delete Policy&quot;部分，可以设置删除策略，如&quot;Allow Delete&quot;表示允许删除构件，&quot;Read Only&quot;表示只读模式不允许删除。 完成设置后，点击&quot;Save&quot;保存配置。 组合仓库访问策略 组合仓库是私服中的虚拟仓库，可以将多个实际仓库组合在一起，呈现为单一的仓库。在配置组合仓库的访问策略时，我们主要关注成员仓库的顺序，即用户在组合仓库中查找构件时会按照顺序依次查找成员仓库。 代码实现：在Nexus控制台中配置组合仓库的访问策略。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，找到已创建的组合仓库，点击仓库名称进入详情页。 在仓库详情页中，点击&quot;Configuration&quot;选项卡。 在&quot;Member Repositories&quot;部分，可以拖动成员仓库来调整它们的顺序。成员仓库的顺序将影响用户查找构件时的查找顺序。 完成设置后，点击&quot;Save&quot;保存配置。 快照仓库访问策略 快照仓库用于存储项目的快照版本，即开发过程中的不稳定版本。在配置快照仓库的访问策略时，我们可以设置过期策略和清理策略。 代码实现：在Nexus控制台中配置快照仓库的访问策略。 登录Nexus控制台，点击左侧导航栏的&quot;Settings&quot;，然后选择&quot;Repositories&quot;。 在右侧的&quot;Repositories&quot;页面，找到已创建的快照仓库，点击仓库名称进入详情页。 在仓库详情页中，点击&quot;Configuration&quot;选项卡。 在&quot;Repository Policy&quot;部分，可以设置过期策略，如&quot;Keep Forever&quot;表示不过期，&quot;Remove When Released&quot;表示当构件发布后删除快照构件。 在&quot;Cleanup&quot;部分，可以设置清理策略，如&quot;Remove If Released&quot;表示当构件发布后删除快照构件，&quot;Remove When More Than N Days Old&quot;表示删除指定天数前的快照构件。 完成设置后，点击&quot;Save&quot;保存配置。 资源上传与下载 概述 创建用户与认证 在Nexus中，认证信息通常是通过用户凭据（用户名和密码）来进行身份验证。认证信息的设置涉及到创建用户账号，并为用户赋予相应的权限。接下来，我将详细讲解在Nexus中设置认证信息的步骤，并结合代码实现辅助理解。 设置认证信息步骤 登录Nexus控制台：使用管理员账号登录Nexus的Web界面。默认情况下，Nexus的Web控制台地址为：http://your-nexus-server:8081，请根据实际情况替换your-nexus-server为你的Nexus服务器地址。 创建用户账号：在Nexus控制台中，点击左侧导航栏的&quot;Security&quot;（安全）选项，然后选择&quot;Users&quot;（用户）。点击&quot;Create User&quot;（创建用户）按钮，填写用户的用户名、密码和邮箱等信息，然后保存。 分配角色：在Nexus中，角色用于管理用户的权限。点击左侧导航栏的&quot;Security&quot;（安全）选项，然后选择&quot;Roles&quot;（角色）。选择或创建一个适当的角色，然后将创建的用户添加到该角色中。 授权访问：在Nexus控制台中，点击左侧导航栏的&quot;Repository&quot;（仓库）选项，然后选择&quot;Repositories&quot;（仓库）。找到需要进行身份验证的仓库，点击仓库名称进入详情页。在仓库详情页中，点击&quot;Configuration&quot;（配置）选项卡。在&quot;Permissions&quot;（权限）部分，授予相应的角色对该仓库的访问权限。确保赋予用户足够的权限，以便进行上传和下载构件的操作。 保存配置：完成上述设置后，点击&quot;Save&quot;（保存）按钮，将认证信息和权限配置保存到Nexus中。 代码实现 假设我们已经在Nexus中创建了一个用户账号，用户名为&quot;myuser&quot;，密码为&quot;mypassword&quot;。并且已经为该用户分配了一个名为&quot;upload-download&quot;的角色，该角色具有上传和下载构件的权限。 下面是使用Maven构建工具时，在pom.xml中配置认证信息的示例代码： &lt;project&gt; &lt;!-- ... --&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;url&gt;https://example.com/nexus/repository/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;url&gt;https://example.com/nexus/repository/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;properties&gt; &lt;!-- 设置认证信息 --&gt; &lt;nexus.username&gt;myuser&lt;/nexus.username&gt; &lt;nexus.password&gt;mypassword&lt;/nexus.password&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;username&gt;${nexus.username}&lt;/username&gt; &lt;password&gt;${nexus.password}&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;username&gt;${nexus.username}&lt;/username&gt; &lt;password&gt;${nexus.password}&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- ... --&gt; &lt;/project&gt; 在上述示例中，我们在pom.xml中设置了Maven的认证信息，使用nexus.username和nexus.password来指定Nexus的用户名和密码。这样，在执行Maven构建命令时，Maven会使用这些认证信息进行身份验证，以便上传和下载构件。 小贴士 实际应用中，为了安全性考虑，我们通常不会直接在pom.xml中明文存储密码，而是使用Maven的加密功能或其他安全方式来管理密码。 资源上传（上传构件） 资源上传指将自己的构件发布到私服，以便其他项目可以从私服中下载这些构件。上传构件的过程主要涉及以下步骤： 身份验证：用户首先需要在Nexus上创建账号，并通过身份验证，以获取上传权限。 配置Maven项目：在Maven项目的pom.xml中配置私服的URL和认证信息，以便Maven构建工具能够将构件上传到私服。 执行构建：通过Maven构建命令将项目构建为构件，并将构件上传到私服。 Maven项目配置 在Maven项目的pom.xml文件中添加私服的配置，包括私服的URL和认证信息。 &lt;project&gt; &lt;!-- ... --&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;url&gt;https://example.com/nexus/repository/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;url&gt;https://example.com/nexus/repository/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;!-- ... --&gt; &lt;/project&gt; 在上述配置中，nexus-releases和nexus-snapshots是私服的ID，https://example.com/nexus/repository/releases/和https://example.com/nexus/repository/snapshots/是私服的URL。 上传构件 使用Maven构建命令上传构件到私服。 # 上传正式版构件 mvn deploy # 上传快照版构件 mvn deploy -Dmaven.deploy.snapshot=true 执行以上命令后，Maven会将构件上传到私服中相应的仓库，正式版构件上传到nexus-releases，快照版构件上传到nexus-snapshots。 资源下载（下载构件） 资源下载指从私服中获取所需的构件，以便在项目中使用。下载构件的过程主要涉及以下步骤： 身份验证：用户需要在Nexus上创建账号，并通过身份验证，以获取下载权限。 配置Maven项目：在Maven项目的pom.xml中配置私服的URL和认证信息，以便Maven构建工具能够从私服中下载构件。 执行构建：通过Maven构建命令将项目构建，Maven会从私服中下载所需的构件。 Maven项目配置 在Maven项目的pom.xml文件中添加私服的配置，包括私服的URL和认证信息，与资源上传时的配置类似。 &lt;project&gt; &lt;!-- ... --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;url&gt;https://example.com/nexus/repository/releases/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;url&gt;https://example.com/nexus/repository/snapshots/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- ... --&gt; &lt;/project&gt; 在上述配置中，我们定义了两个仓库：nexus-releases用于下载正式版构件，nexus-snapshots用于下载快照版构件。请根据实际情况进行替换。 下载构件 当我们执行Maven构建命令时，Maven会自动从私服中下载所需的构件。 mvn clean install 在上述命令中，Maven会从私服中下载依赖的构件，并将项目构建为可执行文件。 小贴士 在进行资源下载前，确保正确配置了私服的URL和认证信息，这样才能顺利下载私服中的构件。 ","tags":[{"index":3,"name":"Maven","slug":"tag-Maven","used":true,"link":"https://riftrays.github.io/tag-Maven/"}],"title":"SonatypeNexus","feature":"","link":"https://riftrays.github.io/6Dq1YTrSe/","stats":{"text":"27 min read","time":1561000,"words":6668,"minutes":27},"date":"2022-01-02 19:58:56","dateFormat":"2022-01-02 19:58:56"},{"abstract":"","content":"概述 Maven是一个流行的Java项目管理工具，它提供了一种规范化的方式来构建、管理和发布Java项目。 下面是一些与Maven相关的概念： 项目对象模型（Project Object Model，POM）：POM是Maven项目的核心文件，它以XML格式描述了项目的元数据、依赖关系、构建配置和插件等信息。POM定义了项目的结构、构建过程和目标。 坐标（Coordinates）：在Maven中，每个项目都有一个唯一的坐标，用于标识项目的组织、唯一ID和版本号。坐标通常由groupId（组织ID）、artifactId（项目ID）和version（版本号）组成。 依赖（Dependencies）：Maven使用依赖管理来管理项目所需的外部库或模块。通过在POM中声明依赖，Maven可以自动下载并管理这些依赖，确保项目能够正确构建和运行。 仓库（Repository）：Maven使用仓库来存储项目的依赖库和构建产物。有两种类型的仓库：本地仓库（Local Repository）用于存储本地计算机上的依赖，远程仓库（Remote Repository）用于从互联网上下载依赖。 生命周期（Lifecycle）：Maven定义了一系列的生命周期，包括clean、validate、compile、test、package、install和deploy等。每个生命周期由一系列的阶段（Phase）组成，而每个阶段由一系列的目标（Goal）构成。 插件（Plugins）：Maven插件是用来扩展和定制构建过程的工具。插件提供了各种目标，可以用来执行特定的任务，例如编译代码、运行测试、生成文档等。Maven本身提供了一些常用的插件，同时也支持自定义插件。 作用 项目构建：Maven提供了一种统一的项目结构和构建方式，使得项目的构建过程更加规范和易于管理。通过定义项目的POM文件，Maven可以自动化执行项目构建所需的步骤，例如编译源代码、运行单元测试、生成文档、打包项目等。 依赖管理：Maven能够自动下载、安装和管理项目所需的外部依赖库。通过在POM文件中声明依赖，Maven可以自动解析和下载依赖，并确保项目构建时所需的依赖库可用。这简化了依赖管理的过程，减少了手动管理依赖的工作量。 项目文档生成：Maven支持通过插件生成项目文档，例如使用Maven Site插件可以生成项目的网站文档，包括项目介绍、开发者文档、API文档等。这有助于提供项目的详细文档和说明，方便团队成员和其他开发者了解和使用项目。 项目报告和统计：Maven能够生成各种报告和统计信息，帮助开发团队了解项目的状态和质量。例如，可以生成代码覆盖率报告、静态代码分析报告、测试结果报告等。这些报告和统计信息有助于发现潜在问题、优化代码质量以及改进项目的开发流程。 项目部署和发布：Maven支持将项目构建产物（如JAR文件、WAR文件）部署到远程仓库或发布到中央仓库。这样其他开发者可以方便地访问和使用你的项目构建产物，提高代码的可重用性和共享性。 总的来说，Maven提供了一种标准化和自动化的方式来管理Java项目的构建、依赖、文档和部署等方面。它简化了项目的管理和维护工作，提高了开发效率，并促进了团队合作和代码质量的提升。 安装配置 下载Maven： 访问Maven官方网站（https://maven.apache.org/），找到最新版本的Maven进行下载。 下载完成后，解压缩Maven压缩包到你选择的目录。 配置环境变量： 在操作系统中配置Maven的环境变量，以便在命令行中能够直接运行Maven命令。 在Windows系统中，右键点击&quot;我的电脑&quot;，选择&quot;属性&quot;，进入&quot;高级系统设置&quot;，点击&quot;环境变量&quot;。 在系统变量中，找到&quot;Path&quot;变量，点击&quot;编辑&quot;，添加Maven的bin目录路径（例如：C:\\apache-maven-3.8.4\\bin）。 在Unix/Linux系统中，编辑~/.bashrc或~/.bash_profile文件，添加以下行：export PATH=/path/to/maven/bin:$PATH 验证Maven安装： 打开命令行终端（Windows下是CMD或PowerShell，Unix/Linux下是Terminal）。 运行以下命令验证Maven是否正确安装：mvn -version 如果能够显示Maven的版本信息，则表示安装成功。 配置Maven的设置（可选）： Maven的配置文件是settings.xml，位于Maven的安装目录下的conf文件夹中。 可以编辑settings.xml文件来配置Maven的行为，例如设置本地仓库路径、代理服务器、镜像等。 如果没有特殊需求，可以使用默认的settings.xml文件，不进行修改。 配置阿里巴巴的仓库： 在&lt;mirrors&gt;标签下添加如下配置：&lt;mirror&gt; &lt;id&gt;alibaba&lt;/id&gt; &lt;name&gt;Alibaba Maven Repository&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 这个配置将创建一个名为&quot;alibaba&quot;的镜像，将中央仓库（central）指向阿里巴巴的公共仓库。 配置.m2路径： 默认情况下，Maven将在用户主目录下的.m2文件夹中保存本地仓库。 如果你想将本地仓库保存在不同的位置，可以在&lt;settings&gt;标签下添加如下配置：&lt;localRepository&gt;/path/to/custom/.m2/repository&lt;/localRepository&gt; 将/path/to/custom替换为你希望存储.m2文件夹的路径。 配置全球中央仓库： 在&lt;mirrors&gt;标签下添加如下配置： &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 这个配置将创建一个名为&quot;central&quot;的镜像，将中央仓库（central）指向全球Maven中央仓库。 基本用法 创建一个Maven项目和POM文件： 首先，确保你已经安装了Maven。然后，在命令行中进入你希望创建项目的目录。 运行以下命令创建一个新的Maven项目：mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false 这将创建一个基本的Maven项目结构，并生成一个默认的POM文件。 配置项目的坐标、依赖和插件： 打开生成的POM文件（位于项目根目录下），在其中配置项目的坐标信息。 &lt;groupId&gt;表示项目的组织ID，&lt;artifactId&gt;表示项目的唯一ID，&lt;version&gt;表示项目的版本号。你可以根据需要进行修改。 在POM文件的&lt;dependencies&gt;部分添加项目所需的依赖库。每个依赖都使用&lt;dependency&gt;标签进行声明，指定依赖的坐标信息。 如果需要使用插件来扩展构建过程，可以在POM文件的&lt;build&gt;部分配置插件。每个插件使用&lt;plugin&gt;标签进行声明，指定插件的坐标和配置信息。 通过Maven进行项目构建、编译、测试和打包： 在项目根目录下运行以下命令进行项目构建：mvn clean package clean命令清理之前构建的结果，package命令编译项目源代码、运行测试并打包项目。你可以根据需要使用其他命令，如compile、test等。 Maven将执行构建过程，并在目标文件夹（默认为target）中生成构建产物，如编译后的类文件、JAR文件等。 管理项目的依赖关系： 在POM文件的&lt;dependencies&gt;部分添加项目所需的依赖库。每个依赖使用&lt;dependency&gt;标签进行声明。 指定依赖的坐标信息，包括groupId、artifactId和version等。Maven将根据这些信息自动下载和管理依赖。 可以使用&lt;scope&gt;标签指定依赖的作用范围，如compile（默认值）、test、runtime等。 可以使用&lt;exclusions&gt;标签排除依赖的传递性依赖关系，以避免冲突或不需要的依赖。 使用Maven插件扩展构建过程： 在POM文件的&lt;build&gt;部分配置插件。每个插件使用&lt;plugin&gt;标签进行声明。 指定插件的坐标和配置信息，如groupId、artifactId和version等。 有些插件有默认配置，你可以根据需要进行修改。可以查阅插件的文档了解可用的配置选项。 插件可以用于各种任务，例如静态代码分析、代码生成、测试报告生成等。你可以根据项目需求选择适合的插件并配置相应的目标和参数。 这些步骤将帮助你掌握Maven的基本用法和功能，以便进行项目的构建、依赖管理和插件扩展等操作。记住，随着实际项目的练习和深入学习，你将更加熟悉和灵活运用这些概念和技术。 Maven常用命令 mvn clean: 清除项目构建目录，删除生成的目标文件。 mvn compile: 编译项目源代码。 mvn package: 打包项目，生成JAR或WAR文件。 mvn install: 将项目构建结果安装到本地Maven仓库，供其他项目使用。 mvn test: 运行项目的单元测试。 mvn clean install: 清除构建目录并重新构建项目，安装到本地仓库。 生命周期与插件 Maven有三个内置的生命周期：clean、default和site。 每个生命周期由一系列的阶段（phase）组成，每个阶段都代表了构建过程中的一个步骤。例如，default生命周期包含了compile、test、package等阶段。 Maven插件可以扩展和定制Maven的功能。例如，maven-compiler-plugin用于编译Java代码，maven-surefire-plugin用于执行测试。 依赖范围 在Maven中，依赖范围（Dependency Scope）用于定义依赖项在编译、测试、运行和打包等不同阶段的可见性和有效性。以下是几个常用的依赖范围： compile（编译依赖）： 默认的依赖范围，用于编译、测试和运行阶段。 编译依赖在编译、测试和运行时均可见。 provided（已提供依赖）： 适用于在编译和测试阶段需要依赖，但在运行时由目标环境（如应用服务器）提供。 在编译和测试时可见，但在打包和运行时不包含在项目中。 runtime（运行时依赖）： 在运行和测试阶段需要依赖，但在编译时不需要。 运行时依赖在运行和测试时可见，但在编译时不包含在项目中。 test（测试依赖）： 仅在测试阶段使用的依赖，不会在编译、运行和打包阶段使用。 测试依赖仅在测试时可见，不会包含在项目的编译和打包结果中。 system（系统依赖）： 指定项目中的依赖来自于系统路径，而不是通过仓库中的坐标来解析。 需要显式指定依赖的路径，使用&lt;systemPath&gt;元素来定义。 下面是一份比较不同依赖范围的表格： 依赖范围 用途 编译阶段 测试阶段 运行阶段 打包阶段 compile 编译、测试和运行时可见 ✔️ ✔️ ✔️ ✔️ provided 在编译和测试阶段需要依赖，但在运行时由目标环境提供 ✔️ ✔️ ❌ ❌ runtime 运行和测试时需要依赖，但在编译时不需要 ❌ ✔️ ✔️ ✔️ test 仅在测试阶段使用的依赖，不会在编译、运行和打包阶段使用 ❌ ✔️ ❌ ❌ system 依赖来自于系统路径，需要显式指定依赖的路径 ✔️ ✔️ ✔️ ✔️ import 用于管理依赖的版本传递性，但本身不会参与构建和运行 ❌ ❌ ❌ ❌ test-compile 仅在测试编译阶段使用的依赖，不会在测试运行和生产环境使用 ✔️ ✔️ ❌ ❌ test-runtime 仅在测试运行阶段使用的依赖，不会在测试编译和生产环境使用 ❌ ✔️ ✔️ ✔️ system-test 仅在测试阶段使用的系统依赖，不会在编译、运行和打包阶段使用 ✔️ ✔️ ✔️ ✔️ provided-test 在编译和测试阶段需要依赖，但在运行时由目标环境提供的测试依赖 ✔️ ✔️ ❌ ❌ 注意：✔️ 表示依赖在该阶段可见和有效，❌ 表示依赖在该阶段不可见或无效。 在&lt;dependencies&gt;标签中，可以为每个依赖项指定所需的依赖范围。例如： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;my-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 高阶用法 使用Maven的生命周期、阶段和目标管理构建过程： Maven定义了一套标准的生命周期，包括clean、validate、compile、test、package、install和deploy等。 生命周期由一系列阶段组成，每个阶段由一个或多个目标构成。例如，compile阶段包含了编译源代码的目标。 通过在命令行中指定生命周期、阶段或目标，你可以按顺序执行构建过程中的特定步骤。 例如，运行以下命令执行clean生命周期的install阶段：mvn clean install 配置Maven插件以满足项目需求： Maven提供了许多内置插件，可以满足常见的构建和开发需求。你可以在POM文件中配置这些插件并指定相关的目标和参数。 你还可以使用自定义插件来满足特定的项目需求。自定义插件需要在POM文件中声明，并提供插件的实现和配置信息。 使用Maven的属性、配置文件和环境变量进行灵活的配置： Maven支持使用属性（Properties）来灵活配置项目。属性可以在POM文件中定义，也可以从外部配置文件中加载。 你可以在POM文件中使用${property}的形式引用属性值，也可以通过命令行参数或环境变量来覆盖属性值。 Maven还支持使用配置文件来配置插件和构建过程。你可以在POM文件中引用配置文件，并在配置文件中设置插件的参数。 使用Maven的多模块项目管理复杂的项目结构： Maven支持创建多模块项目，其中一个父项目管理多个子项目。父项目和子项目分别有自己的POM文件。 父项目的POM文件可以定义模块（modules）列表，列出所有子项目的相对路径。 每个子项目都有自己独立的POM文件，可以定义自己的依赖、插件和构建配置。子项目可以独立构建，也可以作为整个多模块项目的一部分构建。 实际应用 Maven广泛应用于Java项目的构建和依赖管理，可以帮助你更高效地管理项目结构和依赖项。 它可以自动下载所需的依赖库，并支持项目的编译、测试和打包等常见操作。 Maven还可以与持续集成工具（如Jenkins）集成，实现自动化构建和部署。 示范 在src/main/java目录下创建一个Java源代码文件，例如HelloWorld.java： public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello, Maven!&quot;); } } 在根目录下的pom.xml中添加依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 使用Maven编译和运行项目： mvn compile mvn exec:java -Dexec.mainClass=&quot;HelloWorld&quot; 以上示例展示了Maven的基本用法和项目配置。您可以根据实际需求在pom.xml中添加更多依赖和插件。 ","tags":[{"index":3,"name":"Maven","slug":"tag-Maven","used":true,"link":"https://riftrays.github.io/tag-Maven/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Maven 进阶","feature":"","link":"https://riftrays.github.io/MavenAdvanced/","stats":{"text":"16 min read","time":914000,"words":4073,"minutes":16},"date":"2021-01-10 21:31:32","dateFormat":"2021-01-10 21:31:32"},{"abstract":"","content":"Spring Boot 概述 Spring Boot是一个开源的Java框架，它是Spring框架的扩展，旨在简化和加速Java应用程序的开发。Spring Boot专注于使构建、配置和部署基于Spring的应用程序变得更加容易。它采用&quot;约定优于配置&quot;的原则，通过提供默认配置和自动化的配置方式，使开发人员能够快速地启动和运行应用程序。 特性 自动配置：Spring Boot根据项目中所包含的依赖库，自动配置应用程序。这意味着不必手动配置每个细节，大部分情况下只需少量的配置即可。 起步依赖：Spring Boot引入了&quot;起步依赖&quot;的概念，这是预先配置好的依赖项集合，可以帮助快速地集成各种功能模块（例如数据库、安全性、Web等）到应用程序中。 嵌入式Web服务器：Spring Boot内置了常用的Web服务器，如Tomcat、Jetty和Undertow，使能够以独立应用程序的形式轻松地运行Web应用。 Actuator：Spring Boot提供了Actuator模块，用于监控和管理应用程序。它可以提供应用程序的健康状况、运行时信息等，方便开发人员进行调试和监控。 外部化配置：Spring Boot支持将配置从代码中分离，可以通过属性文件、YAML文件、环境变量等方式进行配置，使得应用程序更具灵活性。 简化的安全性配置：Spring Boot简化了安全性配置，通过起步依赖可以很容易地添加安全性功能，例如身份验证和授权。 容易集成：Spring Boot与其他Spring生态系统组件无缝集成，例如Spring Data、Spring Security等。 开发步骤 项目初始化： 创建一个新的Maven或Gradle项目，或者使用现有的项目作为基础。 在项目的构建文件中添加Spring相关依赖，如Spring Boot起步依赖或Spring框架的核心模块。 定义数据模型： 根据应用程序的需求，定义实体类（POJO）来表示数据模型，这些实体类通常映射到数据库表。 使用注解（如@Entity、@Table等）来标识实体类，并定义实体类的属性以及它们之间的关系（如一对多、多对一等）。 创建数据访问层： 使用Spring的数据访问技术（如Spring Data JPA或Spring JDBC）来访问数据库。 定义Repository接口，通过方法签名来声明数据查询和操作。Spring将根据方法命名约定自动生成查询。 创建业务逻辑层： 实现Service层，用于处理业务逻辑。 在Service层中调用数据访问层的方法，处理业务逻辑，并对数据进行处理和转换。 创建控制器层： 创建Controller类，用于处理HTTP请求和响应。 使用注解（如@RestController、@RequestMapping等）来标识控制器，并定义请求映射。 配置依赖注入： 使用Spring的依赖注入（DI）机制来管理组件之间的依赖关系。 在类中使用@Autowired注解来标记需要自动注入的依赖。 配置应用程序： 配置应用程序的属性，可以使用application.properties或application.yml文件进行配置。 定义数据源、日志配置、端口号等应用程序相关的配置信息。 处理异常和错误： 实现全局异常处理，以处理应用程序中出现的异常和错误情况。 可以使用@ControllerAdvice注解来定义全局异常处理类。 测试应用程序： 编写单元测试和集成测试来验证应用程序的功能和正确性。 使用JUnit、Mockito等测试框架来编写和运行测试用例。 运行应用程序： 使用Maven或Gradle构建项目，并生成可执行的JAR或WAR文件。 使用命令行或集成开发环境（IDE）来运行应用程序。 部署应用程序： 将生成的可执行文件部署到服务器或云平台上，以使应用程序可以在生产环境中运行。 创建Spring Boot项目 打开浏览器，并访问Spring Initializr网站：https://start.spring.io/ 在Spring Initializr网站上，可以看到一个简单的界面，用于配置新项目的基本信息。需要提供以下信息： 项目信息：输入项目的基本信息，如Group、Artifact、Name和Description。 依赖：选择需要的起步依赖。这些依赖将自动添加到的项目中，并提供所需的功能，如Web、数据访问、安全等。 Java版本：选择希望使用的Java版本。 配置完成后，点击&quot;Generate&quot;按钮，Spring Initializr将生成一个包含配置的项目结构的Zip文件。 下载生成的Zip文件，并解压到的开发环境中。 使用喜欢的IDE（如IntelliJ IDEA、Eclipse等），打开解压后的项目文件夹。 如果使用Maven，可以直接导入为Maven项目，IDE会自动检测并加载Maven依赖。 开始编写的Spring Boot应用程序的代码，包括控制器、业务逻辑和数据访问等。 运行Spring Boot应用程序，可以使用IDE的运行按钮或使用命令行运行mvn spring-boot:run。 通过浏览器或其他工具访问的应用程序，检查是否正常运行。 IDEA创建Spring Boot项目 打开IntelliJ IDEA，并选择&quot;Create New Project&quot;（创建新项目）。 在弹出的窗口中，选择&quot;Spring Initializr&quot;选项，然后点击&quot;Next&quot;（下一步）。 在下一个窗口中，配置项目的基本信息： Project SDK：选择希望使用的Java SDK版本。 Spring Initializr Service URL：默认情况下，IntelliJ IDEA会自动使用Spring Initializr服务。如果有特定需求，也可以选择使用本地的Spring Initializr服务。 Project：选择&quot;Maven&quot;或&quot;Gradle&quot;作为构建工具。 Language：选择Java。 Group：输入的项目组织或公司的名称。 Artifact：输入项目的名称。 Name：输入项目的显示名称。 Description：输入项目的描述信息（可选）。 确保配置正确后，点击&quot;Next&quot;（下一步）。 在下一个窗口中，选择需要的Spring Boot起步依赖。可以根据项目需求选择Web、数据访问、安全等不同的依赖。选择完成后，点击&quot;Next&quot;（下一步）。 接下来，选择项目存储路径，并配置项目的命名空间（package）。 完成以上步骤后，点击&quot;Finish&quot;（完成），IntelliJ IDEA将会为创建一个Spring Boot项目，并自动下载和配置所需的依赖。 项目创建完成后，可以在IDEA的项目视图中看到项目的结构，其中包含了主应用程序类（通常带有@SpringBootApplication注解）和默认的目录结构。 开始编写的Spring Boot应用程序的代码，包括控制器、业务逻辑和数据访问等。 运行Spring Boot应用程序，可以在主应用程序类上点击右键，然后选择&quot;Run 'YourApplicationName'&quot;，或者使用快捷键Shift + F10运行。 在启动成功后，通过浏览器或其他工具访问的应用程序，检查是否正常运行。 取消启动banner图标 在Spring Boot应用启动时，会默认显示一个启动banner图标，包含Spring Boot的Logo以及项目的名称和版本等信息。有时候，我们可能希望取消这个启动banner图标的显示，以便在控制台中获得更干净的输出。 方法一：通过配置文件取消 可以通过在application.properties或application.yml配置文件中添加如下配置来取消启动banner图标的显示： spring.main.banner-mode=off 或者在application.yml中： spring: main: banner-mode: off 方法二：通过编程方式取消 我们还可以通过编程方式取消启动banner图标的显示，即在Spring Boot应用的主类中添加相应的代码。下面是一个Java代码示例： import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication app = new SpringApplication(MyApplication.class); app.setBannerMode(Banner.Mode.OFF); // 取消启动banner图标的显示 app.run(args); } } 在上述代码中，我们通过SpringApplication类的setBannerMode()方法将启动banner图标的显示模式设置为Banner.Mode.OFF，从而取消了启动时的图标显示。 Sprin引导类 在Spring Boot中，引导类（Bootstrap Class）是一个Java类，它是Spring Boot应用程序的入口点。引导类通常是一个带有main方法的类，它被用来启动应用程序。 引导类的主要作用是启用Spring Boot框架和自动配置。它会自动扫描应用程序中的组件（组件扫描），加载配置文件，并根据依赖关系和配置信息自动配置应用程序的各种功能。 在引导类中，需要使用@SpringBootApplication注解来标记该类。@SpringBootApplication是一个复合注解，包含了@Configuration、@EnableAutoConfiguration和@ComponentScan三个注解。它们的作用如下： @Configuration: 声明该类是一个配置类，相当于Spring中的XML配置文件。 @EnableAutoConfiguration: 开启Spring Boot的自动配置功能。它会根据项目的依赖和配置，自动配置各种Spring框架和第三方库的Bean。 @ComponentScan: 启用组件扫描，Spring Boot会自动扫描引导类所在包及其子包下的组件（包括控制器、服务、存储库等），将它们注册为Spring的Bean。 示例引导类代码如下： import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 在上述示例中，MyApplication类是引导类，通过SpringApplication.run()方法启动了Spring Boot应用程序。 小贴士 引导类应该放在项目的根包下或者根包的子包下，这样可以确保@ComponentScan扫描到所有需要注册为Bean的组件。一旦引导类配置好，Spring Boot将会根据其自动配置的特性，简化应用程序的开发和部署过程。 和传统Spring框架对比 特点 Spring Boot 传统 Spring 框架 概述 用于简化Java应用程序开发的开源框架 综合的Java企业级应用程序框架 项目初始化 提供快速初始化项目的工具 需要手动配置和初始化项目 配置简化 配置更简化，采用约定优于配置原则 配置相对复杂，需要显式配置各种组件 使用起步依赖 使用起步依赖（Starter）简化依赖管理 需要手动管理项目所需的依赖 内置嵌入式Web服务器 内置Tomcat、Jetty等嵌入式Web服务器 需要手动部署Web服务器 XML配置 vs Java配置 推荐使用基于Java的配置，如注解和Java Config 主要使用XML配置（也支持注解和Java Config） 组件自动配置 自动配置Spring Bean和其他组件，无需手动配置 需要显式配置Spring Bean和其他组件 环境配置 使用application.properties或application.yaml进行配置 使用properties或XML文件进行配置 版本兼容性 版本兼容性较好，更容易进行升级和迁移 升级和迁移相对复杂，可能需要修改部分配置和代码 微服务和云原生应用支持 优秀的支持微服务和云原生应用开发 支持微服务和云原生应用开发，但需要更多手动配置和集成 小贴士 Spring Boot和传统Spring框架并不是彼此互斥的，Spring Boot是在传统Spring框架的基础上进行进一步简化和封装，目的是提供更便捷的开发体验。 在选择使用哪种框架时，可以根据项目需求、团队经验以及个人偏好来进行权衡和决策。 与Spring开发的异同 相同点： 定义数据模型：无论是使用Spring还是Spring Boot，都需要定义数据模型，即实体类（POJO），用于表示数据模型和数据库映射。 创建数据访问层：在两种情况下，都需要创建数据访问层，使用Spring的数据访问技术（如Spring Data JPA或Spring JDBC）来访问数据库。 创建业务逻辑层：业务逻辑的处理在Spring和Spring Boot中都是必要的，通过Service层来实现。 创建控制器层：在Spring和Spring Boot中都需要创建Controller类，用于处理HTTP请求和响应。 配置依赖注入：在Spring和Spring Boot中，都使用依赖注入（DI）机制来管理组件之间的依赖关系。 处理异常和错误：在两种情况下，都需要处理异常和错误情况，实现全局异常处理。 测试应用程序：无论使用Spring还是Spring Boot，编写单元测试和集成测试来验证应用程序的功能和正确性是必要的。 不同点： 配置方式：最显著的不同是配置方式。在传统的Spring框架中，需要手动配置大部分内容，包括数据源、事务管理、Web容器等，通常需要使用XML配置文件。而在Spring Boot中，采用&quot;约定优于配置&quot;的原则，很多配置都是自动完成的，可以通过属性文件或YAML文件来进行配置。 起步依赖：Spring Boot引入了起步依赖的概念，通过这种方式，可以很方便地添加所需功能的依赖，而不需要手动选择和配置每个依赖项。这在传统的Spring框架中是没有的。 嵌入式Web服务器：Spring Boot内置了常用的Web服务器（如Tomcat、Jetty和Undertow），使得可以以独立应用程序的形式运行Web应用，而传统的Spring框架通常需要将应用部署到外部的Web容器中。 项目初始化：在使用Spring Boot时，可以使用Spring Initializr工具来快速初始化一个Spring Boot项目，选择需要的依赖项和配置，从而大大简化了项目的初始化过程。 简化配置：由于Spring Boot的自动配置特性，很多常规的配置都不再需要手动编写，使得开发者能够更加专注于业务逻辑的实现。 与Spring配置的差异 配置区别 Spring开发 Spring Boot开发 配置方式 使用XML配置文件进行手动配置 采用&quot;约定优于配置&quot;，使用属性文件或YAML文件进行自动配置 依赖管理 需要手动管理依赖项 引入起步依赖，能够快速添加所需功能的依赖 数据源配置 需要手动配置数据源 自动根据配置文件设置数据源和数据库连接池 Web服务器配置 需要手动部署到外部Web服务器（如Tomcat、Jetty等） 内置嵌入式Web服务器（如Tomcat、Jetty和Undertow），可以独立运行Web应用 项目初始化 手动创建并配置项目 使用Spring Initializr工具快速初始化项目 简化配置 需要手动编写大量常规配置 自动化配置，减少了常规配置的编写 事务管理 需要手动配置事务管理 自动配置事务管理，无需手动设置事务 组件扫描 需要手动配置组件扫描 自动扫描组件，无需手动配置扫描路径 简化REST API开发 需要额外配置REST API（如使用Spring MVC） 内置Spring Web模块，简化REST API的开发 管理端点和健康检查 需要手动配置Actuator端点和健康检查 自动暴露Actuator端点，可用于监控和管理应用程序 自动配置和装配 需要手动配置和装配组件 自动配置和装配组件，减少了手动配置的复杂性 注意：上述表格中的内容是一般性的配置区别，具体差异可能因实际项目和版本而有所不同。Spring Boot的自动化配置使得开发者能够更快速地启动和运行应用程序，而传统的Spring开发可能需要手动处理更多的配置和集成工作。 依赖配置 起步依赖 Spring Boot的起步依赖（Starter Dependencies）是一组预配置的依赖项，它们使能够快速启动和运行特定类型的应用程序。这些依赖项将常用的库和框架集成到项目中，无需手动添加大量依赖项或配置文件，从而简化了开发过程。 Spring Boot的起步依赖通常以spring-boot-starter-*的命名形式出现，其中*表示不同类型的功能或模块。以下是一些常见的Spring Boot起步依赖： spring-boot-starter-web：用于构建Web应用程序，包含了Spring MVC、Tomcat（或其他嵌入式Web服务器）以及其他与Web开发相关的依赖。 spring-boot-starter-data-jpa：用于使用JPA（Java Persistence API）进行数据持久化，包含了Spring Data JPA和与JPA相关的依赖。 spring-boot-starter-data-mongodb：用于使用MongoDB数据库，包含了Spring Data MongoDB和MongoDB驱动的依赖。 spring-boot-starter-thymeleaf：用于使用Thymeleaf模板引擎进行视图渲染。 spring-boot-starter-security：用于实现基本的安全功能，包含了Spring Security和一些与安全相关的依赖。 spring-boot-starter-test：用于编写单元测试和集成测试，包含了JUnit、Mockito等测试框架的依赖。 spring-boot-starter-actuator：用于监控和管理Spring Boot应用程序，包含了健康检查、监控端点等依赖。 除了上述常见的起步依赖，还有很多其他功能的起步依赖可供选择，涵盖了各种场景和需求。 小贴士 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的 spring-boot-starter-parent（2.5.0）与 spring-boot-starter-parent（2.4.6）共计57处坐标版本不同 使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供。如发生坐标错误，再指定version（要小心版本冲突） Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--web起步依赖环境中，排除Tomcat起步依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加Jetty起步依赖，版本由SpringBoot的starter控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写规范 在Spring Boot项目中，可以使用Maven或Gradle来管理依赖项。无论选择哪种构建工具，依赖坐标的编写规范都遵循相应的标准。下面我将分别介绍Maven和Gradle的依赖坐标编写规范： Maven 依赖坐标编写规范 在Maven的pom.xml文件中，可以通过&lt;dependency&gt;元素来添加依赖项。Maven的依赖坐标包括三个主要部分：groupId、artifactId和version。编写规范如下： &lt;dependency&gt; &lt;groupId&gt;组织或公司标识&lt;/groupId&gt; &lt;artifactId&gt;项目或模块标识&lt;/artifactId&gt; &lt;version&gt;版本号&lt;/version&gt; &lt;/dependency&gt; 例如，添加Spring Boot的Web起步依赖，可以使用以下坐标： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/dependency&gt; Gradle 依赖坐标编写规范 在Gradle的build.gradle文件中，可以通过dependencies块来添加依赖项。Gradle的依赖坐标由group、name和version组成。编写规范如下： dependencies { implementation group: '组织或公司标识', name: '项目或模块标识', version: '版本号' } 例如，使用Gradle添加Spring Boot的Web起步依赖，可以使用以下坐标： dependencies { implementation group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '2.5.2' } 无论使用Maven还是Gradle，确保依赖坐标编写正确，这样构建工具才能正确解析并下载相应的依赖项。同时，版本号的选择也很重要，确保使用稳定和兼容的版本，以避免潜在的问题和冲突。通过遵循这些规范，可以有效地管理Spring Boot项目的依赖项。 项目配置 配置方式 Spring Boot提供了多种配置形式，使可以根据项目需求选择最合适的配置方式。以下是Spring Boot常见的配置形式： 应用程序属性配置文件（Application Properties/YAML）：这是最常用的配置方式之一，通过在应用程序的属性配置文件中定义属性键值对来配置应用程序。属性配置文件可以是标准的.properties文件，也可以是更灵活的.yaml或.yml文件。可以在配置文件中设置各种属性，包括数据库连接、服务器端口、日志级别等。 命令行参数：可以通过命令行传递参数来配置Spring Boot应用程序。例如，可以使用--server.port=8080来指定服务器端口，或使用--spring.datasource.url=jdbc:mysql://localhost:3306/mydb来指定数据库连接URL。 环境变量：可以使用操作系统的环境变量来配置Spring Boot应用程序。Spring Boot会自动将环境变量与应用程序的属性进行匹配。 Java系统属性：可以通过Java系统属性来配置Spring Boot应用程序。这可以通过在应用程序启动命令中使用-D参数来设置。 配置类：可以创建一个专门的配置类，并使用注解（如@Configuration、@Bean等）来定义和配置应用程序的组件。 自定义配置文件：除了应用程序属性配置文件外，还可以使用自定义的配置文件。通过使用@PropertySource注解或在@Configuration类中使用@PropertySources注解，可以引入其他的属性配置文件。 Profile（环境）配置：Spring Boot支持使用不同的环境配置文件，例如application-dev.properties、application-prod.properties等，用于在不同的环境中设置不同的配置。可以使用spring.profiles.active属性指定当前激活的环境配置。 配置文件优先级 Spring Boot项目中同时存在application.yml、application.yaml和application.properties这三个配置文件，Spring Boot会按照一定的优先级顺序加载这些配置文件。具体的优先级如下：application.properties &gt; application.yml &gt; application.yaml application.properties: 这是最常见的Spring Boot配置文件，默认的配置文件名。如果存在该文件，它将具有最高的优先级。 application.yml和application.yaml: 这两个文件的优先级相同，如果同时存在，它们的配置将会合并。如果想使用application.yml和application.yaml文件中的配置，建议使用yaml格式，因为它更易读、易写。 根据上述优先级，当三个配置文件都存在时，application.properties的配置将拥有最高优先级，而application.yml和application.yaml的配置将会合并，并在有冲突的情况下，后面加载的配置文件会覆盖前面加载的配置文件中的相同配置项。如果在application.yml和application.yaml文件中存在相同配置项的冲突，后加载的配置文件将会覆盖前面加载的配置文件中的相同配置项。 properties 概述 Properties文件是一种常用的配置文件格式，通常用于存储简单的键值对配置信息。它在Java应用程序中广泛用于配置各种参数和选项。 语法规则 键值对：每行表示一个键值对，用等号（=）或冒号（:）分隔键和值，并且键与值之间没有空格。 key1=value1 key2:value2 注释：使用井号（#）或感叹号（!）作为注释的起始字符。注释会被忽略，不会影响配置解析。 # 这是注释 key=value # 这也是注释 空行：空行会被忽略，可以用于增加配置文件的可读性。 key=value key2=value2 转义字符：如果键或值中包含等号、冒号、井号或感叹号等特殊字符，可以使用反斜杠（\\）进行转义。 special\\=key=value 注意事项 键和值的顺序不影响配置文件的解析，但是建议保持一致性，便于阅读和维护。 键是唯一的，不可重复，如果出现重复的键，后面的键值对会覆盖前面的。 键和值都可以是字符串，不过值会被当作字符串来处理。如果需要其他类型的值，需要在代码中进行类型转换。 Properties文件通常用于存储简单的配置信息，对于复杂的数据结构，可以考虑使用YAML或JSON等格式。 Properties文件是以ISO-8859-1字符集编码的，如果需要包含非ASCII字符，需要进行正确的编码转换。 在Java中，可以使用java.util.Properties类来读取和处理Properties文件，也可以通过Spring框架提供的@PropertySource注解来加载Properties配置文件。确保在使用Properties文件时遵循以上语法规则和注意事项，以确保配置文件能够正确解析和使用。 使用 创建Properties配置文件： 在src/main/resources目录下创建一个新的文件，命名为application.properties。 编写配置信息： 在application.properties文件中，按照键值对的方式编写配置信息。示例如下： server.port=8080 spring.datasource.url=jdbc:mysql://localhost:3306/mydb spring.datasource.username=myuser spring.datasource.password=mypassword 加载配置信息： 与使用YAML配置文件类似，Spring Boot会自动加载application.properties中的配置信息，并将其转换为Java对象供应用程序使用。你可以在代码中通过@Value注解或者@ConfigurationProperties注解来获取配置值。 使用@Value注解示例： import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyComponent { @Value(&quot;${server.port}&quot;) private int serverPort; @Value(&quot;${spring.datasource.url}&quot;) private String dbUrl; // 其他业务逻辑 } 或者使用@ConfigurationProperties注解： import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public class DataSourceConfig { private String url; private String username; private String password; // getter和setter方法 } 或者使用Environment对象： import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.core.env.Environment; @SpringBootApplication public class MyApp { @Autowired private Environment environment; public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } // 在应用程序的某个方法中使用Environment对象 public void printConfigProperty() { String propertyValue = environment.getProperty(&quot;spring.datasource.url&quot;); System.out.println(&quot;配置属性的值：&quot; + propertyValue); } } 运行项目： 在配置文件编写完成后，启动Spring Boot应用程序，它将自动加载Properties配置文件中的配置，并将其应用于相应的组件。 YAML 概述 YAML（YAML Ain't Markup Language）是一种用于数据序列化的格式，它的设计目标是人类可读性高、易于书写和解析。YAML的文件扩展名可以是.yaml或.yml，这两种扩展名可以互相替代使用，没有本质上的区别。 实际上，.yml是.yaml的简化形式，它是为了在文件名中更方便地表示YAML格式而引入的。YAML规范定义了.yaml作为官方的文件扩展名，但.yml也得到广泛接受并广泛使用，尤其在许多编程框架和工具中，.yml被作为默认的YAML文件扩展名。 因此，yml和yaml在功能和语法上是完全相同的，唯一的区别就是文件扩展名的不同。可以根据个人喜好或特定的编程环境来选择使用.yml或.yaml的文件扩展名。无论选择哪个扩展名，YAML解析器都能够正确地解析文件内容。 语法规则 键值对：使用冒号(:)表示键值对，键和值之间用空格隔开。 key: value 列表：使用连字符(-)表示列表中的元素，每个元素占一行，与前面的元素用空格隔开。 - item1 - item2 - item3 嵌套结构：可以嵌套使用键值对和列表，用空格缩进表示层级关系。 key1: subkey1: value1 subkey2: value2 key2: - item1 - item2 注释：使用井号(#)表示注释，从#开始到行末的内容都将被视为注释，不会被解析。 # 这是注释 key: value # 这也是注释 多行字符串：使用|表示保留换行的多行字符串，内容会保留原格式。 multi-line: | This is a multi-line string. 折叠多行字符串：使用&gt;表示折叠多行字符串，换行符会被转换为空格。 folded-line: &gt; This is a folded multi-line string. 注意事项 缩进和格式：YAML使用缩进来表示层级关系，通常使用空格作为缩进，但不要混用空格和制表符。建议在整个配置文件中保持一致的缩进风格，以避免解析错误。 大小写敏感：YAML是大小写敏感的，因此Key和key是不同的键。要保持键的一致性，以便正确匹配和获取配置项。 注释：YAML支持使用#符号进行行内注释，但不支持块注释。注释应该放在合适的位置，提高配置文件的可读性，但要注意不要在重要的键值对上方添加注释，以免干扰解析。 引号：在需要的情况下使用引号来包裹字符串，特别是包含特殊字符或空格的字符串。YAML支持单引号、双引号和折叠式引号。 key: &quot;value with spaces&quot; key2: 'single-quoted value' 特殊字符：一些特殊字符，如:、#、{、}等，需要进行转义处理，使用反斜杠（\\）进行转义。 多行字符串：YAML支持多行字符串，可以使用|或&gt;符号表示。 使用|表示保留换行符，保持多行文本的原样格式。 使用&gt;表示折叠换行符，将多行文本折叠成一行，并用空格替换换行符。 key1: | This is a multiline text. key2: &gt; This is a multiline text. 数组：YAML中的数组可以使用方括号（[]）表示，数组元素之间使用逗号（,）分隔。 fruits: - apple - banana - orange 对象：YAML中的对象可以使用冒号（:）表示，冒号后的值可以是简单的值，也可以是嵌套的对象。 person: name: John age: 30 address: city: New York zip: &quot;10001&quot; 类型推断：YAML会根据内容自动推断数据类型，如字符串、整数、布尔值等。确保键值对的值按照预期类型进行书写，避免类型错误。 包含文件：YAML支持通过!include或!include_dir_merge_list等标签来包含其他文件或目录，但这取决于解析器的支持和配置。 使用 在Spring Boot中，使用YAML配置文件是非常常见和方便的。YAML配置文件可以替代传统的Properties配置文件，并且在Spring Boot项目中，使用YAML配置文件可以更加清晰地组织配置信息，提高可读性和维护性。下面是在Spring Boot中使用YAML配置文件的基本步骤： 创建YAML配置文件： 在Spring Boot项目的src/main/resources目录下创建一个新的文件，命名为application.yml或者application.yaml。这是Spring Boot默认加载的配置文件名。 编写配置信息： 在application.yml文件中，可以使用YAML的语法来编写配置信息。以下是一个简单的示例： server: port: 8080 spring: datasource: url: jdbc:mysql://localhost:3306/mydb username: myuser password: mypassword 加载配置信息： Spring Boot会自动加载application.yml中的配置信息，并将其转换为Java对象，供应用程序使用。你可以在代码中通过@Value注解或@ConfigurationProperties注解来获取配置值。 示例代码： import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyComponent { @Value(&quot;${server.port}&quot;) private int serverPort; @Value(&quot;${spring.datasource.url}&quot;) private String dbUrl; // 其他业务逻辑 } 或者使用@ConfigurationProperties注解： import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public class DataSourceConfig { private String url; private String username; private String password; // getter和setter方法 } 运行项目： 在配置文件编写完成后，启动Spring Boot应用程序，它将自动加载YAML配置文件中的配置，并将其应用于相应的组件。 自定义对象封装数据警告解决方案 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 比较 特点 YAML Properties 结构 使用缩进和层级结构，更具可读性 使用键值对的形式，较为扁平 嵌套支持 支持嵌套结构，可以表示复杂的数据关系 不支持嵌套结构，仅适合简单的键值对配置 注释 支持行内注释和块注释 仅支持行内注释 数据类型推断 自动推断数据类型，支持字符串、整数、浮点数、布尔值等 一般将所有值都视为字符串类型 字符串表示 支持多行字符串和引号表示，可保留换行符 一般使用单行字符串表示，换行使用转义字符 键名大小写敏感 大小写敏感，键名区分大小写 大小写不敏感，键名不区分大小写 特殊字符转义 支持特殊字符转义，使用反斜杠（\\）进行转义 特殊字符通常不需要转义 数组和列表 使用短横线（-）表示数组或列表的元素 不直接支持数组或列表，通常使用逗号分隔多个值 文件引入 支持通过!include标签引入其他文件或片段 不支持直接引入其他文件，但可以通过代码或工具实现 扩展性和可读性 结构清晰，易于理解和维护 简单直观，适用于小型配置文件 生态和应用领域的支持 主要在现代开发中使用，如Spring Boot和其他云原生应用 在传统Java应用中广泛使用，特别是基于Java EE的企业应用 需要根据具体的需求和项目环境选择适合的配置文件格式。YAML适合复杂的配置结构和需要更好可读性的场景，而Properties适合简单的键值对配置和传统Java应用的场景。 多环境配置 概述 在Spring Boot中，你可以使用标准的YAML配置文件来配置多个环境（多环节）的启动参数。通过使用不同的配置文件，你可以为不同的环境提供不同的配置，比如开发环境、测试环境和生产环境。这样可以方便地切换配置，而无需更改代码。 标准的YAML配置文件命名规则是application-{profile}.yml，其中{profile}是你要指定的环境名称，比如dev、test、prod等。默认情况下，Spring Boot会加载名为application.yml的主配置文件，如果存在对应环境的配置文件，例如application-dev.yml，则会根据当前激活的环境加载相应的配置，覆盖主配置文件中的属性。 方式一 创建application.yml主配置文件： # application.yml - 主配置文件 myapp: name: &quot;My App&quot; version: &quot;1.0.0&quot; 创建application-dev.yml开发环境配置文件： # application-dev.yml - 开发环境配置文件 myapp: db: url: &quot;jdbc:mysql://localhost:3306/dev_db&quot; username: &quot;dev_user&quot; password: &quot;dev_password&quot; 创建application-test.yml测试环境配置文件： # application-test.yml - 测试环境配置文件 myapp: db: url: &quot;jdbc:mysql://localhost:3306/test_db&quot; username: &quot;test_user&quot; password: &quot;test_password&quot; 创建application-prod.yml生产环境配置文件： # application-prod.yml - 生产环境配置文件 myapp: db: url: &quot;jdbc:mysql://production-server/prod_db&quot; username: &quot;prod_user&quot; password: &quot;prod_password&quot; 根据上面的配置，当你在不同的环境中启动应用程序时，Spring Boot会自动加载对应的配置文件。例如，在开发环境中启动应用程序，它会加载application.yml和application-dev.yml，从而使用开发环境的数据库配置。 你可以通过在启动命令中指定--spring.profiles.active参数来激活特定的配置环境，比如： java -jar your-application.jar --spring.profiles.active=dev 这样，应用程序将加载application.yml和application-dev.yml的配置。 方式二 可以在YAML配置文件中进行Spring Boot的多环境配置。Spring Boot支持使用.yml或.yaml格式的配置文件。下面是在YAML配置文件中进行多环境配置的步骤： 创建配置文件：为每个环境创建不同的YAML配置文件，命名为application-{profile}.yml或application-{profile}.yaml，其中{profile}是环境名称（例如dev表示开发环境，test表示测试环境，prod表示生产环境）。 配置属性：在每个配置文件中，使用YAML的语法来设置对应环境的属性值。例如，数据库连接信息、日志级别、第三方服务的URL等。 以下是一个示例的YAML配置文件： # application-dev.yml spring: profiles: active: dev # 数据库配置 datasource: url: jdbc:mysql://localhost:3306/devdb username: devuser password: devpass # 日志配置 logging: level: root: INFO com.example: DEBUG # 其他配置项 myapp: someProperty: value 设置当前环境：与前面的方法类似，在应用启动时，可以通过spring.profiles.active属性来指定当前的环境。可以在YAML配置文件中添加以下配置： spring: profiles: active: dev # 新的写法如下 spring: config: active: on-profile: dev 使用@Profile注解：除了配置文件外，仍然可以使用@Profile注解在Java代码中标注特定环境的配置类或方法，以控制在特定环境下是否生效。 配置分类 在 Spring Boot 中，可以通过不同级别的配置文件来覆盖和补充应用程序的配置。以下是 Spring Boot 中的四级配置文件，按优先级从高到低排列： 1级：file:config/application.yml（最高优先级）：位于项目根目录的 config 文件夹下的 application.yml 配置文件。此配置文件具有最高的优先级，任何在该文件中定义的配置将覆盖其他级别的配置。 2级：file:application.yml：位于项目根目录下的 application.yml 配置文件。如果某些配置没有在 file:config/application.yml 中定义，将尝试在此处查找配置。 3级：classpath:config/application.yml：位于 classpath（类路径）下的 config 文件夹下的 application.yml 配置文件。如果某些配置没有在上述两个文件中定义，将尝试在此处查找配置。 4级：classpath:application.yml（最低优先级）：位于 classpath（类路径）下的 application.yml 配置文件。如果所有其他级别的配置都没有定义某些配置，将尝试在此处查找默认配置。 配置文件的优先级由上到下，高优先级的配置将覆盖低优先级的配置。这种配置文件层级的设计使得在不同环境中使用不同的配置变得十分灵活，可以根据需要选择性地覆盖或补充配置，而无需改变应用程序代码。1级与2级留做系统打包后设置通用属性。3级与4级用于系统开发阶段设置通用属性。 存放位置 src/main/resources 目录： 这是默认的配置文件存放位置。将配置文件放在 src/main/resources 目录下可以让 Spring Boot 自动加载并应用这些配置。 外部目录： 可以通过指定启动时的命令行参数 --spring.config.location 或环境变量 SPRING_CONFIG_LOCATION 来指定外部目录，其中包含应用程序的配置文件。例如，java -jar myapp.jar --spring.config.location=/path/to/config/。 classpath 目录之外的地方： 除了 src/main/resources 目录，Spring Boot 还支持从 classpath 目录之外的其他位置加载配置文件。通过使用 --spring.config.additional-location 参数，可以指定其他的配置文件位置，例如 java -jar myapp.jar --spring.config.additional-location=/path/to/external/config/。 项目根目录： 在项目根目录中直接放置配置文件也是可以的，但通常不建议这样做，以免混淆项目结构。 配置优先级 参考文档：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments. You can use a variety of external configuration sources including Java properties files, YAML files, environment variables, and command-line arguments. Property values can be injected directly into your beans by using the @Value annotation, accessed through Spring’s Environment abstraction, or be bound to structured objects through @ConfigurationProperties. Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Later property sources can override the values defined in earlier ones. Sources are considered in the following order: Default properties (specified by setting SpringApplication.setDefaultProperties). @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins. Config data (such as application.properties files). A RandomValuePropertySource that has properties only in random.*. OS environment variables. Java System properties (System.getProperties()). JNDI attributes from java:comp/env. ServletContext init parameters. ServletConfig init parameters. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). Command line arguments. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application. @DynamicPropertySource annotations in your tests. @TestPropertySource annotations on your tests. Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active. Maven与SpringBoot多环境兼容 当使用 Maven 和 Spring Boot 进行多环境兼容配置时，可以通过 Maven 的 profiles 和 Spring Boot 的多环境配置文件相结合来实现。下面是详细的步骤： 步骤 1：创建 Maven 的 profiles 在项目的根目录下，打开 pom.xml 文件。 在 &lt;project&gt; 元素下添加 &lt;profiles&gt; 元素，用于定义不同的环境配置。 在 &lt;profiles&gt; 元素中，添加多个 &lt;profile&gt; 元素，每个 &lt;profile&gt; 元素代表一个环境配置（如开发、测试、生产等）。 在每个 &lt;profile&gt; 元素中，可以设置 &lt;id&gt; 属性来标识该配置，并通过 &lt;properties&gt; 元素设置环境相关的属性值。例如，可以设置数据库连接信息、日志级别等。 确保每个 &lt;profile&gt; 元素包含 &lt;activation&gt; 元素，用于指定激活该配置的条件。例如，可以根据 Maven 的 activeByDefault 属性或环境变量来激活特定的配置。 示例 pom.xml 文件： &lt;project&gt; &lt;!-- 其他项目配置 --&gt; &lt;profiles&gt; &lt;!-- 开发环境配置 --&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;spring.profiles.active&gt;dev&lt;/spring.profiles.active&gt; &lt;!-- 其他环境相关的属性 --&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;!-- 测试环境配置 --&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;spring.profiles.active&gt;test&lt;/spring.profiles.active&gt; &lt;!-- 其他环境相关的属性 --&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- 生产环境配置 --&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;spring.profiles.active&gt;prod&lt;/spring.profiles.active&gt; &lt;!-- 其他环境相关的属性 --&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 其他项目配置 --&gt; &lt;/project&gt; 步骤 2：创建 Spring Boot 的多环境配置文件 在 src/main/resources 目录下，创建多个配置文件，每个配置文件代表一个环境配置。例如，可以创建 application-dev.properties（用于开发环境）、application-test.properties（用于测试环境）、application-prod.properties（用于生产环境）等。 在每个配置文件中，设置与相应环境相关的属性值。例如，可以设置数据库连接信息、日志级别等。 示例 application-dev.properties 文件： # 开发环境数据库连接信息 spring.datasource.url=jdbc:mysql://localhost:3306/dev_db spring.datasource.username=dev_user spring.datasource.password=dev_password # 开发环境日志级别 logging.level.root=DEBUG 示例 application-test.properties 文件： # 测试环境数据库连接信息 spring.datasource.url=jdbc:mysql://localhost:3306/test_db spring.datasource.username=test_user spring.datasource.password=test_password # 测试环境日志级别 logging.level.root=INFO 示例 application-prod.properties 文件： # 生产环境数据库连接信息 spring.datasource.url=jdbc:mysql://production-server:3306/prod_db spring.datasource.username=prod_user spring.datasource.password=prod_password # 生产环境日志级别 logging.level.root=WARN 步骤 3：使用 Maven 配置打包 使用 Maven 的 maven-resources-plugin 插件配置打包过程，使得对应环境的配置文件能够正确地打包到最终的可执行 Jar 或 War 文件中。 在 pom.xml 中添加以下插件配置： &lt;project&gt; &lt;!-- 其他项目配置 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 其他插件配置 --&gt; &lt;!-- Maven Resources Plugin 配置 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimiter&gt;@&lt;/delimiter&gt; &lt;/delimiters&gt; &lt;useDefaultDelimiters&gt;false&lt;/useDefaultDelimiters&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 其他项目配置 --&gt; &lt;/project&gt; 步骤 4：运行应用程序 使用 Maven 打包应用程序。在项目根目录下执行命令：mvn clean package。 Maven 将根据配置的激活环境打包对应的配置文件到可执行 Jar 或 War 文件中。 运行应用程序时，可以使用以下方式激活特定的配置文件： 使用命令行参数：java -jar myapp.jar --spring.profiles.active=dev 使用环境变量：export SPRING_PROFILES_ACTIVE=dev（Linux 环境） 在 application.properties 或 application.yml 中指定：spring.profiles.active=dev 通过以上步骤，可以成功实现 Maven 与 Spring Boot 的多环境兼容配置。在不同的环境中，应用程序将使用相应的配置文件，从而确保在不同环境下应用程序的正确运行和部署。 加载Maven对应的属性 对于源码中非 Java 类（例如 XML 配置文件、YAML 配置文件、资源文件等）的操作，如果希望加载 Maven 对应的属性，可以使用 Spring Boot 提供的占位符机制和配置文件加载策略来实现。 使用占位符机制： 在 Spring Boot 中，可以在配置文件中使用占位符来引用 Maven 的属性。Maven 的属性可以通过 ${} 语法在配置文件中进行引用。 示例 application.yml 文件： server: port: ${server.port} datasource: url: ${spring.datasource.url} username: ${spring.datasource.username} password: ${spring.datasource.password} 在上述示例中，${server.port}、${spring.datasource.url}、${spring.datasource.username} 和 ${spring.datasource.password} 都是引用了 Maven 中定义的属性，Spring Boot 将在启动时根据 Maven 属性的值进行替换。 配置文件加载策略： Spring Boot 会自动加载项目根目录下的 application.properties 或 application.yml 配置文件。但如果希望在其他位置放置配置文件，并加载 Maven 的属性，可以通过以下方式实现： 将配置文件放置在 Maven 项目的 src/main/resources 目录中，然后在配置文件中使用占位符引用 Maven 的属性，如前面的示例所示。 如果希望在其他位置放置配置文件（例如外部目录），可以使用 --spring.config.location 参数指定外部配置文件的位置。例如，java -jar myapp.jar --spring.config.location=/path/to/config/。Spring Boot 将自动加载指定位置的配置文件，并根据 Maven 属性的值进行替换。 总之，可以在源码中的非 Java 类中使用 Spring Boot 的占位符机制，通过引用 Maven 的属性来实现配置的加载。同时，可以根据需要选择合适的配置文件加载策略，确保配置文件能够正确加载 Maven 的属性值。这样，可以在不同环境中更加灵活地配置应用程序的属性。 假设有一个 Spring Boot 应用程序，需要配置数据库连接信息，并且希望通过 Maven 属性来设置这些信息。 首先，在 Maven 的 pom.xml 文件中添加数据库连接信息的属性和开启对默认占位符的解析。 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;project&gt; &lt;!-- 其他项目配置 --&gt; &lt;properties&gt; &lt;db.url&gt;jdbc:mysql://localhost:3306/mydb&lt;/db.url&gt; &lt;db.username&gt;myuser&lt;/db.username&gt; &lt;db.password&gt;mypassword&lt;/db.password&gt; &lt;/properties&gt; &lt;!-- 其他项目配置 --&gt; &lt;/project&gt; 在 src/main/resources 目录下创建 application.yml 配置文件，并在其中使用占位符引用 Maven 的属性。 # src/main/resources/application.yml spring: datasource: url: ${db.url} username: ${db.username} password: ${db.password} 创建一个简单的 Spring Boot 应用程序，用于测试配置。 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @SpringBootApplication public class MyAppApplication { public static void main(String[] args) { SpringApplication.run(MyAppApplication.class, args); } } @Component @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) class DataSourceProperties { private String url; private String username; private String password; // Getters and setters // Test method to print database connection information public void printDatabaseConfig() { System.out.println(&quot;Database URL: &quot; + url); System.out.println(&quot;Database Username: &quot; + username); System.out.println(&quot;Database Password: &quot; + password); } } 在上述示例中，在 pom.xml 中定义了数据库连接信息的 Maven 属性，并在 application.yml 中使用占位符引用这些属性。然后，通过 DataSourceProperties 类使用 @ConfigurationProperties 注解将属性值绑定到类中，并在 printDatabaseConfig 方法中打印出来。 当运行这个应用程序时，Spring Boot 将加载 application.yml 中的配置，将 Maven 的属性值替换到对应的占位符中。这样，就成功地在配置文件中使用了占位符引用 Maven 的属性，实现了动态加载配置。 整合三方技术 整合JUnit 步骤1：添加依赖项 首先，在项目的构建文件（例如pom.xml）中添加所需的依赖项。确保包含JUnit和Spring Boot Test相关的依赖项。 &lt;!-- JUnit 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.7.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Test 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 步骤2：编写测试类 创建一个测试类，并使用JUnit的注解标记测试方法。 import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.boot.test.web.client.TestRestTemplate.HttpClientOption; import org.springframework.boot.test.web.client.TestRestTemplate.ResponseExtractor; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpMethod; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.RequestEntity; import org.springframework.http.ResponseEntity; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig; import org.springframework.web.client.RestTemplate; import static org.junit.jupiter.api.Assertions.assertEquals; @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class MyControllerTest { @Autowired private TestRestTemplate restTemplate; @Test public void testHelloEndpoint() { String url = &quot;/hello&quot;; ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class); assertEquals(HttpStatus.OK, response.getStatusCode()); assertEquals(&quot;Hello, World!&quot;, response.getBody()); } } 在上面的示例中，使用了@SpringBootTest注解来标记测试类，并指定WebEnvironment.RANDOM_PORT以在随机端口上启动应用程序的嵌入式服务器。使用@Autowired注解注入TestRestTemplate来进行HTTP请求的模拟。 步骤3：运行测试 使用常规的JUnit运行器（如JUnit Jupiter或JUnit 4）来运行测试类。测试类中的测试方法将会执行，并且可以通过assertEquals等断言方法进行断言和验证。 小贴士 可以使用TestRestTemplate来发送HTTP请求并进行断言。这使得可以测试控制器、服务或其他组件的行为和结果。 示例中使用了Spring Boot 2.x的方式，如果使用的是较早的版本，请相应地调整依赖项和注解的版本。 整合MyBatis 步骤1：添加依赖项 首先，需要在项目的构建文件（例如pom.xml）中添加Spring Boot和MyBatis的依赖项。 &lt;!-- Spring Boot 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.26&lt;/version&gt; &lt;/dependency&gt; 步骤2：配置数据源和MyBatis 在application.properties或application.yml中配置数据源和MyBatis。 # application.yml spring: datasource: url: jdbc:mysql://localhost:3306/mydatabase username: your_username password: your_password driver-class-name: com.mysql.cj.jdbc.Driver mybatis: mapper-locations: classpath:mappers/*.xml 在上述配置中，指定了数据库连接的URL、用户名和密码，以及MySQL驱动的类名。还指定了MyBatis Mapper文件的位置，这里假设它们位于src/main/resources/mappers/目录下。 步骤3：创建Mapper接口和XML文件 创建MyBatis的Mapper接口和XML文件，用于定义数据库操作。 // UserMapper.java import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; @Mapper public interface UserMapper { @Select(&quot;SELECT id, username, email FROM users WHERE id = #{id}&quot;) User findById(Long id); } &lt;!-- UserMapper.xml --&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;!-- 这里可以定义更多的数据库操作 --&gt; &lt;/mapper&gt; 步骤4：实现Service层和Controller层 创建Service层和Controller层，用于调用MyBatis的Mapper接口进行数据库操作。 // UserService.java import com.example.mapper.UserMapper; import com.example.model.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class UserService { private final UserMapper userMapper; @Autowired public UserService(UserMapper userMapper) { this.userMapper = userMapper; } public User getUserById(Long id) { return userMapper.findById(id); } } // UserController.java import com.example.model.User; import com.example.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class UserController { private final UserService userService; @Autowired public UserController(UserService userService) { this.userService = userService; } @GetMapping(&quot;/users/{id}&quot;) public User getUserById(@PathVariable Long id) { return userService.getUserById(id); } } 在上面的示例中，创建了UserService和UserController，其中UserService调用MyBatis的UserMapper接口来查询数据库，并返回User对象。UserController暴露了一个REST API来获取用户信息。 步骤5：运行应用程序 现在，可以运行Spring Boot应用程序，并访问UserController暴露的REST API来测试MyBatis集成是否正常工作。 当访问/users/{id}时，UserController将调用UserService，并通过MyBatis查询数据库，并返回相应的用户信息。 ","tags":[{"index":2,"name":"Spring","slug":"tag-Spring","used":true,"link":"https://riftrays.github.io/tag-Spring/"},{"index":-1,"name":"SpringBoot","slug":"tag-SpringBoot","used":true,"link":"https://riftrays.github.io/tag-SpringBoot/"}],"title":"Spring Boot","feature":"","link":"https://riftrays.github.io/springboot/","stats":{"text":"55 min read","time":3268000,"words":13600,"minutes":55},"date":"2021-01-01 22:41:03","dateFormat":"2021-01-01 22:41:03"},{"abstract":"","content":"概述 MyBatis-Plus（简称MP）是一个基于MyBatis的增强工具库，它简化了与数据库的交互，提供了更多的便利功能，帮助开发者更高效地进行数据库操作。MP提供了许多实用的功能，包括通用CRUD操作、分页查询、条件构造器、逻辑删除、乐观锁、自动填充字段等。 官方网站：https://mybatis.plus/ (他人捐赠) 官方网站：https://mp.baomidou.com/ （原始官网） 搭建步骤 步骤 1：创建一个新的Maven项目 首先，创建一个新的Maven项目作为你的工程。 步骤 2：添加依赖 在项目的pom.xml文件中添加MyBatis-Plus和MySQL的依赖。 &lt;dependencies&gt; &lt;!-- MyBatis-Plus依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 请确保将最新版本替换为MyBatis-Plus和MySQL驱动的实际版本号。 步骤 3：配置数据源 在application.properties或application.yml中配置数据库连接信息。 spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name spring.datasource.username=your_mysql_username spring.datasource.password=your_mysql_password spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 请将your_database_name、your_mysql_username和your_mysql_password替换为实际的数据库名、MySQL用户名和密码。 步骤 4：创建实体类 创建对应数据库表的实体类。例如，我们创建一个名为User的实体类。 import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; @TableName(&quot;user&quot;) public class User { @TableId(type = IdType.AUTO) private Long id; private String name; private Integer age; // 省略getter和setter方法 } 在这里，我们使用了@TableName注解指定实体类对应的数据库表名，@TableId注解指定主键类型为自增。 步骤 5：创建Mapper接口 创建UserMapper接口，并继承BaseMapper&lt;User&gt;。 import com.baomidou.mybatisplus.core.mapper.BaseMapper; import org.springframework.stereotype.Repository; @Repository public interface UserMapper extends BaseMapper&lt;User&gt; { } 步骤 6：配置Mapper扫描路径 在application.properties或application.yml中配置Mapper的扫描路径。 mybatis-plus.mapper-locations=classpath:mapper/*.xml 步骤 7：创建Mapper XML文件（可选） 在resources目录下创建mapper文件夹，并在其中创建UserMapper.xml文件。在该XML文件中，你可以编写自定义的SQL语句，MyBatis-Plus将会自动识别并与接口方法进行绑定。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;!-- 你可以在这里编写自定义的SQL语句，MyBatis-Plus会自动识别并与接口方法进行绑定 --&gt; &lt;/mapper&gt; 步骤 8：使用MyBatis-Plus进行数据库操作 现在，你已经完成了MyBatis-Plus环境的搭建。你可以通过UserMapper接口进行数据库的增删改查操作。 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class UserService { private final UserMapper userMapper; @Autowired public UserService(UserMapper userMapper) { this.userMapper = userMapper; } // 示例：插入数据 public void insertUser(User user) { userMapper.insert(user); } // 示例：查询数据 public User getUserById(Long id) { return userMapper.selectById(id); } // 示例：更新数据 public void updateUser(User user) { userMapper.updateById(user); } // 示例：删除数据 public void deleteUser(Long id) { userMapper.deleteById(id); } } 这样，你就可以通过UserService中的方法来进行数据库操作，而无需编写具体的SQL语句。 优点/特性 简化开发 MyBatis-Plus封装了许多常用的CRUD操作，通过继承BaseMapper接口，无需编写繁琐的SQL语句，开发者可以更专注于业务逻辑的实现。这极大地简化了开发过程，提高了开发效率。 强大的查询功能 MyBatis-Plus提供了丰富的查询条件构造器，支持链式调用，可以轻松地构建复杂的查询条件，包括等值、范围、模糊查询等。 // 示例：查询年龄在25到30岁之间，并且姓名包含&quot;John&quot;的用户 List&lt;User&gt; userList = userMapper.selectList( new QueryWrapper&lt;User&gt;() .between(&quot;age&quot;, 25, 30) .like(&quot;name&quot;, &quot;John&quot;) ); 分页查询 MyBatis-Plus提供了方便的分页查询功能，开发者只需传入页码和每页记录数即可轻松实现分页查询。 // 示例：查询第2页，每页10条记录的用户列表 Page&lt;User&gt; page = new Page&lt;&gt;(2, 10); IPage&lt;User&gt; userPage = userMapper.selectPage(page, null); List&lt;User&gt; userList = userPage.getRecords(); 自动填充 MyBatis-Plus支持自动填充功能，在插入和更新数据时，可以自动填充指定的字段，例如创建时间和更新时间。 public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); } @Override public void updateFill(MetaObject metaObject) { this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); } } 乐观锁支持 MyBatis-Plus支持乐观锁功能，通过在实体类字段上添加@Version注解，可以实现乐观锁的功能，防止并发修改冲突。 public class User { private Long id; private String name; private Integer age; @Version private Integer version; // 乐观锁版本号 // 省略getter和setter方法 } 多租户支持 MyBatis-Plus提供了多租户的支持，可以在SQL查询时自动添加租户字段的条件，实现数据隔离。 // 示例：根据租户ID查询用户列表 List&lt;User&gt; userList = userMapper.selectList( new QueryWrapper&lt;User&gt;().eq(&quot;tenant_id&quot;, tenantId) ); 逻辑删除 MyBatis-Plus支持逻辑删除功能，通过在实体类字段上添加@TableLogic注解，可以实现逻辑删除的功能。 public class User { private Long id; private String name; private Integer age; @TableLogic // 逻辑删除标志 private Integer deleted; // 省略getter和setter方法 } 代码生成器 MyBatis-Plus提供了代码生成器，可以根据数据库表自动生成实体类、Mapper接口以及XML文件，极大地提高了开发效率。 性能优化 MyBatis-Plus对查询进行了优化，可以缓存SQL查询结果，减少数据库访问次数，提高性能。 可扩展性 MyBatis-Plus提供了许多钩子方法和插件机制，允许开发者自定义扩展功能，满足特定的业务需求。 与Mybatis对比 MyBatis MyBatis-Plus 基于MyBatis，是MyBatis的增强版。 基于MyBatis，是MyBatis的增强工具，提供了更多便捷的功能。 需要手动编写大部分的SQL语句。 封装了常用的CRUD操作，无需手动编写大部分的SQL语句。 提供了基本的CRUD操作，如insert、update、delete、select。 在基本的CRUD操作之上，增加了更多的操作方法，如Lambda查询、分页查询等。 不提供自动填充、乐观锁、逻辑删除等功能。 提供了自动填充、乐观锁、逻辑删除等强大功能。 不提供代码生成器。 提供了代码生成器，可以根据数据库表自动生成实体类、Mapper接口、XML文件。 不提供分页查询功能。 提供了方便的分页查询功能。 不提供多租户支持。 提供了多租户支持，可以实现数据隔离。 不提供逻辑删除功能。 提供了逻辑删除功能，可以实现数据逻辑删除。 需要手动编写Mapper接口和XML文件。 可以通过继承BaseMapper接口，自动实现部分CRUD操作，简化开发。 MyBatis与MyBatis-Plus的代码实现对比： 1. 使用MyBatis进行数据库操作 // UserMapper.java public interface UserMapper { User selectUserById(Long id); void insertUser(User user); void updateUser(User user); void deleteUser(Long id); } &lt;!-- UserMapper.xml --&gt; &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectUserById&quot; resultType=&quot;com.example.entity.User&quot;&gt; SELECT * FROM user WHERE id = #{id} &lt;/select&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.entity.User&quot;&gt; INSERT INTO user (id, name, age) VALUES (#{id}, #{name}, #{age}) &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.example.entity.User&quot;&gt; UPDATE user SET name = #{name}, age = #{age} WHERE id = #{id} &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Long&quot;&gt; DELETE FROM user WHERE id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 2. 使用MyBatis-Plus进行数据库操作 // UserMapper.java import com.baomidou.mybatisplus.core.mapper.BaseMapper; import org.springframework.stereotype.Repository; @Repository public interface UserMapper extends BaseMapper&lt;User&gt; { } // UserService.java import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class UserService { private final UserMapper userMapper; @Autowired public UserService(UserMapper userMapper) { this.userMapper = userMapper; } // 查询数据 public User getUserById(Long id) { return userMapper.selectById(id); } // 插入数据 public void insertUser(User user) { userMapper.insert(user); } // 更新数据 public void updateUser(User user) { userMapper.updateById(user); } // 删除数据 public void deleteUser(Long id) { userMapper.deleteById(id); } } 通过对比以上代码，我们可以看到使用MyBatis-Plus的代码更加简洁，无需手动编写SQL语句，通过继承BaseMapper接口，就可以实现大部分的CRUD操作。此外，MyBatis-Plus还提供了一些额外的功能，如自动填充、乐观锁、逻辑删除等，可以进一步简化开发过程，并提供更多便捷的操作方法。 取消启动banner图标 当使用MyBatis-Plus时，默认情况下，它会显示一个启动banner图标，其中包含MyBatis-Plus的Logo和版本信息。 如果你希望取消MyBatis-Plus的启动banner图标显示，可以按照以下步骤进行配置： 方法一：通过配置文件取消 可以通过在application.properties或application.yml配置文件中添加如下配置来取消MyBatis-Plus的启动banner图标显示： mybatis-plus.banner=false 或者在application.yml中： mybatis-plus: banner: false 方法二：通过编程方式取消 我们也可以通过编程方式取消MyBatis-Plus的启动banner图标显示。以下是一个Java代码示例： import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication app = new SpringApplication(MyApplication.class); app.setBannerMode(Banner.Mode.OFF); // 取消启动banner图标的显示 app.run(args); } } 在上述代码中，我们通过SpringApplication类的setBannerMode()方法将启动banner图标的显示模式设置为Banner.Mode.OFF，从而取消了启动时的图标显示。 MyBatisPlus的CRUD操作 操作 方法 描述 插入数据 insert(entity) 插入一条数据，如果数据已存在则会抛出异常。 插入或更新数据 insertOrUpdate(entity) 插入或更新数据，根据实体类的主键判断数据是否存在，存在则更新，不存在则插入。 更新数据 updateById(entity) 根据主键更新数据，实体类中未设置的字段会被更新为null。 更新数据（忽略null值） update(entity, updateWrapper) 根据条件更新数据，updateWrapper为条件构造器，可以指定更新的字段和条件。 删除数据 deleteById(id) 根据主键删除数据。 删除数据（条件删除） delete(deleteWrapper) 根据条件删除数据，deleteWrapper为条件构造器，可以指定删除的条件。 查询数据（根据ID） selectById(id) 根据主键查询数据。 查询数据（多个ID） selectBatchIds(ids) 根据多个主键查询数据。 查询数据（所有数据） selectList(null) 查询所有数据。 查询数据（条件查询） selectList(queryWrapper) 根据条件查询数据，queryWrapper为条件构造器，可以指定查询的条件。 查询数据（分页查询） selectPage(page, queryWrapper) 分页查询数据，page为分页对象，queryWrapper为条件构造器，可以指定查询的条件。 查询数据（总记录数） selectCount(queryWrapper) 查询满足条件的数据总记录数，queryWrapper为条件构造器，可以指定查询的条件。 查询一条数据 selectOne(queryWrapper) 查询满足条件的一条数据，如果满足条件的数据有多条，只返回第一条数据。 查询数据（Lambda查询） lambdaQuery().list() 使用Lambda表达式进行查询，更加直观和简洁。 查询数据（自定义SQL） selectBySql(sql, params) 执行自定义SQL语句查询数据，params为参数列表。 代码实现辅助理解： // 插入数据 User user = new User(); user.setName(&quot;John&quot;); user.setAge(25); userMapper.insert(user); // 更新数据 User user = userMapper.selectById(1L); user.setAge(26); userMapper.updateById(user); // 删除数据 userMapper.deleteById(1L); // 查询数据（根据ID） User user = userMapper.selectById(1L); // 查询数据（条件查询） List&lt;User&gt; userList = userMapper.selectList( new QueryWrapper&lt;User&gt;() .ge(&quot;age&quot;, 25) .like(&quot;name&quot;, &quot;John&quot;) ); // 查询数据（分页查询） Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); // 查询第1页，每页5条记录 IPage&lt;User&gt; userPage = userMapper.selectPage(page, new QueryWrapper&lt;User&gt;() .ge(&quot;age&quot;, 25) .like(&quot;name&quot;, &quot;John&quot;) ); List&lt;User&gt; userList = userPage.getRecords(); // 查询数据（总记录数） int count = userMapper.selectCount( new QueryWrapper&lt;User&gt;() .ge(&quot;age&quot;, 25) .like(&quot;name&quot;, &quot;John&quot;) ); // 查询一条数据 User user = userMapper.selectOne( new QueryWrapper&lt;User&gt;() .eq(&quot;age&quot;, 25) .orderByDesc(&quot;create_time&quot;) ); // 使用Lambda查询 List&lt;User&gt; userList = new LambdaQueryChainWrapper&lt;&gt;(userMapper) .ge(User::getAge, 25) .like(User::getName, &quot;John&quot;) .list(); // 执行自定义SQL语句查询数据 String sql = &quot;SELECT * FROM user WHERE age &gt;= ? AND name LIKE ?&quot;; List&lt;User&gt; userList = userMapper.selectBySql(sql, 25, &quot;%John%&quot;); 分页查询 概述 当使用MyBatis-Plus（MP）进行分页查询时，我们需要使用Page对象来表示分页信息，并结合QueryWrapper来构建查询条件。Page对象用于指定当前页码和每页记录数，而QueryWrapper用于添加其他查询条件。 实现步骤 假设我们有一个用户实体类User，对应数据库中的user表，表结构如下： CREATE TABLE user ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), age INT, email VARCHAR(100) ); 首先，我们需要准备好Spring Boot项目，并添加相应的依赖。在pom.xml中添加MyBatis-Plus和数据库连接相关的依赖： &lt;!-- MyBatis-Plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接相关依赖（此处以MySQL为例） --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.26&lt;/version&gt; &lt;/dependency&gt; 接下来，我们需要配置数据库连接信息和MyBatis-Plus分页插件。在application.properties（或application.yml）中添加以下配置： 配置方式一： # 数据库连接配置 spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=root spring.datasource.password=your_password spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # MyBatis-Plus配置 mybatis-plus.configuration.map-underscore-to-camel-case=true mybatis-plus.configuration.use-generated-keys=true mybatis-plus.configuration.db-config.limit=100 在这个配置中，我们是直接在配置文件中使用属性进行配置。具体解释如下： mybatis-plus.configuration.map-underscore-to-camel-case=true： 这个配置项表示是否将数据库字段的下划线命名转换为Java对象属性的驼峰命名。如果设置为true，例如数据库字段为user_name，对应的Java对象属性会变成userName。 mybatis-plus.configuration.use-generated-keys=true： 这个配置项表示是否使用数据库自动生成的主键值作为Java对象的主键属性。如果设置为true，在插入一条记录时，MyBatis-Plus会尝试将数据库自动生成的主键值设置到Java对象的主键属性中。 mybatis-plus.configuration.db-config.limit=100： 这个配置项设置数据库查询的默认分页大小。当在分页查询时没有指定具体的分页大小时，MyBatis-Plus会使用这个配置的默认值。这里设置的是默认分页大小为100。 配置方式二： @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ //1 创建MybatisPlusInterceptor拦截器对象 MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor(); //2 添加分页拦截器 mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mpInterceptor; } } 在这个配置中，我们是通过Java Config方式进行配置。具体解释如下： 首先，我们创建了一个MybatisPlusInterceptor拦截器对象，它是MyBatis-Plus提供的拦截器，用于添加各种功能的插件。 然后，我们通过mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor())方式，添加了分页拦截器。分页拦截器是MyBatis-Plus提供的插件，用于自动拦截分页查询的请求，并完成分页查询逻辑。 区别： 配置方式不同： 配置一是在application.properties或application.yml配置文件中直接设置属性值的方式来配置。 配置二是通过Java Config方式来配置，即在Java类中使用@Configuration注解，并创建Bean对象来配置。 配置粒度不同： 配置一中的属性设置是全局生效的，影响整个项目的MyBatis-Plus行为。 配置二中的拦截器配置是针对特定功能的，例如这里只添加了分页拦截器，如果需要其他功能，还可以添加其他的拦截器。 可扩展性不同： 配置一较为简单，但如果需要更复杂的功能或自定义插件，则可能需要额外的配置和编写自定义插件。 配置二提供了更灵活的方式，可以根据实际需求选择不同的拦截器组合，也可以编写自定义的拦截器来实现更复杂的功能。 接下来，创建User实体类和对应的Mapper接口： // User实体类 public class User { private Long id; private String name; private Integer age; private String email; // Getters and Setters... } // UserMapper接口 @Mapper public interface UserMapper extends BaseMapper&lt;User&gt; { List&lt;User&gt; queryUserByPage(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;user&quot;) User user); } 在上述代码中，我们使用@Mapper注解标记UserMapper接口，表明它是一个MyBatis的Mapper接口，并继承了BaseMapper&lt;User&gt;。BaseMapper是MyBatis-Plus提供的接口，包含了基本的增删改查方法。 接下来，我们创建一个Service层，用于调用Mapper进行分页查询： @Service public class UserServiceImpl implements UserService { @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; queryUserByPage(int currentPage, int pageSize, String name) { Page&lt;User&gt; page = new Page&lt;&gt;(currentPage, pageSize); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); if (name != null &amp;&amp; !name.isEmpty()) { queryWrapper.like(&quot;name&quot;, name); } return userMapper.queryUserByPage(page, null); } } 在上述代码中，我们创建了一个UserServiceImpl实现UserService接口。在queryUserByPage方法中，我们创建了一个Page对象，用于指定当前页码和每页记录数。然后，我们创建了一个QueryWrapper对象，并根据传入的name参数（如果有）添加了模糊查询条件。 接下来，在Controller层处理请求，将前端传来的分页参数传递给Service层进行分页查询： @RestController public class UserController { @Autowired private UserService userService; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsersByPage(@RequestParam(name = &quot;page&quot;, defaultValue = &quot;1&quot;) int currentPage, @RequestParam(name = &quot;size&quot;, defaultValue = &quot;10&quot;) int pageSize, @RequestParam(required = false) String name) { return userService.queryUserByPage(currentPage, pageSize, name); } } 在上述代码中，我们使用@RestController注解标记UserController类，表明它是一个控制器类。在getUsersByPage方法中，我们使用@RequestParam注解标记请求参数，并指定了默认值。 现在，我们已经完成了整个分页查询的实现。当前端发起GET请求到/users时，Controller接收请求参数（当前页码、每页记录数、查询关键字），然后调用Service层的方法进行分页查询，最终将查询结果返回给前端。 请确保你的数据库连接配置正确，并且数据库中有相应的数据。运行Spring Boot应用程序后，你可以通过类似以下的URL进行分页查询： http://localhost:8080/users?page=1&amp;size=10&amp;name=John 以上URL将查询名为&quot;John&quot;的用户信息，返回第1页的10条记录。 分页插件配置方式 使用Java Config配置分页插件： 在Spring Boot项目中，你可以使用Java Config来配置MyBatis-Plus分页插件。在配置类中，创建一个PaginationInterceptor实例，并将其注册到MyBatis的SqlSessionFactoryBean中。 示例代码： @Configuration public class MyBatisConfig { @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 在上述配置中，我们创建了一个PaginationInterceptor的Bean，并将其加入到MyBatis的配置中。这样，MyBatis-Plus分页插件就会自动生效，无需额外的配置。 使用MyBatis配置文件配置分页插件： 如果你使用传统的MyBatis项目，你可以在MyBatis的配置文件中手动配置分页插件。在mybatis-config.xml中添加以下配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;/&gt; &lt;/plugins&gt; &lt;/configuration&gt; 在上述配置中，我们使用&lt;plugin&gt;标签指定了PaginationInterceptor的类路径，这样MyBatis-Plus分页插件就会被自动注册。 使用分页拦截器配置插件参数： MyBatis-Plus的分页插件还支持自定义配置。你可以通过PaginationInterceptor来配置一些参数，例如数据库类型、是否开启合理化分页等。 示例代码： @Configuration public class MyBatisConfig { @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor interceptor = new PaginationInterceptor(); // 设置数据库类型，例如MySQL interceptor.setDbType(DbType.MYSQL); // 设置是否开启合理化分页 interceptor.setOverflow(true); return interceptor; } } 在上述示例中，我们创建了一个PaginationInterceptor的Bean，并设置了数据库类型为MySQL，以及开启了合理化分页功能。 使用物理分页配置插件参数： 物理分页是一种更高效的分页方式，可以使用数据库的特定语法来执行分页查询。MyBatis-Plus也支持物理分页，你可以通过PaginationInterceptor配置物理分页参数。 示例代码： @Configuration public class MyBatisConfig { @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor interceptor = new PaginationInterceptor(); // 设置物理分页参数 interceptor.setDialectType(&quot;mysql&quot;); return interceptor; } } 在上述示例中，我们创建了一个PaginationInterceptor的Bean，并设置了物理分页的数据库类型为MySQL。 无论使用哪种配置方式，配置MyBatis-Plus分页插件都是非常简单的。根据你的项目需求和开发环境，选择合适的方式来配置分页插件即可。分页插件的配置通常只需在项目启动时完成一次，然后插件将自动拦截分页查询的请求。 MyBatisPlus日志 当使用MyBatis-Plus时，我们可以通过配置来开启MyBatis-Plus的日志输出。MyBatis-Plus使用MyBatis的日志功能，因此我们需要同时配置MyBatis和MyBatis-Plus的日志。 步骤一：配置MyBatis的日志级别 首先，我们需要在配置文件中配置MyBatis的日志级别。MyBatis的日志级别分为TRACE、DEBUG、INFO、WARN和ERROR五个级别，级别从低到高依次为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR。配置MyBatis的日志级别为DEBUG或更高级别，可以让我们看到SQL语句和执行结果。 在application.properties或application.yml配置文件中添加如下配置： # 配置MyBatis的日志级别为DEBUG logging.level.org.mybatis=DEBUG 步骤二：配置日志框架 MyBatis-Plus使用Slf4j作为日志框架，因此我们需要在项目中添加Slf4j的依赖，并配置对应的日志桥接器。 如果你的项目使用Maven，可以在pom.xml中添加以下依赖： &lt;!-- Slf4j 日志门面 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.32&lt;/version&gt; &lt;!-- 使用当前最新版本 --&gt; &lt;/dependency&gt; &lt;!-- Logback 日志框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;!-- 使用当前最新版本 --&gt; &lt;/dependency&gt; 步骤三：配置Logback的日志输出格式 接下来，我们需要配置Logback的日志输出格式，以便更清晰地查看MyBatis-Plus的日志信息。 在项目的src/main/resources目录下创建logback.xml文件，并添加如下配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;!-- 定义日志输出的格式 --&gt; &lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&quot; /&gt; &lt;!-- 控制台输出日志 --&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- MyBatis-Plus 的日志输出器 --&gt; &lt;logger name=&quot;com.baomidou.mybatisplus.core&quot; level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;/logger&gt; &lt;!-- 设置根日志级别为DEBUG --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;/root&gt; &lt;/configuration&gt; 在上述配置中，我们定义了一个名为CONSOLE的控制台输出日志的Appender，并将日志输出格式设置为我们定义的${LOG_PATTERN}。然后，我们将MyBatis-Plus的日志级别设置为DEBUG，并将其日志输出到控制台。 DQL编程控制 概述 当使用MyBatis-Plus（MP）进行DQL（Data Query Language）编程控制时，我们主要关注以下方面： 实体类的定义：定义Java实体类，用于映射数据库表结构。 Mapper接口的定义：定义Mapper接口，用于定义数据库的增删改查操作。 Mapper XML的配置：配置Mapper接口对应的XML文件，实现具体的数据库操作。 使用MyBatis-Plus提供的封装方法：使用MyBatis-Plus提供的便捷方法简化数据库操作。 实现步骤 步骤一：实体类的定义 首先，我们需要定义一个Java实体类，用于映射数据库表的结构。实体类的字段应该与数据库表的字段对应，并使用注解来标识表名、字段名等信息。 示例：假设我们有一个名为User的数据库表，包含id、username和age字段。 import com.baomidou.mybatisplus.annotation.TableName; @TableName(&quot;user&quot;) public class User { private Long id; private String username; private Integer age; // 省略 getter 和 setter 方法 } 步骤二：Mapper接口的定义 接下来，我们需要定义一个Mapper接口，用于定义数据库的增删改查操作。这个接口不需要实现，只需要声明对应的方法。 示例：我们定义一个名为UserMapper的接口，包含查询用户信息和插入用户信息的方法。 import com.baomidou.mybatisplus.core.mapper.BaseMapper; public interface UserMapper extends BaseMapper&lt;User&gt; { List&lt;User&gt; selectAllUsers(); void insertUser(User user); } 注意：UserMapper继承了BaseMapper&lt;User&gt;，这是MyBatis-Plus提供的通用Mapper接口，通过继承它，我们可以省去很多基本的CRUD操作的实现。 步骤三：Mapper XML的配置 接下来，我们需要为UserMapper接口编写对应的Mapper XML文件，实现具体的数据库操作。 示例：创建一个名为UserMapper.xml的XML文件，并放置在resources/mapper目录下。 &lt;!-- resources/mapper/UserMapper.xml --&gt; &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;!-- 查询所有用户信息 --&gt; &lt;select id=&quot;selectAllUsers&quot; resultType=&quot;com.example.entity.User&quot;&gt; SELECT id, username, age FROM user &lt;/select&gt; &lt;!-- 插入用户信息 --&gt; &lt;insert id=&quot;insertUser&quot;&gt; INSERT INTO user (username, age) VALUES (#{username}, #{age}) &lt;/insert&gt; &lt;/mapper&gt; 步骤四：使用MyBatis-Plus提供的封装方法 在配置完成后，我们可以直接使用MyBatis-Plus提供的封装方法来进行数据库操作，而无需编写额外的SQL语句。 示例：在Service层中使用UserMapper来查询所有用户信息和插入用户信息。 import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getAllUsers() { return baseMapper.selectAllUsers(); } @Override public void addUser(User user) { baseMapper.insertUser(user); } } 在上述示例中，UserServiceImpl继承了ServiceImpl&lt;UserMapper, User&gt;，这是MyBatis-Plus提供的通用Service实现类。通过继承它，我们可以直接调用baseMapper来实现数据库操作。 查询条件 在多条件查询中，我们可以使用不同的组合来灵活构建查询条件，以满足不同的查询需求。以下是多条件查询可能的组合方式的详细讲解： 官方参考文档：https://baomidou.com/pages/10c804/ 组合方式 描述 代码实现 单条件查询 只使用一个条件进行查询 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;); 多条件AND查询 多个条件之间使用AND逻辑连接进行查询 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).eq(&quot;age&quot;, 25); 多条件OR查询 多个条件之间使用OR逻辑连接进行查询 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).or().eq(&quot;age&quot;, 30); 多条件嵌套查询 多个条件使用括号嵌套进行查询 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).and(qw -&gt; qw.eq(&quot;age&quot;, 25).or().eq(&quot;age&quot;, 30)); 条件参数控制 根据条件参数动态构建查询条件 queryWrapper.eq(StringUtils.isNotBlank(name), &quot;name&quot;, name).eq(age != null, &quot;age&quot;, age); Lambda方式查询 使用Lambda表达式进行条件查询 lambdaQueryWrapper.eq(User::getName, &quot;John&quot;).eq(User::getAge, 25); Query方式查询 使用Query对象进行条件查询 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).eq(&quot;age&quot;, 25); 带排序的查询 在查询条件的基础上添加排序规则 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).orderByAsc(&quot;age&quot;); 带分组的查询 在查询条件的基础上添加分组规则 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).groupBy(&quot;age&quot;); 带分页的查询 在查询条件的基础上添加分页规则 queryWrapper.eq(&quot;name&quot;, &quot;John&quot;).page(new Page&lt;&gt;(1, 10)); 请注意，以上代码实现仅用于示例，具体的使用方式可能会根据实际情况有所不同。多条件查询非常灵活，可以根据不同的业务需求组合不同的条件来获取符合要求的查询结果。 在实际使用中，可以根据具体的业务需求选择适合的查询方式，根据条件的复杂程度和查询结果的需求，灵活组合各种条件查询方式，以满足不同场景的查询需求。 条件查询 当使用MyBatis-Plus（MP）进行DQL（Data Query Language）编程控制中的条件查询时，我们可以通过不同的方式来实现按条件查询。 在下面，我将详细并全面地讲解三种方式的条件查询：按条件查询、Lambda格式按条件查询（完整）、Lambda格式按条件查询（简化）。并结合代码来辅助理解。 我们以查询用户信息为例，假设有一个名为User的数据库表，包含id、username和age字段。以下是用户的实体类定义： import com.baomidou.mybatisplus.annotation.TableName; @TableName(&quot;user&quot;) public class User { private Long id; private String username; private Integer age; // 省略 getter 和 setter 方法 } 方式一：按条件查询 在MP中，我们可以使用Wrapper对象来构建查询条件，并将其作为参数传递给相应的查询方法。Wrapper是MP提供的查询条件构造器，我们可以通过它来设置各种查询条件。 示例：按条件查询年龄在20岁以上的用户信息。 import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByAge(int age) { QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.ge(&quot;age&quot;, age); return baseMapper.selectList(queryWrapper); } } 在上述示例中，我们创建了一个QueryWrapper&lt;User&gt;对象，并使用ge方法设置查询条件为年龄大于等于指定的age值。然后，我们将QueryWrapper作为参数传递给selectList方法，完成按条件查询。 方式二：Lambda格式按条件查询（完整） MP提供了Lambda表达式的方式来更简洁地构建查询条件。使用Lambda表达式，我们可以在编译时进行语法检查，避免了写错字段名或拼写错误的问题。 示例：按条件查询年龄在20岁以上的用户信息，使用Lambda格式进行完整的条件构造。 import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByAge(int age) { LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.ge(User::getAge, age); return baseMapper.selectList(lambdaQueryWrapper); } } 在上述示例中，我们创建了一个LambdaQueryWrapper&lt;User&gt;对象，并使用ge方法设置查询条件为年龄大于等于指定的age值。使用Lambda表达式，我们可以直接引用实体类的字段，并通过方法引用的方式指定要比较的字段。然后，我们将LambdaQueryWrapper作为参数传递给selectList方法，完成按条件查询。 方式三：Lambda格式按条件查询（简化） 对于简单的条件查询，我们可以进一步简化Lambda表达式的写法，使代码更加简洁。 示例：按条件查询年龄在20岁以上的用户信息，使用Lambda格式进行简化的条件构造。 import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByAge(int age) { return lambdaQuery().ge(User::getAge, age).list(); } } 在上述示例中，我们直接使用lambdaQuery()方法来创建LambdaQueryWrapper&lt;User&gt;对象，并链式调用ge方法设置查询条件为年龄大于等于指定的age值。然后，通过list()方法完成按条件查询。 完整实现步骤 User实体类的定义： import com.baomidou.mybatisplus.annotation.TableName; @TableName(&quot;user&quot;) public class User { private Long id; private String username; private Integer age; // 省略 getter 和 setter 方法 } UserMapper接口的定义： import com.baomidou.mybatisplus.core.mapper.BaseMapper; public interface UserMapper extends BaseMapper&lt;User&gt; { } UserMapper.xml的配置： &lt;!-- resources/mapper/UserMapper.xml --&gt; &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;/mapper&gt; Service层的实现： import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByAge(int age) { return baseMapper.selectList(lambdaQuery().ge(User::getAge, age)); } } 组合条件 在MyBatis-Plus（MP）中，组合条件是指在查询时使用多个条件来限制结果集。常见的组合条件包括&quot;并且关系&quot;（and）和&quot;或者关系&quot;（or）。通过组合条件，我们可以更精确地筛选出满足特定条件的数据。 方式一：并且关系（and） 在MP中，使用Wrapper对象来构建查询条件时，多个条件之间默认是&quot;并且关系&quot;（and），即多个条件都必须同时满足才能查询到数据。 示例：按条件查询用户名为&quot;John&quot;且年龄在20岁以上的用户信息。 import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByNameAndAge(String name, int age) { QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;username&quot;, name).ge(&quot;age&quot;, age); return baseMapper.selectList(queryWrapper); } } 在上述示例中，我们创建了一个QueryWrapper&lt;User&gt;对象，并使用eq方法设置查询条件为用户名等于指定的name值，同时使用ge方法设置查询条件为年龄大于等于指定的age值。这两个条件之间是&quot;并且关系&quot;，即查询结果要满足用户名为&quot;John&quot;且年龄在20岁以上的条件。 方式二：或者关系（or） 如果我们需要使用&quot;或者关系&quot;来组合条件，可以使用or方法来实现。 示例：按条件查询用户名为&quot;John&quot;或者年龄在20岁以上的用户信息。 import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByNameOrAge(String name, int age) { QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;username&quot;, name).or().ge(&quot;age&quot;, age); return baseMapper.selectList(queryWrapper); } } 在上述示例中，我们创建了一个QueryWrapper&lt;User&gt;对象，并使用eq方法设置查询条件为用户名等于指定的name值。然后，使用or方法表示接下来的条件是&quot;或者关系&quot;。紧接着，我们使用ge方法设置查询条件为年龄大于等于指定的age值。这两个条件之间是&quot;或者关系&quot;，即查询结果要满足用户名为&quot;John&quot;或者年龄在20岁以上的条件。 完整实现步骤 User实体类的定义： import com.baomidou.mybatisplus.annotation.TableName; @TableName(&quot;user&quot;) public class User { private Long id; private String username; private Integer age; // 省略 getter 和 setter 方法 } UserMapper接口的定义： import com.baomidou.mybatisplus.core.mapper.BaseMapper; public interface UserMapper extends BaseMapper&lt;User&gt; { } UserMapper.xml的配置： &lt;!-- resources/mapper/UserMapper.xml --&gt; &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;/mapper&gt; Service层的实现： import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByNameAndAge(String name, int age) { QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;username&quot;, name).ge(&quot;age&quot;, age); return baseMapper.selectList(queryWrapper); } @Override public List&lt;User&gt; getUsersByNameOrAge(String name, int age) { QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;username&quot;, name).or().ge(&quot;age&quot;, age); return baseMapper.selectList(queryWrapper); } } Null的处理 在多条件查询的场景中，有时候条件的值可能为空。在这种情况下，我们需要针对不同的情况进行处理，以确保查询条件正确且不出现错误。 在MyBatis-Plus（MP）中，处理条件值为空的情况有多种方式，我们可以使用Wrapper对象的方法来构建查询条件，同时根据条件值是否为空来决定是否添加该条件。 方式一：if语句控制条件追加 在这种方式中，我们可以使用if语句来判断条件是否为空，如果不为空，则将该条件追加到查询条件中。 示例代码如下： import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByAgeRange(Integer minAge, Integer maxAge) { LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (minAge != null) { queryWrapper.gt(User::getAge, minAge); } if (maxAge != null) { queryWrapper.lt(User::getAge, maxAge); } return baseMapper.selectList(queryWrapper); } } 在上述示例中，我们通过使用if语句判断minAge和maxAge是否为空，如果不为空，则使用gt和lt方法来设置年龄的大于和小于条件，实现了根据年龄范围来查询用户信息。 方式二：条件参数控制 MyBatis-Plus提供了条件参数控制的方法，我们可以在查询条件中使用条件判断来决定是否使用该条件。 示例代码如下： import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByAgeRange(Integer minAge, Integer maxAge) { LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.gt(minAge != null, User::getAge, minAge) .lt(maxAge != null, User::getAge, maxAge); return baseMapper.selectList(queryWrapper); } } 在上述示例中，我们使用了条件参数控制，通过在gt和lt方法中传入一个boolean类型的条件判断，当该条件为true时，才会使用对应的查询条件，否则不使用该条件。 查询射影 在MyBatis-Plus中，查询投影指的是从数据库中查询出特定字段，并将其映射到Java模型类或其他数据结构中。查询投影可以实现只查询模型类中部分属性、包含模型类未定义的属性以及进行分组和分页操作。 查询结果包含模型类中部分属性 在查询投影中，如果我们只想查询模型类中的部分属性，可以使用select方法来指定要查询的字段。 示例代码如下： import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersWithPartialAttributes() { // 方式一 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;); // 方式二 LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.select(User::getId,User::getName,User::getAge); return baseMapper.selectList(queryWrapper); } } 在上述示例中，我们使用QueryWrapper对象并调用select方法，指定了要查询的字段名为&quot;id&quot;、&quot;name&quot;和&quot;age&quot;。这样，查询结果将只包含模型类中这三个属性的值。 查询结果包含模型类中未定义的属性 有时候，我们希望查询结果中包含模型类中未定义的属性，比如使用聚合函数计算的字段，可以使用select方法来实现。 示例代码如下： import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import org.springframework.stereotype.Service; import java.util.List; import java.util.Map; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;Map&lt;String, Object&gt;&gt; getUsersWithAdditionalAttributes() { QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;count(*) as count, tel&quot;); queryWrapper.groupBy(&quot;tel&quot;); return baseMapper.selectMaps(queryWrapper); } } 在上述示例中，我们使用QueryWrapper对象并调用select方法，指定了要查询的字段为&quot;count() as count&quot;和&quot;tel&quot;。其中，&quot;count() as count&quot;是使用聚合函数计算的字段，这个字段将返回每个电话号码对应的用户数量。我们还调用了groupBy方法，按照电话号码进行分组。这样，查询结果将包含模型类未定义的属性&quot;count&quot;和&quot;tel&quot;，并且按照电话号码分组。 常见问题 对象名与表名不一致 如果表名与实体类的类名不一致，我们可以使用@TableName注解来显式设置当前类对应的数据库表名称。通过value属性来指定映射的数据库表名。 示例代码如下： @Data @TableName(&quot;tbl_user&quot;) // 指定实体类对应的数据库表名为tbl_user public class User { private Long id; private String name; private Integer age; // 其他属性... } 在上述示例中，我们使用@TableName注解，将实体类User映射到数据库表tbl_user。 字段与属性名不一致 在这种情况下，表的字段和实体类的属性名不一致，我们可以使用@TableField属性注解来显式设置当前属性对应的数据库表中的字段名。通过value属性来指定映射的数据库字段名。 示例代码如下： @Data @TableName(&quot;tbl_user&quot;) public class User { private Long id; @TableField(&quot;user_name&quot;) // 表中的字段名为user_name private String name; private Integer age; // 其他属性... } 在上述示例中，我们使用@TableField注解，将实体类中的name属性映射到数据库表中的user_name字段。 属性中存在不存在的字段 有时候，我们希望在实体类中添加一些属性，但这些属性并未在数据库表中定义。在这种情况下，我们可以使用@TableField注解，通过exist属性设置属性在数据库表字段中是否存在，默认为true。 示例代码如下： @Data @TableName(&quot;tbl_user&quot;) public class User { private Long id; private String name; @TableField(exist = false) // online字段并未在数据库表中定义 private Boolean online; // 其他属性... } 在上述示例中，我们使用@TableField注解，将实体类中的online属性设置为在数据库表中不存在的字段。 敏感数据不参与查询 MyBatis-Plus允许在查询时限制查询的字段，以避免开放过多字段的查看权限。我们可以使用@TableField注解，通过select属性设置该属性是否参与查询，默认为true。 示例代码如下： @Data @TableName(&quot;tbl_user&quot;) public class User { private Long id; private String name; private Integer age; @TableField(select = false) // 密码字段在查询中不参与 private String password; // 其他属性... } 在上述示例中，我们使用@TableField注解，将实体类中的password属性设置为在查询中不参与。 DML编程控制 Id生成策略 在MyBatis-Plus中，主键生成策略是通过@TableId注解来指定的。MyBatis-Plus支持多种主键生成策略，可以根据不同的需求选择合适的策略。 以下是几种常见的主键生成策略及对应的解释和代码实现： 自增策略（AUTO） 这是最常见的主键生成策略，数据库自动递增生成主键。在MySQL中，通常使用AUTO_INCREMENT来实现自增。 示例代码： @Data public class Log { @TableId(type = IdType.AUTO) private Long id; // 其他属性... } 手动指定（NONE） 手动指定主键值，需要在插入数据时自行设置主键值。 示例代码： @Data public class Order { @TableId(type = IdType.NONE) private String orderId; // 手动指定订单号作为主键 // 其他属性... } 雪花算法（ASSIGN_ID） 使用Twitter的Snowflake算法生成分布式唯一ID，适用于分布式环境。 示例代码： @Data public class TakeoutOrder { @TableId(type = IdType.ASSIGN_ID) private Long orderId; // 使用雪花算法生成订单号作为主键 // 其他属性... } UUID策略（UUID） 使用UUID作为主键，保证全局唯一性。 示例代码： @Data public class Relation { @TableId(type = IdType.UUID) private String relationId; // 使用UUID作为关系表主键 // 其他属性... } 自定义主键生成策略（INPUT） 允许开发者自定义主键值，插入数据时需要自行设置主键值。 示例代码： @Data public class Custom { @TableId(type = IdType.INPUT) private Long customId; // 自定义主键值 // 其他属性... } 以上列举了几种常见的主键生成策略，根据不同的表应用不同的id生成策略，你可以在实体类中使用不同的@TableId注解来设置不同的策略。 @Data public class Log { @TableId(type = IdType.AUTO) private Long id; // 其他属性... } @Data public class Order { @TableId(type = IdType.NONE) private String orderId; // 其他属性... } @Data public class TakeoutOrder { @TableId(type = IdType.ASSIGN_ID) private Long orderId; // 其他属性... } @Data public class Relation { @TableId(type = IdType.UUID) private String relationId; // 其他属性... } @Data public class Custom { @TableId(type = IdType.INPUT) private Long customId; // 其他属性... } 这样，不同的实体类对应不同的表就可以使用不同的主键生成策略。 全局策略配置 在MyBatis-Plus中，id生成策略的控制可以通过全局策略配置来统一设置，以确保所有的实体类都使用相同的主键生成策略。全局策略配置是在MyBatis-Plus的配置文件中进行设置的，可以通过配置GlobalConfiguration来实现。 Step 1：创建全局配置类 首先，我们需要创建一个全局配置类，继承GlobalConfiguration类，并在该类中配置主键生成策略。 @Configuration public class MybatisPlusConfig extends GlobalConfiguration { @Override public IKeyGenerator keyGenerator() { // 返回自定义的主键生成器 return new CustomKeyGenerator(); } } Step 2：自定义主键生成器 接下来，我们需要实现自定义的主键生成器。自定义主键生成器需要实现IKeyGenerator接口，并重写executeSql()方法来生成主键。 public class CustomKeyGenerator implements IKeyGenerator { @Override public String executeSql(String incrementerName) { // 在这里实现你的主键生成逻辑，可以使用雪花算法、UUID等方式生成主键 // 这里简单示例为使用UUID生成主键 return UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); } } Step 3：配置全局策略 在MyBatis-Plus的配置文件中，将自定义的全局配置类加入到配置中。 @EnableTransactionManagement @Configuration @MapperScan(&quot;com.example.mapper&quot;) public class MybatisPlusConfig { @Bean public GlobalConfiguration globalConfiguration() { GlobalConfiguration conf = new GlobalConfiguration(); // 设置自定义的主键生成器 conf.setKeyGenerator(new CustomKeyGenerator()); return conf; } } Step 4：使用全局策略配置 在以上配置完成后，MyBatis-Plus会自动使用全局策略配置中的主键生成器，来生成实体类中所有使用@TableId注解的主键。 示例代码： @Data @TableName(&quot;tbl_log&quot;) public class Log { @TableId(type = IdType.INPUT) private Long id; // 使用自定义主键生成器生成主键 private String content; // 其他属性... } 在上述示例中，我们使用了@TableId注解来设置主键，并通过全局策略配置中的自定义主键生成器生成主键值。 使用全局策略配置可以确保所有的实体类都使用相同的主键生成策略，避免了在每个实体类中都重复配置主键生成策略的麻烦。同时，也提高了代码的复用性和可维护性。 在MyBatis-Plus中，我们可以通过全局策略配置来统一设置所有实体类的主键生成策略。通过在Spring Boot的配置文件中配置相关参数，可以灵活地控制主键生成策略。 1. 配置文件中添加全局策略配置 在Spring Boot的配置文件（通常是application.properties或application.yml）中，可以添加以下配置项来设置全局的主键生成策略： # application.properties # 设置全局主键生成策略 mybatis-plus.global-config.db-config.id-type=UUID # 表名前缀 mybatis-plus.global-config.db-config.table-prefix: t_ # application.yml mybatis-plus: global-config: db-config: id-type: UUID table-prefix: t_ 在上述配置中，我们将全局的主键生成策略设置为UUID，这将影响所有使用MyBatis-Plus的实体类。 2. 全局策略配置类 除了在配置文件中设置全局策略，我们还可以通过编程的方式来配置全局策略。创建一个全局策略配置类，继承com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig，并重写相应的方法。 示例代码如下： @Configuration public class MybatisPlusConfig { @Bean public GlobalConfig globalConfig() { GlobalConfig globalConfig = new GlobalConfig(); DbConfig dbConfig = new GlobalConfig.DbConfig(); // 设置主键生成策略为UUID dbConfig.setIdType(IdType.UUID); globalConfig.setDbConfig(dbConfig); return globalConfig; } } 在上述示例中，我们创建了一个MybatisPlusConfig类，并通过@Bean注解将GlobalConfig对象交给Spring容器管理。在globalConfig方法中，我们设置了主键生成策略为UUID。 3. 实体类使用@TableId注解 无论是通过配置文件设置全局策略，还是通过编程方式设置全局策略，都需要在实体类中使用@TableId注解来指定主键生成策略。 示例代码如下： @Data public class User { @TableId(type = IdType.AUTO) // 设置主键生成策略为自增 private Long id; // 其他属性... } 在上述示例中，我们使用@TableId注解，将实体类中的id属性的主键生成策略设置为自增，而不受全局策略的影响。 4. 多种主键生成策略的混合使用 在实际开发中，不同的表可能需要采用不同的主键生成策略。如果某个表需要使用特定的主键生成策略，可以在实体类中直接指定，而不受全局策略的影响。 示例代码如下： @Data public class Order { @TableId(type = IdType.NONE) // 手动指定订单号作为主键 private String orderId; // 其他属性... } 在上述示例中，我们使用@TableId注解，将实体类中的orderId属性设置为手动指定主键，而不使用全局策略。 批量操作 多记录删除（批量Delete） MyBatis-Plus中，我们可以使用deleteBatchIds方法来实现多记录删除。该方法接收一个ID列表作为参数，可以删除多个记录。 代码实现： 假设我们有一个User实体类，对应数据库中的user表。现在我们要删除多个用户，可以使用deleteBatchIds方法来实现： @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public boolean deleteUsersByIds(List&lt;Long&gt; userIds) { return removeByIds(userIds); } } 在上述示例中，我们在UserServiceImpl类中定义了一个deleteUsersByIds方法，接收一个userIds列表作为参数，并调用removeByIds方法来执行多记录删除操作。 多记录查询（批量Select） MyBatis-Plus提供了selectBatchIds方法来实现多记录查询。该方法接收一个ID列表作为参数，可以查询多个记录。 代码实现： 假设我们还是使用上面的User实体类和user表，现在我们要根据多个用户ID查询用户信息： @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public List&lt;User&gt; getUsersByIds(List&lt;Long&gt; userIds) { return listByIds(userIds); } } 在上述示例中，我们在UserServiceImpl类中定义了一个getUsersByIds方法，接收一个userIds列表作为参数，并调用listByIds方法来执行多记录查询操作。 多记录更新（批量Update） MyBatis-Plus提供了updateBatchById方法来实现多记录更新。该方法接收一个实体对象列表作为参数，可以更新多个记录。 代码实现： 假设我们还是使用上面的User实体类和user表，现在我们要更新多个用户的信息： @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public boolean updateUsers(List&lt;User&gt; users) { return updateBatchById(users); } } 在上述示例中，我们在UserServiceImpl类中定义了一个updateUsers方法，接收一个users列表作为参数，并调用updateBatchById方法来执行多记录更新操作。 删除操作 删除方式 在实际环境中，删除数据时有两种常见的处理方式：物理删除和逻辑删除。 物理删除 物理删除是指直接从数据库中永久删除数据，使其不再存在于数据库中。这意味着一旦数据被物理删除，就无法恢复，数据将永久丢失。在某些情况下，物理删除可能是合适的选择，比如当数据过期、无用或包含敏感信息时。但是，需要慎重考虑物理删除的后果，确保没有重要数据会被误删。 代码实现： 假设我们使用User实体类和user表作为示例，下面是物理删除的代码示例： @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public boolean deleteUserById(Long userId) { return removeById(userId); } } 在上述代码中，deleteUserById方法接收一个userId作为参数，并调用removeById方法来执行物理删除操作。这样，执行该方法后，数据库中对应的用户数据将被永久删除。 逻辑删除 逻辑删除是指在数据库中保留数据，但通过设置一个额外的字段（通常是状态字段）来标记数据是否可用。当进行删除操作时，不是直接从数据库中删除数据，而是将状态字段设置为标识数据不可用状态。这样，数据仍然保留在数据库中，但在查询时会自动忽略标记为不可用的数据，从逻辑上实现了删除效果。 逻辑删除的好处是可以避免意外删除重要数据，同时保留了删除的记录用于后续查询或数据审计。逻辑删除适用于那些不希望真正删除数据但需要隐藏或标记的场景。 实现步骤 在MyBatis-Plus中，逻辑删除可以通过注解@TableLogic实现。首先，在实体类的状态字段上添加@TableLogic注解： @Data public class User { @TableId(type = IdType.AUTO) private Long id; private String username; @TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;) private Integer status; // 状态字段，用于逻辑删除 } 然后，在UserMapper接口中启用逻辑删除功能： @Mapper public interface UserMapper extends BaseMapper&lt;User&gt; { } 在默认情况下，MyBatis-Plus启用了逻辑删除功能，但需要注意数据库表中的状态字段命名默认为is_deleted，也可以通过全局配置进行修改。当执行删除操作时，MyBatis-Plus会自动将status字段更新为逻辑删除的值（通常是0或1），而不是实际从数据库中删除数据。 关闭逻辑删除 小贴士 逻辑删除功能默认是启用的，如果你不需要逻辑删除功能，可以在全局配置中禁用它。 @Configuration public class MyBatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 禁用逻辑删除 interceptor.addInnerInterceptor(new LogicSqlInjector() { @Override protected boolean doRemoveSql(Supplier&lt;MetaObject&gt; metaObject) { return false; } }); return interceptor; } } 全局开启配置 在Spring Boot中配置MyBatis-Plus的逻辑删除字面值需要在application.yml或application.properties配置文件中添加相应的配置。MyBatis-Plus提供了一组全局配置，其中包括逻辑删除相关的配置项。 1. 添加配置项 在application.yml或application.properties中添加MyBatis-Plus的全局配置项，包括逻辑删除字段名、逻辑删除字面值等。 mybatis-plus: global-config: db-config: # 表名前缀，可选配置，如果有表名前缀，需要加上 table-prefix: tbl_ # 逻辑删除字段名 logic-delete-field: deleted # 逻辑删除字面值：未删除为0 logic-not-delete-value: 0 # 逻辑删除字面值：删除为1 logic-delete-value: 1 在上述配置中，我们配置了表名前缀、逻辑删除字段名以及逻辑删除的字面值。其中，logic-delete-field表示逻辑删除字段名，logic-not-delete-value表示未删除状态的字面值，logic-delete-value表示删除状态的字面值。 2. 实体类配置 在实体类中，需要添加与逻辑删除相关的字段，并使用@TableLogic注解标注该字段。 import com.baomidou.mybatisplus.annotation.TableName; import com.baomidou.mybatisplus.annotation.TableLogic; import lombok.Data; @Data @TableName(value = &quot;tbl_user&quot;) public class User { private Long id; private String username; // 逻辑删除字段 @TableLogic private Integer deleted; } 在上述代码中，我们在User实体类中添加了一个名为deleted的整型字段，并使用@TableLogic注解标注该字段。这样，MyBatis-Plus会自动识别deleted字段为逻辑删除字段。 3. 数据库表配置 在数据库表中创建对应的User表，并添加deleted字段作为逻辑删除字段。 CREATE TABLE tbl_user ( id BIGINT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL, -- 添加逻辑删除字段 deleted INT NOT NULL DEFAULT 0 ); 4. 使用逻辑删除功能 现在，我们已经配置了逻辑删除字面值和相应的实体类字段。在使用MyBatis-Plus进行删除操作时，MyBatis-Plus会自动根据配置进行逻辑删除。 实现案例： 假设我们有一个UserService接口和UserServiceImpl实现类，我们可以在UserServiceImpl中调用MyBatis-Plus的删除方法来实现逻辑删除。 @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public boolean deleteUserById(Long userId) { // 调用MyBatis-Plus的逻辑删除方法 return removeById(userId); } } 在上述代码中，我们通过调用removeById方法实现逻辑删除操作。根据逻辑删除字面值的配置，MyBatis-Plus会将deleted字段的值更新为1，表示数据已删除。 乐观锁 概述 MyBatis-Plus（简称MP）提供了乐观锁机制，用于解决多线程并发更新数据时的数据一致性问题。乐观锁是一种乐观的并发控制策略，它不会对数据库进行锁定，而是通过版本号（或者叫作时间戳）来实现并发控制。当两个或多个线程尝试同时修改同一条记录时，乐观锁会根据版本号来判断哪个线程的更新会成功，从而保证数据的一致性。 使用乐观锁的原理 在数据库表中添加一个用于乐观锁的版本字段，通常是一个整数或时间戳类型。 当执行更新操作时，首先会获取当前记录的版本号，并将版本号作为更新条件。 如果另一个线程已经修改了数据并更新了版本号，那么当前更新操作会失败，因为版本号条件不匹配。 在更新失败后，可以选择重试更新操作或者执行其他逻辑，以保证数据的一致性。 乐观锁实现示例 在MyBatis-Plus中，配置乐观锁拦截器可以实现对乐观锁的支持，使得在进行更新操作时，自动拼装带有版本号的动态SQL语句。乐观锁拦截器会在执行更新操作前进行拦截，并根据实体类中的乐观锁版本号字段，自动拼装带有版本号的更新SQL语句，从而实现乐观锁的功能。 1. 配置乐观锁拦截器 在Spring Boot中，配置乐观锁拦截器需要创建一个配置类，并在其中注册乐观锁拦截器。乐观锁拦截器是MyBatis-Plus提供的OptimisticLockerInterceptor类。 @Configuration public class MyBatisPlusConfig { @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); } } 在上述代码中，我们创建了一个配置类MyBatisPlusConfig，并在其中注册了OptimisticLockerInterceptor乐观锁拦截器。 2. 实体类配置 在实体类中添加乐观锁版本号字段，并使用@Version注解标识该字段为乐观锁版本号。 import com.baomidou.mybatisplus.annotation.TableName; import com.baomidou.mybatisplus.annotation.Version; import lombok.Data; @Data @TableName(&quot;user&quot;) public class User { private Long id; private String username; private String email; @Version // 添加乐观锁注解 private Integer version; } 在上述代码中，我们在User实体类的version字段上添加了@Version注解，表示该字段是乐观锁版本号字段。 3. 动态SQL语句拼装 在进行更新操作时，乐观锁拦截器会自动拼装带有版本号的动态SQL语句。在执行更新操作时，MyBatis-Plus会检测实体类中的乐观锁版本号字段，并自动在更新SQL语句中增加版本号条件，以实现乐观锁的功能。 下面是一个使用乐观锁的示例代码： @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public boolean updateUser(User user) { // 调用MyBatis-Plus的updateById方法进行更新操作 // 在更新操作时，MyBatis-Plus会自动更新版本号 return updateById(user); } } 在上述代码中，我们在UserServiceImpl中调用updateById方法来进行更新操作。MyBatis-Plus会自动检测User对象中的版本号字段，并将版本号作为更新条件，实现乐观锁的功能。 4. 测试乐观锁 为了测试乐观锁的效果，我们可以编写一个测试方法来模拟并发更新的情况。 @RunWith(SpringRunner.class) @SpringBootTest public class UserServiceImplTest { @Autowired private UserService userService; @Test public void testOptimisticLock() { // 假设现在有一条id为1的用户记录，version为0 User user = userService.getById(1L); // 线程1更新用户的信息 user.setUsername(&quot;user1-updated&quot;); userService.updateUser(user); // 线程2同时更新用户的信息 User user2 = userService.getById(1L); user2.setUsername(&quot;user2-updated&quot;); userService.updateUser(user2); } } 在上述测试方法中，我们首先获取一条id为1的用户记录，然后模拟两个线程同时对这条记录进行更新操作。由于乐观锁的存在，只有其中一个线程的更新操作会成功，另一个线程的更新会失败。 5. 结果分析 当两个线程同时更新一条记录时，由于乐观锁的作用，其中一个线程的更新操作会成功，而另一个线程的更新会失败。失败的线程可以根据需要进行重试或者执行其他逻辑，以保证数据的一致性和完整性。 代码生成器 MyBatis-Plus（MP）代码生成器是一个强大的工具，可以帮助开发者快速生成与数据库表对应的Java实体类、Mapper接口、Service接口以及Controller等代码，从而大大提高开发效率。下面将详细并全面地讲解MP代码生成器的使用，并附带相应的代码实现来辅助理解。 1. 添加依赖 首先，我们需要在项目的pom.xml文件中添加MyBatis-Plus和相关数据库驱动的依赖。假设我们使用MySQL数据库，那么添加如下依赖： &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; 请注意将上述依赖中的最新版本替换为实际的MyBatis-Plus和MySQL版本号。 2. 配置数据源 接下来，在application.properties或application.yml中配置数据源信息。 # 数据库连接信息 spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=root spring.datasource.password=your_password spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # MyBatis-Plus配置 mybatis-plus.configuration.map-underscore-to-camel-case=true 请将上述配置中的db_example、root和your_password分别替换为实际的数据库名、用户名和密码。 3. 配置代码生成器 在使用MP代码生成器之前，我们需要配置代码生成器的参数，包括生成的代码输出路径、生成的代码包路径、作者信息、表名、主键生成策略等。 我们可以通过创建一个代码生成器的配置类来完成配置，示例如下： import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.rules.DateType; public class CodeGenerator { public static void main(String[] args) { // 1. 创建代码生成器 AutoGenerator generator = new AutoGenerator(); // 2. 全局配置 GlobalConfig globalConfig = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); // 获取项目根目录 globalConfig.setOutputDir(projectPath + &quot;/src/main/java&quot;); // 设置代码输出路径 globalConfig.setAuthor(&quot;YourName&quot;); // 设置作者 globalConfig.setOpen(false); // 生成完成后是否打开输出目录 globalConfig.setDateType(DateType.ONLY_DATE); // 设置日期类型为仅日期 globalConfig.setIdType(IdType.AUTO); // 设置主键生成策略为自增 generator.setGlobalConfig(globalConfig); // 3. 数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setUrl(&quot;jdbc:mysql://localhost:3306/db_example&quot;); // 数据库连接URL dataSourceConfig.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 数据库驱动 dataSourceConfig.setUsername(&quot;root&quot;); // 数据库用户名 dataSourceConfig.setPassword(&quot;your_password&quot;); // 数据库密码 generator.setDataSource(dataSourceConfig); // 4. 包配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(&quot;com.example&quot;); // 设置生成的代码包路径 generator.setPackageInfo(packageConfig); // 5. 策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setInclude(&quot;table_name&quot;); // 设置要生成代码的表名，多个表名用逗号分隔 strategyConfig.setControllerMappingHyphenStyle(true); // 设置Controller的映射地址为连字符形式 generator.setStrategy(strategyConfig); // 6. 执行代码生成 generator.execute(); } } 在上述代码中，我们配置了代码生成器的全局配置、数据源配置、包配置以及策略配置。请将代码中的YourName、db_example和your_password分别替换为实际的作者名、数据库名和数据库密码。 4. 运行代码生成器 完成配置后，我们只需运行CodeGenerator类的main方法，即可生成对应的代码文件。生成的代码文件将输出在指定的包路径下。 新代码生成器 小贴士 旧版适用版本：mybatis-plus-generator 3.5.1 以下版本，3.5.1 及以上的请参考新代码生成器 快速生成 FastAutoGenerator.create(&quot;url&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; { builder.author(&quot;baomidou&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;D://&quot;); // 指定输出目录 }) .dataSourceConfig(builder -&gt; builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -&gt; { int typeCode = metaInfo.getJdbcType().TYPE_CODE; if (typeCode == Types.SMALLINT) { // 自定义类型转换 return DbColumnType.INTEGER; } return typeRegistry.getColumnType(metaInfo); })) .packageConfig(builder -&gt; { builder.parent(&quot;com.baomidou.mybatisplus.samples.generator&quot;) // 设置父包名 .moduleName(&quot;system&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;D://&quot;)); // 设置mapperXml生成路径 }) .strategyConfig(builder -&gt; { builder.addInclude(&quot;t_simple&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 }) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); 交互式生成 FastAutoGenerator.create(DATA_SOURCE_CONFIG) // 全局配置 .globalConfig((scanner, builder) -&gt; builder.author(scanner.apply(&quot;请输入作者名称？&quot;)).fileOverride()) // 包配置 .packageConfig((scanner, builder) -&gt; builder.parent(scanner.apply(&quot;请输入包名？&quot;))) // 策略配置 .strategyConfig((scanner, builder) -&gt; builder.addInclude(getTables(scanner.apply(&quot;请输入表名，多个英文逗号分隔？所有输入 all&quot;))) .controllerBuilder().enableRestStyle().enableHyphenStyle() .entityBuilder().enableLombok().addTableFills( new Column(&quot;create_time&quot;, FieldFill.INSERT) ).build()) /* 模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker .templateEngine(new BeetlTemplateEngine()) .templateEngine(new FreemarkerTemplateEngine()) */ .execute(); // 处理 all 情况 protected static List&lt;String&gt; getTables(String tables) { return &quot;all&quot;.equals(tables) ? Collections.emptyList() : Arrays.asList(tables.split(&quot;,&quot;)); } ","tags":[{"index":-1,"name":"MyBatis","slug":"tag-MyBatis","used":true,"link":"https://riftrays.github.io/tag-MyBatis/"},{"index":-1,"name":"MyBatis-Plus","slug":"tag-MyBatis-Plus","used":true,"link":"https://riftrays.github.io/tag-MyBatis-Plus/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Mybatis-Plus","feature":"","link":"https://riftrays.github.io/2m8J3JVh/","stats":{"text":"69 min read","time":4136000,"words":16590,"minutes":69},"date":"2020-01-05 21:47:14","dateFormat":"2020-01-05 21:47:14"},{"abstract":"","content":"概述 Lombok是一个Java库，它通过注解来简化Java类的编写，减少了冗余的代码，提高了开发效率。Lombok可以帮助我们在编译时自动生成一些常用的方法，如getter、setter、toString、equals等，同时还支持更多功能，如@Data注解可以自动生成所有常用的方法，@NoArgsConstructor可以自动生成无参构造函数等。 @Getter和@Setter 使用@Getter注解在类上，可以为所有非静态字段自动生成getter方法。 使用@Setter注解在类上，可以为所有非静态字段自动生成setter方法。 import lombok.Getter; import lombok.Setter; @Getter @Setter public class Person { private String name; private int age; } // 自动生成的代码相当于 public class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } @ToString 使用@ToString注解在类上，可以自动生成toString方法。 import lombok.ToString; @ToString public class Person { private String name; private int age; } // 自动生成的代码相当于 public class Person { private String name; private int age; @Override public String toString() { return &quot;Person(name=&quot; + name + &quot;, age=&quot; + age + &quot;)&quot;; } } @EqualsAndHashCode 使用@EqualsAndHashCode注解在类上，可以自动生成equals和hashCode方法。 import lombok.EqualsAndHashCode; @EqualsAndHashCode public class Person { private String name; private int age; } // 自动生成的代码相当于 public class Person { private String name; private int age; @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } } @Data 使用@Data注解在类上，可以自动生成所有常用的方法，包括@Getter、@Setter、@ToString、@EqualsAndHashCode。 import lombok.Data; @Data public class Person { private String name; private int age; } // 自动生成的代码相当于 public class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Person(name=&quot; + name + &quot;, age=&quot; + age + &quot;)&quot;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } } @NoArgsConstructor和@AllArgsConstructor 使用@NoArgsConstructor注解在类上，可以自动生成无参构造函数。 使用@AllArgsConstructor注解在类上，可以自动生成包含所有字段的构造函数。 import lombok.NoArgsConstructor; import lombok.AllArgsConstructor; @NoArgsConstructor @AllArgsConstructor public class Person { private String name; private int age; } // 自动生成的代码相当于 public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } } @RequiredArgsConstructor 使用@RequiredArgsConstructor注解在类上，可以自动生成包含final字段的构造函数。 import lombok.RequiredArgsConstructor; @RequiredArgsConstructor public class Person { private final String name; private final int age; } // 自动生成的代码相当于 public class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } } @Builder 使用@Builder注解在类上，可以自动生成Builder模式的构造方法。 import lombok.Builder; @Builder public class Person { private String name; private int age; } // 自动生成的代码相当于 public class Person { private String name; private int age; private Person(String name, int age) { this.name = name; this.age = age; } public static PersonBuilder builder() { return new PersonBuilder(); } public static class PersonBuilder { private String name; private int age; private PersonBuilder() { } public PersonBuilder name(String name) { this.name = name; return this; } public PersonBuilder age(int age) { this.age = age; return this; } public Person build() { return new Person(name, age); } } } ","tags":[{"index":9,"name":"Plug-In","slug":"tag-Plug-In","used":true,"link":"https://riftrays.github.io/tag-Plug-In/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Lombok","feature":"","link":"https://riftrays.github.io/b5cgF9qH5/","stats":{"text":"5 min read","time":241000,"words":808,"minutes":5},"date":"2020-01-02 22:55:58","dateFormat":"2020-01-02 22:55:58"},{"abstract":"","content":"概述 MyBatis是一种轻量级的Java持久层框架，它提供了简单而强大的数据库访问功能，帮助开发者将Java对象与数据库之间进行映射和交互。 ORM（对象关系映射）：MyBatis采用ORM的思想，将数据库表和Java对象之间建立映射关系。通过配置和编写SQL映射文件，开发者可以直接使用Java对象来操作数据库，而无需手动编写大量的JDBC代码。 核心组件： SqlSessionFactory：SqlSessionFactory是MyBatis的核心接口，负责创建和管理SqlSession对象。它是单个数据库映射关系的工厂类，通过它可以获取SqlSession对象来执行SQL操作。 SqlSession：SqlSession是与数据库交互的会话对象，它提供了执行SQL语句、获取映射器（Mapper）和管理事务的方法。 Mapper接口：Mapper接口定义了与数据库交互的方法，通过编写Mapper接口的方法以及对应的XML配置文件，可以实现Java方法和SQL语句的映射关系。 作用 MyBatis的作用是简化和优化Java应用程序与数据库之间的交互过程。它提供了以下主要功能和作用： 数据库访问：MyBatis使得数据库的访问变得简单和高效。通过编写SQL映射文件和Mapper接口，开发者可以使用面向对象的方式执行数据库操作，包括插入、更新、删除和查询等常见操作。 对象关系映射（ORM）：MyBatis实现了数据库表和Java对象之间的映射关系，通过配置和映射文件，可以将查询结果自动映射到Java对象中。这使得开发者可以使用面向对象的方式操作数据，而无需手动编写JDBC代码。 灵活的SQL编写：MyBatis提供了灵活的SQL编写方式，支持静态SQL和动态SQL。开发者可以在SQL映射文件中编写SQL语句，通过使用条件判断、循环和参数绑定等功能，可以动态构建SQL语句，满足各种复杂的查询需求。 缓存支持：MyBatis内置了缓存机制，可以将查询结果缓存起来，提高查询性能。通过配置和合理使用缓存，可以减少数据库的访问次数，加快应用程序的响应速度。 事务管理：MyBatis提供了事务管理的支持，开发者可以通过SqlSession来管理事务。MyBatis可以与Spring等框架集成，实现声明式事务管理，保证数据库操作的原子性和一致性。 扩展性和插件：MyBatis具有良好的扩展性，允许开发者编写自定义的类型处理器、拦截器和插件等，以满足特定的需求。这使得开发者可以根据应用程序的需求进行定制和扩展。 原理 配置文件：MyBatis使用一个配置文件（mybatis-config.xml）来配置和初始化框架的各种设置，例如数据库连接、类型处理器、插件等。 SQL映射文件：SQL映射文件（Mapper）定义了Java方法和对应的SQL语句的映射关系。通过配置SQL映射文件，MyBatis可以自动执行SQL语句并将结果映射到Java对象中。 SqlSessionFactoryBuilder：SqlSessionFactoryBuilder是用于创建SqlSessionFactory的构建器，它读取配置文件并解析配置信息，然后构建出SqlSessionFactory对象。 SqlSessionFactory：SqlSessionFactory是由SqlSessionFactoryBuilder创建的，它是一个线程安全的工厂类，用于创建SqlSession对象。 SqlSession：SqlSession是与数据库交互的会话对象，它提供了执行SQL语句、获取映射器（Mapper）和管理事务的方法。每个线程都应该拥有自己的SqlSession实例。 安装配置 引入MyBatis依赖：在您的Java项目中，需要将MyBatis作为依赖添加到项目的构建文件（如Maven或Gradle）中。您可以从Maven中央存储库或MyBatis官方网站获取最新的MyBatis依赖。 创建MyBatis配置文件：在项目的资源目录下创建一个名为mybatis-config.xml的文件，用于配置MyBatis的各种设置。 配置数据源：在mybatis-config.xml文件中配置数据库连接信息和连接池。您可以使用MyBatis提供的内置连接池（如PooledDataSource），或者使用第三方的连接池库（如Druid或HikariCP）。 创建SQL映射文件（Mapper）：创建一个或多个XML文件，用于定义SQL语句和与之对应的映射关系。这些文件通常与数据库表或Java对象相关联。 配置SQL映射文件：在mybatis-config.xml文件中配置SQL映射文件的路径，以便MyBatis可以找到并加载它们。您可以使用相对路径或绝对路径，确保文件能够正确加载。 创建SqlSessionFactory：使用mybatis-config.xml文件的配置信息，通过编程方式创建SqlSessionFactory实例。可以使用SqlSessionFactoryBuilder类来构建SqlSessionFactory。 获取SqlSession：使用SqlSessionFactory创建SqlSession对象。SqlSession是与数据库交互的会话对象，它提供了执行SQL语句、获取映射器（Mapper）和管理事务的方法。 编写Mapper接口：创建Java接口，定义与数据库交互的方法。每个方法对应于一个SQL语句。可以使用注解或XML文件来配置方法与SQL语句的映射关系。 执行数据库操作：使用SqlSession通过调用Mapper接口的方法执行数据库操作。MyBatis将根据配置的映射关系执行对应的SQL语句，并将结果映射到Java对象中。 当安装和配置MyBatis时，涉及的配置文件和代码如下所示： 创建mybatis-config.xml文件（示例内容）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置数据源 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydatabase&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置SQL映射文件的路径 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/example/mappers/MyMapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 创建SQL映射文件 MyMapper.xml（示例内容）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.example.mappers.MyMapper&quot;&gt; &lt;!-- 定义结果映射 --&gt; &lt;resultMap id=&quot;myModelResultMap&quot; type=&quot;com.example.models.MyModel&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt; &lt;!-- 其他属性映射 --&gt; &lt;/resultMap&gt; &lt;!-- 查询操作 --&gt; &lt;select id=&quot;getById&quot; resultMap=&quot;myModelResultMap&quot; parameterType=&quot;int&quot;&gt; SELECT * FROM my_table WHERE id = #{id} &lt;/select&gt; &lt;select id=&quot;getAll&quot; resultMap=&quot;myModelResultMap&quot;&gt; SELECT * FROM my_table &lt;/select&gt; &lt;!-- 插入操作 --&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.example.models.MyModel&quot;&gt; INSERT INTO my_table (name, email) VALUES (#{name}, #{email}) &lt;/insert&gt; &lt;!-- 更新操作 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.example.models.MyModel&quot;&gt; UPDATE my_table SET name = #{name}, email = #{email} WHERE id = #{id} &lt;/update&gt; &lt;!-- 删除操作 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; DELETE FROM my_table WHERE id = #{id} &lt;/delete&gt; &lt;!-- 其他SQL语句和映射关系 --&gt; &lt;/mapper&gt; 创建Mapper接口 MyMapper.java（示例内容）： package com.example.mappers; import com.example.models.MyModel; public interface MyMapper { MyModel getById(int id); void insert(MyModel model); // 其他方法声明 } 创建SqlSessionFactory和SqlSession： import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.apache.ibatis.session.SqlSession; public class MyBatisConfig { public static void main(String[] args) { // 读取mybatis-config.xml配置文件 String configPath = &quot;path/to/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(configPath); // 创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession获取Mapper接口实例 MyMapper myMapper = sqlSession.getMapper(MyMapper.class); // 执行数据库操作 MyModel result = myMapper.getById(1); System.out.println(result); // 提交事务并关闭SqlSession sqlSession.commit(); sqlSession.close(); } } 上述代码中，需要注意将mybatis-config.xml的路径、SQL映射文件的路径以及数据库连接的配置信息根据实际情况进行修改。 拓展：插入操作中返回添加数据的主键 在插入操作中，如果需要获取添加数据的主键，可以通过 MyBatis 提供的一些特性来实现。下面是详细讲解如何在插入操作中返回添加数据的主键： 在 Mapper XML 文件中，使用 &lt;insert&gt; 元素执行插入操作，并设置 useGeneratedKeys 属性为 true，同时指定 keyProperty 属性来指定保存主键值的属性。 &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO users (name, age) VALUES (#{name}, #{age}) &lt;/insert&gt; 在上述示例中，useGeneratedKeys 属性设置为 true，表示开启自动生成主键的功能，keyProperty 属性设置为 id，表示将生成的主键值赋给 id 属性。 在 Java 对象中，需要为保存主键值的属性提供对应的 setter 方法。 public class User { private Long id; private String name; private int age; // Getter and Setter for id // Getter and Setter for name and age } 确保 User 类中的 id 属性有对应的 getter 和 setter 方法。 在执行插入操作后，通过获取 User 对象的 id 属性即可获取添加数据的主键值。 User user = new User(); user.setName(&quot;John&quot;); user.setAge(25); userMapper.insertUser(user); Long generatedId = user.getId(); 在上述示例中，通过调用 insertUser 方法插入数据后，可以通过 user.getId() 方法获取添加数据的主键值。 常用配置 MyBatis的核心配置文件mybatis-config.xml具有以下结构和常用配置项： 根元素 &lt;configuration&gt;：表示配置文件的根元素，包含了整个配置的内容。 &lt;properties&gt; 元素：用于定义属性，可以在配置文件中引用这些属性。常用的子元素有： &lt;property&gt;：定义一个属性，包括name和value两个属性，用于设置属性的名称和值。 &lt;settings&gt; 元素：配置全局设置选项，用于影响 MyBatis 的运行时行为。常用的设置项有： &lt;setting&gt;：用于设置具体的选项，包括name和value两个属性。 cacheEnabled：是否启用缓存，默认值为 true。 lazyLoadingEnabled：是否启用延迟加载，默认值为 false。 mapUnderscoreToCamelCase：是否开启自动驼峰命名规则映射，默认值为 false。 &lt;typeAliases&gt; 元素：用于配置类型别名，简化映射器中的类型引用。常用的子元素有： &lt;typeAlias&gt;：用于定义一个类型别名，包括type和alias两个属性，分别指定类型和别名。 &lt;typeHandlers&gt; 元素：配置类型处理器，用于处理 Java 类型与数据库类型之间的转换。常用的子元素有： &lt;typeHandler&gt;：用于配置具体的类型处理器，可以指定 Java 类型和对应的处理器类。 &lt;objectFactory&gt; 元素：配置对象工厂，用于创建映射器中的结果对象。常用的子元素有： &lt;property&gt;：用于配置对象工厂的属性。 &lt;plugins&gt; 元素：用于配置插件，可以在 MyBatis 的执行过程中添加自定义的功能扩展。常用的子元素有： &lt;plugin&gt;：用于配置具体的插件，需要指定插件的实现类。 &lt;environments&gt; 元素：配置 MyBatis 的环境，包括事务管理器和数据源。常用的子元素有： &lt;environment&gt;：定义一个具体的环境，包含事务管理器和数据源配置。 &lt;transactionManager&gt;：配置事务管理器的类型。 &lt;dataSource&gt;：配置数据源的类型和相关属性。 &lt;databaseIdProvider&gt; 元素：用于根据数据库厂商标识（databaseId）选择不同的语句。常用的子元素有： &lt;property&gt;：用于配置数据库厂商标识和对应的语句。 &lt;mappers&gt; 元素：配置映射器，用于告知 MyBatis 哪些接口是映射器。常用的子元素有： &lt;mapper&gt;：用于指定映射器的位置，可以通过路径、类或包进行配置。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置数据源 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 配置数据源类型 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 数据库连接信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydatabase&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射器 --&gt; &lt;mappers&gt; &lt;!-- 方式1：通过路径加载映射器 --&gt; &lt;mapper resource=&quot;com/example/mappers/MyMapper.xml&quot; /&gt; &lt;!-- 方式2：通过类加载映射器 --&gt; &lt;mapper class=&quot;com.example.mappers.OtherMapper&quot; /&gt; &lt;!-- 方式3：使用包扫描加载映射器 --&gt; &lt;package name=&quot;com.example.mappers&quot; /&gt; &lt;/mappers&gt; &lt;!-- 其他常用配置选项 --&gt; &lt;!-- 开启或关闭缓存，默认为true --&gt; &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt; &lt;!-- 开启或关闭延迟加载，默认为false --&gt; &lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot; /&gt; &lt;/settings&gt; &lt;!-- 开启或关闭自动驼峰命名规则映射，默认为false --&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt; &lt;/settings&gt; &lt;!-- 设置日志实现类 --&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot; /&gt; &lt;/settings&gt; &lt;/configuration&gt; 数据源配置： &lt;environments&gt;元素用于配置MyBatis的环境，包含多个&lt;environment&gt;子元素，可用于定义多个环境，例如development、production等。 &lt;environment&gt;元素用于定义一个具体的环境，包括事务管理器和数据源配置。 &lt;transactionManager&gt;元素用于指定事务管理器的类型，常见的类型有： JDBC：使用JDBC事务管理器，适用于单个数据库的场景。 MANAGED：使用容器管理的事务，例如Java EE容器管理的事务。 &lt;dataSource&gt;元素用于配置数据源的类型，常用的类型有： POOLED：使用连接池管理数据库连接，通过配置属性如driver、url、username、password等来连接数据库。 UNPOOLED：不使用连接池，每次请求都会创建新的数据库连接。 JNDI：使用Java命名和目录接口（JNDI）获取数据源。 映射器配置： &lt;mappers&gt;元素用于配置映射器，可以通过多种方式加载映射器。 &lt;mapper resource=&quot;com/example/mappers/MyMapper.xml&quot; /&gt;用于通过路径加载映射器，指定映射器文件的路径。 &lt;mapper class=&quot;com.example.mappers.OtherMapper&quot; /&gt;用于通过类加载映射器，指定映射器接口的类名。 &lt;package name=&quot;com.example.mappers&quot; /&gt;用于通过包扫描加载映射器，指定包的路径，MyBatis将扫描包路径下的映射器接口。 缓存配置： &lt;settings&gt;元素用于配置全局设置选项。 &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;用于开启或关闭缓存，默认为true。 MyBatis提供多种缓存实现，包括本地缓存、二级缓存等，可根据需要进行配置。 延迟加载配置： &lt;settings&gt;元素中的&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot; /&gt;用于开启或关闭延迟加载，默认为false。 当开启延迟加载时，MyBatis将延迟加载关联对象的属性，直到访问该属性时才进行加载。 命名规则映射配置： &lt;settings&gt;元素中的&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt;用于开启或关闭自动驼峰命名规则映射，默认为false。 当开启自动驼峰命名规则映射时，MyBatis会自动将数据库列名的下划线命名转换为Java对象的驼峰命名属性。 日志配置： &lt;settings&gt;元素中的&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot; /&gt;用于设置日志实现类。 MyBatis支持多种日志实现，可根据项目使用的日志框架进行配置，如LOG4J、SLF4J、STDOUT_LOGGING等。 基本使用 定义数据模型（Model）： 创建一个Java类，用于表示数据库表中的一行数据。 在类中定义与表中列对应的属性，并提供相应的getter和setter方法。 编写映射器（Mapper）： 创建一个映射器接口，用于定义数据库操作的方法。 在接口中定义与数据库操作相对应的方法，并使用注解或XML配置SQL语句。 配置MyBatis： 创建mybatis-config.xml配置文件，配置数据源、映射器等相关设置。 在配置文件中指定映射器的位置，可以通过XML文件路径、类路径或包扫描等方式加载映射器。 使用MyBatis进行数据库操作： 获取SqlSessionFactory对象，它是MyBatis的核心对象，负责创建SqlSession对象。 通过SqlSession对象，调用映射器接口中的方法执行数据库操作。 SQL映射文件（Mapper） 概述 SQL映射文件（Mapper）是MyBatis中定义数据库操作的地方。它包含了SQL语句和映射器接口方法之间的映射关系。 创建SQL映射文件： 创建一个以.xml为后缀的文件，用于存放SQL语句和映射关系。 可以将SQL映射文件放置在类路径下的任意位置，例如resources目录。 定义命名空间： 在SQL映射文件的根元素上，使用namespace属性定义一个命名空间，用于唯一标识该映射文件。 命名空间的值通常是映射器接口的完全限定名，例如com.example.mappers.UserMapper。 编写SQL语句： 使用合适的SQL元素（如&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;）编写SQL语句。 在SQL元素中，使用${}或#{}来引用参数或属性。 配置映射器接口方法： 在SQL映射文件中，通过与映射器接口中的方法相对应，建立方法与SQL语句之间的映射关系。 使用合适的SQL元素来定义SQL语句，并使用id属性指定映射器接口中的方法名。 使用参数： 在SQL语句中，可以使用${}和#{}两种方式来引用参数。 ${}会将参数的值直接替换到SQL语句中，可能会有SQL注入的风险。 #{}会将参数作为预编译参数进行处理，更加安全。 处理结果集： 使用&lt;resultMap&gt;元素定义结果集的映射关系，将查询结果的列与映射器接口方法返回类型中的属性进行映射。 使用&lt;result&gt;元素定义列和属性的映射关系。 使用&lt;association&gt;和&lt;collection&gt;元素处理一对一和一对多的关联关系。 配置其他元素： 可以在SQL映射文件中配置其他元素，如动态SQL、参数类型处理器、缓存等。 配置映射器： 在mybatis-config.xml中的&lt;mappers&gt;元素中配置映射器。 可以通过多种方式加载映射器，如通过路径、类或包进行配置。 编写和配置 &lt;!-- 定义命名空间 --&gt; &lt;mapper namespace=&quot;com.example.mappers.UserMapper&quot;&gt; &lt;!-- 定义查询用户的SQL语句 --&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;com.example.models.User&quot;&gt; SELECT * FROM users WHERE id = #{id} &lt;/select&gt; &lt;!-- 定义插入用户的SQL语句 --&gt; &lt;insert id=&quot;insertUser&quot;&gt; INSERT INTO users (name, email) VALUES (#{name}, #{email}) &lt;/insert&gt; &lt;!-- 定义更新用户的SQL语句 --&gt; &lt;update id=&quot;updateUser&quot;&gt; UPDATE users SET name = #{name}, email = #{email} WHERE id = #{id} &lt;/update&gt; &lt;!-- 定义删除用户的SQL语句 --&gt; &lt;delete id=&quot;deleteUser&quot;&gt; DELETE FROM users WHERE id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 特殊字符处理 在编写 Mapper XML 文件时，如果遇到特殊字符，可以使用 XML 的转义字符来处理。以下是常见的几个特殊字符及其对应的转义字符： &lt;（小于号）：使用 &amp;lt; 表示。 &gt;（大于号）：使用 &amp;gt; 表示。 &amp;（和号）：使用 &amp;amp; 表示。 &quot;（双引号）：使用 &amp;quot; 表示。 '（单引号）：使用 &amp;apos; 表示。 例如，如果你的 SQL 语句中包含一个 &lt; 符号，你可以使用 &amp;lt; 替代它。 下面是一个示例，展示如何在 Mapper XML 文件中处理特殊字符： &lt;select id=&quot;getUserByName&quot; resultType=&quot;com.example.User&quot;&gt; SELECT * FROM users WHERE name = '&amp;lt;John&amp;gt;' &lt;/select&gt; 在上述示例中，SQL 语句中的特殊字符 &lt; 和 &gt; 被转义为 &amp;lt; 和 &amp;gt;。这样可以确保 XML 解析时不会将其误认为是标签，而是作为普通的文本处理。 除了使用 XML 转义字符处理特殊字符之外，还有另一种处理方式，即使用 CDATA（字符数据）块来包裹包含特殊字符的内容。CDATA 块会告诉 XML 解析器将其中的内容视为纯文本，不会解析其中的标签或特殊字符。 以下是使用 CDATA 块处理特殊字符的示例： &lt;select id=&quot;getUserByName&quot; resultType=&quot;com.example.User&quot;&gt; &lt;![CDATA[ SELECT * FROM users WHERE name = '&lt;John&gt;' ]]&gt; &lt;/select&gt; 在上述示例中，SQL 语句被包裹在 &lt;![CDATA[ 和 ]]&gt; 之间，告诉 XML 解析器将其视为纯文本。这样可以避免解析器将 &lt; 和 &gt; 等特殊字符作为标签进行处理。 使用 CDATA 块处理特殊字符的好处是可以更直观地表达包含特殊字符的内容，并且不需要手动转义每个特殊字符。但需要注意，CDATA 块内部仍然要遵循 XML 的语法规则，例如不可出现 ]]&gt; 的内容。 动态SQL语句 使用if语句 在 MyBatis 中，&lt;if&gt; 元素是一种常用的动态 SQL 标签，用于根据条件动态生成 SQL 语句的一部分。&lt;if&gt; 元素通常结合其他 SQL 标签一起使用，例如 &lt;select&gt;、&lt;update&gt;、&lt;insert&gt; 等，以根据条件决定是否包含某个语句块或生成特定的 SQL 语句。 下面是一个示例，展示如何在 MyBatis 中使用 &lt;if&gt; 元素生成动态的 SQL 语句： &lt;select id=&quot;getUserList&quot; parameterType=&quot;com.example.UserSearchCriteria&quot; resultType=&quot;com.example.User&quot;&gt; SELECT * FROM users WHERE 1=1 &lt;if test=&quot;name != null&quot;&gt; AND name = #{name} &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; AND age = #{age} &lt;/if&gt; &lt;if test=&quot;email != null and email != ''&quot;&gt; AND email = #{email} &lt;/if&gt; &lt;/select&gt; 在上述示例中，&lt;if&gt; 元素用于根据不同的条件判断是否生成对应的 SQL 语句部分。每个 &lt;if&gt; 元素都有一个 test 属性，用于指定判断条件。 例如，如果传入了 name 和 age 参数，但没有传入 email 参数，则生成的 SQL 语句将只包含 name 和 age 条件的部分。 UserSearchCriteria criteria = new UserSearchCriteria(); criteria.setName(&quot;John&quot;); criteria.setAge(25); List&lt;User&gt; userList = userMapper.getUserList(criteria); 在上述示例中，根据传入的搜索条件对象 UserSearchCriteria 中的属性值，动态生成 SQL 语句。只有满足条件的 &lt;if&gt; 块中的语句会被包含在最终的 SQL 语句中。 通过使用 &lt;if&gt; 元素，可以根据不同的条件动态生成 SQL 语句的一部分，以适应不同的查询需求。在实际使用中，可以根据具体的业务场景和查询条件，结合其他动态 SQL 标签来编写更复杂的动态 SQL 语句。 使用choose语句 在 MyBatis 中，&lt;choose&gt; 元素是一种用于处理多个条件的动态 SQL 标签。它类似于 Java 中的 switch-case 语句，用于在多个条件中选择一个满足条件的分支。 下面是一个示例，展示如何在 MyBatis 中使用 &lt;choose&gt; 元素生成动态的 SQL 语句： &lt;select id=&quot;getUserList&quot; parameterType=&quot;com.example.UserSearchCriteria&quot; resultType=&quot;com.example.User&quot;&gt; SELECT * FROM users WHERE 1=1 &lt;choose&gt; &lt;when test=&quot;name != null&quot;&gt; AND name = #{name} &lt;/when&gt; &lt;when test=&quot;age != null&quot;&gt; AND age = #{age} &lt;/when&gt; &lt;otherwise&gt; AND email = #{email} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; 在上述示例中，&lt;choose&gt; 元素包含多个 &lt;when&gt; 元素和一个 &lt;otherwise&gt; 元素。每个 &lt;when&gt; 元素用于指定一个条件，如果满足该条件，则生成对应的 SQL 语句部分。&lt;otherwise&gt; 元素是可选的，用于指定默认的条件分支，当其他条件都不满足时，会生成对应的 SQL 语句部分。 例如，如果传入了 name 和 age 参数，但没有传入 email 参数，则生成的 SQL 语句将只包含 name 和 age 条件的部分。 UserSearchCriteria criteria = new UserSearchCriteria(); criteria.setName(&quot;John&quot;); criteria.setAge(25); List&lt;User&gt; userList = userMapper.getUserList(criteria); 在上述示例中，根据传入的搜索条件对象 UserSearchCriteria 中的属性值，动态生成 SQL 语句。只有满足条件的 &lt;when&gt; 块中的语句会被包含在最终的 SQL 语句中，如果所有的条件都不满足，则会执行 &lt;otherwise&gt; 块中的语句。 通过使用 &lt;choose&gt; 元素，可以根据多个条件选择一个满足条件的分支，并生成对应的 SQL 语句。这样可以在复杂的查询场景中灵活地处理多个条件的组合，以满足不同的查询需求。 使用Set语句 在 MyBatis 中，&lt;set&gt; 元素用于动态生成 SQL 语句中的 SET 子句，用于指定要修改的字段和对应的值。 &lt;set&gt; 元素可以与其他动态标签（如 &lt;if&gt;、&lt;choose&gt; 等）结合使用，以根据条件动态生成 SET 子句的内容。 下面是一个示例，展示如何在 MyBatis 中使用 &lt;set&gt; 元素生成动态的 SET 子句： &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.example.User&quot;&gt; UPDATE users &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #{name}, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age = #{age}, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email = #{email}, &lt;/if&gt; &lt;/set&gt; WHERE id = #{id} &lt;/update&gt; 在上述示例中，&lt;set&gt; 元素包含了多个 &lt;if&gt; 元素。每个 &lt;if&gt; 元素用于判断某个字段是否需要修改。如果满足条件，就会生成对应的 SET 子句，将字段和值添加到 SQL 语句中。 例如，如果只传入了 name 字段和值，那么生成的 SQL 语句将只包含修改 name 字段的 SET 子句。 User user = new User(); user.setId(1L); user.setName(&quot;John Doe&quot;); userMapper.updateUser(user); 在上述示例中，只传入了 name 字段和值，生成的 SQL 语句将只修改 name 字段的值。 使用 &lt;set&gt; 元素可以灵活地根据条件动态生成 SET 子句，以满足不同的修改需求。可以根据具体的业务场景，结合其他动态标签来编写复杂的动态 SQL 语句。 使用foreach语句 在 MyBatis 中，&lt;foreach&gt; 元素是一种用于遍历集合或数组并生成动态 SQL 语句的标签。它可以循环处理集合中的元素，并将每个元素应用于指定的 SQL 语句部分。 下面是一个示例，展示如何在 MyBatis 中使用 &lt;foreach&gt; 元素生成动态的 SQL 语句： &lt;select id=&quot;getUserList&quot; parameterType=&quot;java.util.List&quot; resultType=&quot;com.example.User&quot;&gt; SELECT * FROM users WHERE id IN &lt;foreach item=&quot;id&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt; &lt;/select&gt; 在上述示例中，&lt;foreach&gt; 元素用于遍历传入的 List 类型参数中的元素，并将每个元素应用于 SQL 语句中的 IN 子句中。item 属性指定了循环变量的名称，collection 属性指定了要遍历的集合或数组，open、separator、close 属性用于指定拼接 SQL 语句时的开头、分隔符和结尾。 例如，传入了一个包含多个用户 ID 的列表： List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); List&lt;User&gt; userList = userMapper.getUserList(idList); 在上述示例中，根据传入的 ID 列表，动态生成 SQL 语句，使用 IN 子句查询符合条件的用户。 通过使用 &lt;foreach&gt; 元素，可以在 SQL 语句中循环遍历集合或数组，并将集合中的元素应用于指定的 SQL 语句部分。这样可以方便地处理需要循环操作的查询场景，如根据多个条件查询、批量插入等。 使用trim语句 在 MyBatis 中，&lt;trim&gt; 元素是一种用于修剪生成的 SQL 语句中不需要的部分的标签。它可以用于在生成 SQL 语句时去除开头、结尾或中间的多余字符，从而更灵活地构建动态 SQL 语句。 下面是一个示例，展示如何在 MyBatis 中使用 &lt;trim&gt; 元素： &lt;select id=&quot;getUserList&quot; parameterType=&quot;com.example.UserSearchCriteria&quot; resultType=&quot;com.example.User&quot;&gt; SELECT * FROM users &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; &lt;if test=&quot;name != null&quot;&gt; AND name = #{name} &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; AND age = #{age} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; 在上述示例中，&lt;trim&gt; 元素用于修剪生成的 SQL 语句中的不需要的部分。prefix 属性指定了修剪后添加的前缀，prefixOverrides 属性指定了要移除的前缀。在 &lt;trim&gt; 元素内部，可以使用其他动态 SQL 标签（如 &lt;if&gt;、&lt;choose&gt; 等）来生成动态的 SQL 语句。 例如，如果传入了 name 和 age 参数，则生成的 SQL 语句将包含对应的查询条件，并且以 WHERE 关键字开头。 UserSearchCriteria criteria = new UserSearchCriteria(); criteria.setName(&quot;John&quot;); criteria.setAge(25); List&lt;User&gt; userList = userMapper.getUserList(criteria); 在上述示例中，根据传入的搜索条件对象 UserSearchCriteria 中的属性值，动态生成 SQL 语句。只有满足条件的 &lt;if&gt; 块中的语句会被包含在最终的 SQL 语句中。 通过使用 &lt;trim&gt; 元素，可以更精确地控制生成的 SQL 语句中的部分内容，去除不需要的前缀或修剪掉多余的字符。这样可以减少手动拼接字符串的复杂性，提高动态 SQL 的可读性和灵活性。 使用sql片段 在 MyBatis 中，可以使用 &lt;sql&gt; 元素定义 SQL 片段（SQL Fragment），并在需要的地方引用这些片段。SQL 片段可以用于重复使用一段 SQL 代码，提高代码的可维护性和重用性。 下面是一个示例，展示如何在 MyBatis 中使用 &lt;sql&gt; 元素： &lt;sql id=&quot;userColumns&quot;&gt; id, name, age, email &lt;/sql&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.example.User&quot;&gt; SELECT &lt;include refid=&quot;userColumns&quot;/&gt; FROM users &lt;/select&gt; 在上述示例中，&lt;sql&gt; 元素用于定义了一个名为 &quot;userColumns&quot; 的 SQL 片段，其中包含了用户表的列名。通过 &lt;include&gt; 元素引用了这个 SQL 片段，将其插入到了 &lt;select&gt; 语句中。 这样，可以在多个 SQL 语句中重复使用 userColumns 的定义，避免重复编写相同的列名。 List&lt;User&gt; userList = userMapper.getUserList(); 在上述示例中，查询语句中的 &lt;include&gt; 元素会被替换为 userColumns 定义的 SQL 片段，从而生成最终的 SQL 语句。 通过使用 &lt;sql&gt; 元素和 &lt;include&gt; 元素，可以方便地定义和引用 SQL 片段，提高 SQL 语句的可读性和重用性。这样可以简化 SQL 语句的编写，减少冗余代码，并增加代码的可维护性和可扩展性。 参数传递 在 MyBatis 中，参数传递是将数据传递给 SQL 语句的一种方式。MyBatis 支持多种参数传递方式，包括单个参数、多个参数、Map 类型参数以及使用注解等方式。 下面是几种常见的参数传递方式： 单个参数：可以直接将单个参数传递给 SQL 语句，例如： List&lt;User&gt; getUserList(String name); 在上述示例中，单个参数 name 会被传递给 SQL 语句，并在 SQL 语句中使用。 多个参数：可以使用 @Param 注解来标记多个参数，并在 SQL 语句中使用这些参数，例如： List&lt;User&gt; getUserList(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) int age); 在上述示例中，使用 @Param 注解标记了两个参数 name 和 age，并在 SQL 语句中使用它们。 Map 类型参数：可以将参数封装为一个 Map 对象，然后将 Map 对象传递给 SQL 语句，例如： List&lt;User&gt; getUserList(Map&lt;String, Object&gt; paramMap); 在上述示例中，参数被封装为一个 Map 对象 paramMap，其中键为参数名，值为参数值。在 SQL 语句中使用参数时，可以通过键来获取对应的值。 使用注解：可以使用 MyBatis 的注解方式来指定参数传递，例如 @Param 注解、@ParamMap 注解等。具体使用方式可参考 MyBatis 的注解文档。 在 SQL 语句中引用参数时，可以使用 ${} 或 #{} 语法来获取参数值。其中 ${} 使用的是直接替换的方式，而 #{} 使用的是预编译的方式，可以有效防止 SQL 注入攻击，并自动进行类型转换和特殊字符的处理。 小贴士 参数的命名在 SQL 语句中要与参数对象的属性或者注解中的名称一致，这样 MyBatis 才能正确地映射参数值。 结果集处理 在 MyBatis 中，结果集处理是指将数据库返回的查询结果映射到 Java 对象或其他数据结构的过程。MyBatis 提供了多种方式来处理结果集，包括自动映射、手动映射和使用结果集映射器。 下面是几种常见的结果集处理方式： 自动映射：MyBatis 提供了自动将查询结果集映射到 Java 对象的功能。它会根据查询结果集的列名与 Java 对象的属性名进行自动匹配，并将结果集中的数据赋值给对象的属性。要使用自动映射，可以在 SQL 映射文件（Mapper XML）中使用 resultType 属性指定结果对象的类型，或者使用注解方式指定结果对象的类型。 手动映射：如果查询结果集的列名与 Java 对象的属性名不完全匹配，或者需要进行复杂的映射操作，可以使用手动映射方式。手动映射需要在 SQL 映射文件中使用 &lt;resultMap&gt; 元素定义结果集的映射关系，将查询结果的列与映射器接口方法返回类型中的属性进行手动映射。 使用结果集映射器：MyBatis 还提供了结果集映射器（ResultMap）的功能，可以在 XML 配置文件中定义复杂的映射关系，包括一对一关联、一对多关联等。结果集映射器可以通过 &lt;resultMap&gt; 元素定义，然后在 SQL 映射文件中引用该结果集映射器，进行结果集的映射处理。 无论使用哪种方式进行结果集处理，都可以通过在 SQL 映射文件中编写相应的配置来指定映射关系，包括列名与属性名的映射、关联关系的映射等。具体的映射配置会根据查询的需求和结果的数据结构而有所不同。 通过 &lt;resultMap&gt; 元素来定义结果集的映射关系，将查询结果的列与映射器接口方法返回类型中的属性进行映射。同时，使用 &lt;result&gt; 元素定义列和属性的映射关系，以及 &lt;association&gt; 和 &lt;collection&gt; 元素处理一对一和一对多的关联关系。 以下是对处理结果集的详细讲解： &lt;resultMap&gt; 元素： &lt;resultMap&gt; 元素用于定义结果集的映射关系。 通过 id 属性指定 &lt;resultMap&gt; 的唯一标识符。 使用 type 属性指定映射器接口方法的返回类型。 通过 &lt;resultMap&gt; 的子元素 &lt;result&gt;、&lt;association&gt; 和 &lt;collection&gt; 来定义具体的映射关系。 &lt;result&gt; 元素： &lt;result&gt; 元素用于定义列和属性的映射关系。 使用 column 属性指定查询结果的列名。 使用 property 属性指定映射器接口方法返回类型中的属性名。 可以使用 javaType 属性指定属性的 Java 类型。 可以使用 jdbcType 属性指定列的 JDBC 类型。 &lt;association&gt; 元素： &lt;association&gt; 元素用于处理一对一的关联关系。 使用 property 属性指定映射器接口方法返回类型中的属性名。 使用 javaType 或 resultMap 属性指定关联对象的类型或关联对象的映射关系。 &lt;collection&gt; 元素： &lt;collection&gt; 元素用于处理一对多的关联关系。 使用 property 属性指定映射器接口方法返回类型中的属性名。 使用 ofType 或 resultMap 属性指定集合元素的类型或集合元素的映射关系。 下面是一个包含 &lt;resultMap&gt; 元素、&lt;result&gt; 元素、&lt;association&gt; 元素和 &lt;collection&gt; 元素的完整案例配置： &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.example.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt; &lt;result property=&quot;phone&quot; column=&quot;phone&quot; /&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot; /&gt; &lt;association property=&quot;role&quot; javaType=&quot;com.example.Role&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;role_id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;role_name&quot; /&gt; &lt;/association&gt; &lt;collection property=&quot;permissions&quot; ofType=&quot;com.example.Permission&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;permission_id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;permission_name&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; 在上述案例中，假设有一个 User 类，其中包含了用户的基本信息以及关联的角色和权限信息。使用 &lt;resultMap&gt; 元素定义了名为 userResultMap 的结果映射关系，类型为 com.example.User。接下来使用 &lt;id&gt; 元素和 &lt;result&gt; 元素将列和属性进行映射。其中 &lt;id&gt; 元素用于指定主键映射，&lt;result&gt; 元素用于指定其他列和属性的映射。 在 &lt;resultMap&gt; 中还使用了 &lt;association&gt; 元素和 &lt;collection&gt; 元素来处理一对一和一对多的关联关系。通过 &lt;association&gt; 元素，定义了 role 属性的关联关系，指定了 com.example.Role 类型，并使用 &lt;id&gt; 元素和 &lt;result&gt; 元素将角色的列和属性进行映射。同样地，通过 &lt;collection&gt; 元素，定义了 permissions 属性的关联关系，指定了 com.example.Permission 类型，并使用 &lt;id&gt; 元素和 &lt;result&gt; 元素将权限的列和属性进行映射。 注解开发 在 MyBatis 中，除了使用 XML 配置文件来编写 SQL 映射和配置，还可以使用注解开发的方式来简化开发过程。注解开发可以将 SQL 语句直接与 Java 接口或方法进行关联，使得代码更加紧凑和易于理解。 以下是注解开发的一般步骤： 创建实体类：创建一个 Java 类来表示数据库中的表，可以使用 @Entity 注解将其与数据库表进行映射。 创建 Mapper 接口：创建一个接口，其中定义了与数据库交互的方法。使用注解来标记接口中的方法与 SQL 语句的对应关系。可以使用 @Select、@Insert、@Update、@Delete 注解等，分别对应查询、插入、更新和删除操作。 配置 MyBatis：在 MyBatis 的配置文件（mybatis-config.xml）中，需要配置将注解进行扫描的相关设置。通过 &lt;mappers&gt; 元素和 &lt;package&gt; 元素指定要扫描的 Mapper 接口所在的包。 使用注解开发：在 Mapper 接口中，根据需要定义各种查询和操作的方法，并使用相应的注解来映射 SQL 语句。注解的参数可以直接传递 SQL 语句或者使用动态 SQL 的注解来构建动态 SQL。 下面是一个简单的注解开发的示例： @Entity public class User { private Long id; private String username; private String password; // getters and setters } public interface UserMapper { @Select(&quot;SELECT * FROM users WHERE id = #{id}&quot;) User getUserById(Long id); @Insert(&quot;INSERT INTO users (username, password) VALUES (#{username}, #{password})&quot;) void addUser(User user); @Update(&quot;UPDATE users SET password = #{password} WHERE id = #{id}&quot;) void updatePassword(@Param(&quot;id&quot;) Long id, @Param(&quot;password&quot;) String password); @Delete(&quot;DELETE FROM users WHERE id = #{id}&quot;) void deleteUser(Long id); } 在上述示例中，User 类使用 @Entity 注解与数据库表进行映射。UserMapper 接口定义了与用户相关的数据库操作方法，并使用了不同的注解来映射 SQL 语句。 小贴士 使用注解开发可以简化 XML 配置文件的编写，提高开发效率。但需要注意，注解开发也有一些限制，例如无法实现复杂的动态 SQL 和复用 SQL 片段等。因此，在实际开发中，可以根据具体的需求和项目规模选择合适的开发方式（注解开发、XML 配置或混合使用），以达到最佳的开发效果和可维护性。 高级特性 缓存 在 MyBatis 中，缓存是一种机制，用于提高数据库查询性能和减少数据库访问的次数。MyBatis 提供了多级缓存的支持，包括一级缓存和二级缓存。 一级缓存：一级缓存是 MyBatis 默认开启的缓存机制，它是基于线程的缓存，每个 SqlSession 都有自己的一级缓存。当执行相同的查询语句时，如果查询条件相同，MyBatis 会先从一级缓存中查找结果，如果找到则直接返回，减少了数据库访问的次数。一级缓存的作用范围是同一个 SqlSession，在同一个 SqlSession 中执行相同的查询语句会命中缓存。 二级缓存：二级缓存是基于 SqlSessionFactory 的缓存，它可以被多个 SqlSession 共享。当不同的 SqlSession 执行相同的查询语句时，如果查询条件相同且命中了二级缓存，MyBatis 会直接从二级缓存中获取结果，避免了数据库的访问。二级缓存的作用范围是同一个 namespace 下的查询语句，在不同的 SqlSession 之间可以共享缓存。 配置和使用缓存的步骤如下： 开启缓存：在 MyBatis 的配置文件（mybatis-config.xml）中，设置 &lt;setting&gt; 元素的 cacheEnabled 属性为 true，开启缓存。 配置缓存：对于需要开启二级缓存的 Mapper 接口，需要在对应的 Mapper XML 文件中添加 &lt;cache&gt; 元素进行配置。可以设置缓存的策略、过期时间等属性。 标记查询语句：对于希望使用缓存的查询语句，需要在对应的 Mapper XML 文件中设置 &lt;select&gt; 元素的 useCache 属性为 true。 通过合理配置和使用缓存，可以显著提高数据库查询性能，减少数据库访问的次数，特别是对于重复性的查询操作。但需要注意的是，在使用缓存时要注意缓存的更新策略和时机，避免数据不一致的问题。可以使用 flushCache=&quot;true&quot; 来手动刷新缓存，或者使用 @CacheEvict 注解来配置缓存的清除操作。 批处理 在 MyBatis 中，批处理（Batch Processing）是一种执行批量操作的机制，可以在一次数据库访问中执行多个 SQL 语句，从而提高数据库操作的效率。MyBatis 提供了批处理的支持，可以通过批量插入、批量更新或批量删除等方式来处理大量数据的操作。 使用批处理的步骤如下： 开启批处理：在 MyBatis 的配置文件（mybatis-config.xml）中，设置 &lt;setting&gt; 元素的 defaultExecutorType 属性为 BATCH，或者在对应的 Mapper 接口方法上使用 @Options 注解指定 executorType 属性为 ExecutorType.BATCH，以开启批处理。 编写批处理操作：在 Mapper 接口中定义批处理的方法，可以是插入、更新或删除等操作。方法的参数可以是单个对象或对象列表。 执行批处理：通过 SqlSession 的 insert、update、delete 方法执行批处理操作。可以传入对象列表或使用可迭代对象进行批量操作。 下面是一个批量插入的示例： void insertUsers(List&lt;User&gt; userList); 在 Mapper 接口中定义了一个 insertUsers 方法，接收一个 User 对象列表作为参数。 使用批处理时，需要注意以下几点： 数据库支持：批处理的可用性取决于所使用的数据库驱动程序和数据库本身。不是所有的数据库和数据库驱动程序都支持批处理操作，需要确保所使用的数据库和驱动程序支持批处理。 批处理大小：可以通过设置 jdbc.batch.size 属性来指定批处理的大小，默认值为 100。可以根据具体的场景和性能需求来调整批处理大小。 批处理提交：MyBatis 会根据批处理大小自动提交一部分操作，但需要注意在适当的时机进行提交，以避免内存溢出或长时间事务的问题。可以在方法执行完毕后手动提交事务。 通过合理使用批处理，可以有效减少数据库访问的次数，提高数据操作的效率。但需要根据具体的业务需求和数据规模来决定是否使用批处理，并进行适当的调整和优化。 插件 在 MyBatis 中，插件（Plugins）是一种可扩展的机制，可以在执行 SQL 语句的过程中进行拦截和增强操作。通过自定义插件，可以在 SQL 执行的各个阶段进行自定义处理，例如日志记录、性能监控、数据加解密等。 使用插件的步骤如下： 编写插件类：创建一个实现了 Interceptor 接口的插件类，该接口定义了插件的拦截方法。插件类需要实现 intercept 方法，在该方法中编写自定义的处理逻辑。 定义插件拦截的目标：通过 @Intercepts 注解或者实现 Interceptor 接口时传入的 @Signature 注解，指定插件要拦截的目标方法和参数类型。可以拦截的目标包括 Executor、StatementHandler、ParameterHandler 和 ResultSetHandler 等。 配置插件：在 MyBatis 的配置文件（mybatis-config.xml）中，使用 &lt;plugins&gt; 元素进行插件的配置。将插件类添加到 &lt;plugins&gt; 元素中，并指定插件的相关配置属性。 应用插件：在使用 MyBatis 的 Mapper 接口方法时，插件会自动拦截目标方法，并执行插件中定义的处理逻辑。 下面是一个简单的插件示例： @Intercepts({ @Signature(type = Executor.class, method = &quot;update&quot;, args = {MappedStatement.class, Object.class}) }) public class MyPlugin implements Interceptor { // 实现 intercept 方法，在方法中编写自定义的处理逻辑 @Override public Object intercept(Invocation invocation) throws Throwable { // 拦截目标方法的处理逻辑 // ... return invocation.proceed(); // 继续执行目标方法 } // 实现 plugin 方法，返回被拦截的对象的代理对象 @Override public Object plugin(Object target) { return Plugin.wrap(target, this); } // 实现 setProperties 方法，可以通过配置属性初始化插件 @Override public void setProperties(Properties properties) { // 初始化插件的相关配置 } } 在上述示例中，MyPlugin 类实现了 Interceptor 接口，并通过 @Intercepts 注解指定了要拦截的目标方法。在 intercept 方法中编写了自定义的处理逻辑，然后使用 Plugin.wrap 方法创建被拦截对象的代理对象。最后，可以在 MyBatis 的配置文件中配置该插件。 通过自定义插件，可以对 MyBatis 的 SQL 执行过程进行拦截和增强，实现各种自定义的功能和处理逻辑。插件可以应用于日志记录、权限验证、性能监控等场景，提供了灵活的扩展机制。但需要注意插件的使用要遵循一定的原则和规范，确保插件的正确性和稳定性。 ","tags":[{"index":-1,"name":"MyBatis","slug":"tag-MyBatis","used":true,"link":"https://riftrays.github.io/tag-MyBatis/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"MyBatis","feature":"","link":"https://riftrays.github.io/GSuNvEiVe/","stats":{"text":"50 min read","time":2946000,"words":12234,"minutes":50},"date":"2020-01-02 19:40:54","dateFormat":"2020-01-02 19:40:54"},{"abstract":"","content":"概述 Maven是一个流行的Java项目管理工具，它提供了一种规范化的方式来构建、管理和发布Java项目。 下面是一些与Maven相关的概念： 项目对象模型（Project Object Model，POM）：POM是Maven项目的核心文件，它以XML格式描述了项目的元数据、依赖关系、构建配置和插件等信息。POM定义了项目的结构、构建过程和目标。 坐标（Coordinates）：在Maven中，每个项目都有一个唯一的坐标，用于标识项目的组织、唯一ID和版本号。坐标通常由groupId（组织ID）、artifactId（项目ID）和version（版本号）组成。 依赖（Dependencies）：Maven使用依赖管理来管理项目所需的外部库或模块。通过在POM中声明依赖，Maven可以自动下载并管理这些依赖，确保项目能够正确构建和运行。 仓库（Repository）：Maven使用仓库来存储项目的依赖库和构建产物。有两种类型的仓库：本地仓库（Local Repository）用于存储本地计算机上的依赖，远程仓库（Remote Repository）用于从互联网上下载依赖。 生命周期（Lifecycle）：Maven定义了一系列的生命周期，包括clean、validate、compile、test、package、install和deploy等。每个生命周期由一系列的阶段（Phase）组成，而每个阶段由一系列的目标（Goal）构成。 插件（Plugins）：Maven插件是用来扩展和定制构建过程的工具。插件提供了各种目标，可以用来执行特定的任务，例如编译代码、运行测试、生成文档等。Maven本身提供了一些常用的插件，同时也支持自定义插件。 作用 项目构建：Maven提供了一种统一的项目结构和构建方式，使得项目的构建过程更加规范和易于管理。通过定义项目的POM文件，Maven可以自动化执行项目构建所需的步骤，例如编译源代码、运行单元测试、生成文档、打包项目等。 依赖管理：Maven能够自动下载、安装和管理项目所需的外部依赖库。通过在POM文件中声明依赖，Maven可以自动解析和下载依赖，并确保项目构建时所需的依赖库可用。这简化了依赖管理的过程，减少了手动管理依赖的工作量。 项目文档生成：Maven支持通过插件生成项目文档，例如使用Maven Site插件可以生成项目的网站文档，包括项目介绍、开发者文档、API文档等。这有助于提供项目的详细文档和说明，方便团队成员和其他开发者了解和使用项目。 项目报告和统计：Maven能够生成各种报告和统计信息，帮助开发团队了解项目的状态和质量。例如，可以生成代码覆盖率报告、静态代码分析报告、测试结果报告等。这些报告和统计信息有助于发现潜在问题、优化代码质量以及改进项目的开发流程。 项目部署和发布：Maven支持将项目构建产物（如JAR文件、WAR文件）部署到远程仓库或发布到中央仓库。这样其他开发者可以方便地访问和使用你的项目构建产物，提高代码的可重用性和共享性。 总的来说，Maven提供了一种标准化和自动化的方式来管理Java项目的构建、依赖、文档和部署等方面。它简化了项目的管理和维护工作，提高了开发效率，并促进了团队合作和代码质量的提升。 安装配置 下载Maven： 访问Maven官方网站（https://maven.apache.org/），找到最新版本的Maven进行下载。 下载完成后，解压缩Maven压缩包到你选择的目录。 配置环境变量： 在操作系统中配置Maven的环境变量，以便在命令行中能够直接运行Maven命令。 在Windows系统中，右键点击&quot;我的电脑&quot;，选择&quot;属性&quot;，进入&quot;高级系统设置&quot;，点击&quot;环境变量&quot;。 在系统变量中，找到&quot;Path&quot;变量，点击&quot;编辑&quot;，添加Maven的bin目录路径（例如：C:\\apache-maven-3.8.4\\bin）。 在Unix/Linux系统中，编辑~/.bashrc或~/.bash_profile文件，添加以下行：export PATH=/path/to/maven/bin:$PATH 验证Maven安装： 打开命令行终端（Windows下是CMD或PowerShell，Unix/Linux下是Terminal）。 运行以下命令验证Maven是否正确安装：mvn -version 如果能够显示Maven的版本信息，则表示安装成功。 配置Maven的设置（可选）： Maven的配置文件是settings.xml，位于Maven的安装目录下的conf文件夹中。 可以编辑settings.xml文件来配置Maven的行为，例如设置本地仓库路径、代理服务器、镜像等。 如果没有特殊需求，可以使用默认的settings.xml文件，不进行修改。 配置阿里巴巴的仓库： 在&lt;mirrors&gt;标签下添加如下配置：&lt;mirror&gt; &lt;id&gt;alibaba&lt;/id&gt; &lt;name&gt;Alibaba Maven Repository&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 这个配置将创建一个名为&quot;alibaba&quot;的镜像，将中央仓库（central）指向阿里巴巴的公共仓库。 配置.m2路径： 默认情况下，Maven将在用户主目录下的.m2文件夹中保存本地仓库。 如果你想将本地仓库保存在不同的位置，可以在&lt;settings&gt;标签下添加如下配置：&lt;localRepository&gt;/path/to/custom/.m2/repository&lt;/localRepository&gt; 将/path/to/custom替换为你希望存储.m2文件夹的路径。 配置全球中央仓库： 在&lt;mirrors&gt;标签下添加如下配置： &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 这个配置将创建一个名为&quot;central&quot;的镜像，将中央仓库（central）指向全球Maven中央仓库。 基本用法 创建一个Maven项目和POM文件： 首先，确保你已经安装了Maven。然后，在命令行中进入你希望创建项目的目录。 运行以下命令创建一个新的Maven项目：mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false 这将创建一个基本的Maven项目结构，并生成一个默认的POM文件。 配置项目的坐标、依赖和插件： 打开生成的POM文件（位于项目根目录下），在其中配置项目的坐标信息。 &lt;groupId&gt;表示项目的组织ID，&lt;artifactId&gt;表示项目的唯一ID，&lt;version&gt;表示项目的版本号。你可以根据需要进行修改。 在POM文件的&lt;dependencies&gt;部分添加项目所需的依赖库。每个依赖都使用&lt;dependency&gt;标签进行声明，指定依赖的坐标信息。 如果需要使用插件来扩展构建过程，可以在POM文件的&lt;build&gt;部分配置插件。每个插件使用&lt;plugin&gt;标签进行声明，指定插件的坐标和配置信息。 通过Maven进行项目构建、编译、测试和打包： 在项目根目录下运行以下命令进行项目构建：mvn clean package clean命令清理之前构建的结果，package命令编译项目源代码、运行测试并打包项目。你可以根据需要使用其他命令，如compile、test等。 Maven将执行构建过程，并在目标文件夹（默认为target）中生成构建产物，如编译后的类文件、JAR文件等。 管理项目的依赖关系： 在POM文件的&lt;dependencies&gt;部分添加项目所需的依赖库。每个依赖使用&lt;dependency&gt;标签进行声明。 指定依赖的坐标信息，包括groupId、artifactId和version等。Maven将根据这些信息自动下载和管理依赖。 可以使用&lt;scope&gt;标签指定依赖的作用范围，如compile（默认值）、test、runtime等。 可以使用&lt;exclusions&gt;标签排除依赖的传递性依赖关系，以避免冲突或不需要的依赖。 使用Maven插件扩展构建过程： 在POM文件的&lt;build&gt;部分配置插件。每个插件使用&lt;plugin&gt;标签进行声明。 指定插件的坐标和配置信息，如groupId、artifactId和version等。 有些插件有默认配置，你可以根据需要进行修改。可以查阅插件的文档了解可用的配置选项。 插件可以用于各种任务，例如静态代码分析、代码生成、测试报告生成等。你可以根据项目需求选择适合的插件并配置相应的目标和参数。 这些步骤将帮助你掌握Maven的基本用法和功能，以便进行项目的构建、依赖管理和插件扩展等操作。记住，随着实际项目的练习和深入学习，你将更加熟悉和灵活运用这些概念和技术。 Maven常用命令 mvn clean: 清除项目构建目录，删除生成的目标文件。 mvn compile: 编译项目源代码。 mvn package: 打包项目，生成JAR或WAR文件。 mvn install: 将项目构建结果安装到本地Maven仓库，供其他项目使用。 mvn test: 运行项目的单元测试。 mvn clean install: 清除构建目录并重新构建项目，安装到本地仓库。 生命周期与插件 Maven有三个内置的生命周期：clean、default和site。 每个生命周期由一系列的阶段（phase）组成，每个阶段都代表了构建过程中的一个步骤。例如，default生命周期包含了compile、test、package等阶段。 Maven插件可以扩展和定制Maven的功能。例如，maven-compiler-plugin用于编译Java代码，maven-surefire-plugin用于执行测试。 依赖范围 在Maven中，依赖范围（Dependency Scope）用于定义依赖项在编译、测试、运行和打包等不同阶段的可见性和有效性。以下是几个常用的依赖范围： compile（编译依赖）： 默认的依赖范围，用于编译、测试和运行阶段。 编译依赖在编译、测试和运行时均可见。 provided（已提供依赖）： 适用于在编译和测试阶段需要依赖，但在运行时由目标环境（如应用服务器）提供。 在编译和测试时可见，但在打包和运行时不包含在项目中。 runtime（运行时依赖）： 在运行和测试阶段需要依赖，但在编译时不需要。 运行时依赖在运行和测试时可见，但在编译时不包含在项目中。 test（测试依赖）： 仅在测试阶段使用的依赖，不会在编译、运行和打包阶段使用。 测试依赖仅在测试时可见，不会包含在项目的编译和打包结果中。 system（系统依赖）： 指定项目中的依赖来自于系统路径，而不是通过仓库中的坐标来解析。 需要显式指定依赖的路径，使用&lt;systemPath&gt;元素来定义。 下面是一份比较不同依赖范围的表格： 依赖范围 用途 编译阶段 测试阶段 运行阶段 打包阶段 compile 编译、测试和运行时可见 ✔️ ✔️ ✔️ ✔️ provided 在编译和测试阶段需要依赖，但在运行时由目标环境提供 ✔️ ✔️ ❌ ❌ runtime 运行和测试时需要依赖，但在编译时不需要 ❌ ✔️ ✔️ ✔️ test 仅在测试阶段使用的依赖，不会在编译、运行和打包阶段使用 ❌ ✔️ ❌ ❌ system 依赖来自于系统路径，需要显式指定依赖的路径 ✔️ ✔️ ✔️ ✔️ import 用于管理依赖的版本传递性，但本身不会参与构建和运行 ❌ ❌ ❌ ❌ test-compile 仅在测试编译阶段使用的依赖，不会在测试运行和生产环境使用 ✔️ ✔️ ❌ ❌ test-runtime 仅在测试运行阶段使用的依赖，不会在测试编译和生产环境使用 ❌ ✔️ ✔️ ✔️ system-test 仅在测试阶段使用的系统依赖，不会在编译、运行和打包阶段使用 ✔️ ✔️ ✔️ ✔️ provided-test 在编译和测试阶段需要依赖，但在运行时由目标环境提供的测试依赖 ✔️ ✔️ ❌ ❌ 注意：✔️ 表示依赖在该阶段可见和有效，❌ 表示依赖在该阶段不可见或无效。 在&lt;dependencies&gt;标签中，可以为每个依赖项指定所需的依赖范围。例如： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;my-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 高阶用法 使用Maven的生命周期、阶段和目标管理构建过程： Maven定义了一套标准的生命周期，包括clean、validate、compile、test、package、install和deploy等。 生命周期由一系列阶段组成，每个阶段由一个或多个目标构成。例如，compile阶段包含了编译源代码的目标。 通过在命令行中指定生命周期、阶段或目标，你可以按顺序执行构建过程中的特定步骤。 例如，运行以下命令执行clean生命周期的install阶段：mvn clean install 配置Maven插件以满足项目需求： Maven提供了许多内置插件，可以满足常见的构建和开发需求。你可以在POM文件中配置这些插件并指定相关的目标和参数。 你还可以使用自定义插件来满足特定的项目需求。自定义插件需要在POM文件中声明，并提供插件的实现和配置信息。 使用Maven的属性、配置文件和环境变量进行灵活的配置： Maven支持使用属性（Properties）来灵活配置项目。属性可以在POM文件中定义，也可以从外部配置文件中加载。 你可以在POM文件中使用${property}的形式引用属性值，也可以通过命令行参数或环境变量来覆盖属性值。 Maven还支持使用配置文件来配置插件和构建过程。你可以在POM文件中引用配置文件，并在配置文件中设置插件的参数。 使用Maven的多模块项目管理复杂的项目结构： Maven支持创建多模块项目，其中一个父项目管理多个子项目。父项目和子项目分别有自己的POM文件。 父项目的POM文件可以定义模块（modules）列表，列出所有子项目的相对路径。 每个子项目都有自己独立的POM文件，可以定义自己的依赖、插件和构建配置。子项目可以独立构建，也可以作为整个多模块项目的一部分构建。 实际应用 Maven广泛应用于Java项目的构建和依赖管理，可以帮助你更高效地管理项目结构和依赖项。 它可以自动下载所需的依赖库，并支持项目的编译、测试和打包等常见操作。 Maven还可以与持续集成工具（如Jenkins）集成，实现自动化构建和部署。 示范 在src/main/java目录下创建一个Java源代码文件，例如HelloWorld.java： public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello, Maven!&quot;); } } 在根目录下的pom.xml中添加依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 使用Maven编译和运行项目： mvn compile mvn exec:java -Dexec.mainClass=&quot;HelloWorld&quot; 以上示例展示了Maven的基本用法和项目配置。您可以根据实际需求在pom.xml中添加更多依赖和插件。 ","tags":[{"index":3,"name":"Maven","slug":"tag-Maven","used":true,"link":"https://riftrays.github.io/tag-Maven/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Maven","feature":"","link":"https://riftrays.github.io/maven/","stats":{"text":"16 min read","time":914000,"words":4073,"minutes":16},"date":"2020-01-01 16:45:09","dateFormat":"2020-01-01 16:45:09"},{"abstract":"","content":"Git 什么是Git Git 是一个分布式版本控制系统，用于跟踪代码的变化，协同开发，以及管理项目。它是由 Linus Torvalds 在2005年创建的，最初用于管理 Linux 内核的开发。 为什么需要 Git？ 在软件开发过程中，团队成员通常需要协同工作，修改和共享代码。这可能会导致版本混乱和代码冲突。Git 的出现解决了这些问题，它允许开发人员跟踪每次代码的变化，轻松地协同工作，并在需要时回溯到特定版本。 程序员小明负责的模块就要完成了，就在即将提交发布之前的一瞬间，电脑突然蓝屏，硬盘光荣下岗！ 几个月来的努力付之东流 老王需要在项目中加入一个很复杂的功能，一边尝试，一边修改代码，就这样摸索了一个星期。 可是这被改得面目全非的代码已经回不到从前了。 小明和老王先后从文件服务器上下载了同一个文件 因项目中Bug过多，导致项目进度拖延，项目经理老徐因此被骂，但不清楚Bug是手下哪一个程序员写的 开发中要解决的问题 代码备份 版本控制 协同工作 责任追溯 下载和安装 下载 官网下载地址：https://git-scm.com/downloads 安装 双击安装包，进入安装向导界面 指定安装目录 一路next下一步 等待安装 安装完成 安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。 运行Git命令客户端，使用git --version 命令，可以查看git版本 基本概念 仓库（Repository）： Git 仓库是存储代码的地方，它包含了项目的所有文件和历史记录。 提交（Commit）： 提交是一次代码变更的快照，它包含了代码的实际修改和一个相关的说明。 分支（Branch）： 分支是代码的不同版本，每个分支都可以独立地进行开发和修改。 合并（Merge）： 合并是将不同分支的代码合并为一个新的版本。 远程仓库（Remote Repository）： 远程仓库是存储在网络上的仓库，团队成员可以共享和协同工作。 工作流程 克隆（Clone）： 开发人员从远程仓库中复制项目到本地，创建一个本地仓库。 添加（Add）： 开发人员将修改后的文件添加到暂存区，准备提交。 提交（Commit）： 开发人员将暂存区中的文件提交到本地仓库，生成一个新的提交记录。 推送（Push）： 开发人员将本地仓库的提交推送到远程仓库，使团队成员可以访问这些更改。 拉取（Pull）： 开发人员从远程仓库中获取最新的代码变更，将其合并到本地仓库。 合并（Merge）： 开发人员将不同分支的代码合并为一个版本，解决可能出现的代码冲突。 基础操作 让我们通过一个简单的示例来理解 Git 的操作。假设我们要创建一个简单的 Python 脚本并使用 Git 来进行版本控制。 初始化仓库： # 在命令行中执行以下命令 git init 添加和提交代码： 创建一个名为 hello.py 的文件，包含以下内容： print(&quot;Hello, Git!&quot;) 然后执行以下命令： git add hello.py git commit -m &quot;Add hello.py&quot; 创建分支和合并： # 创建一个新分支 git branch feature # 切换到新分支 git checkout feature # 在 feature 分支中修改 hello.py，将内容修改为： # print(&quot;Hello, Feature Branch!&quot;) # 添加和提交修改 git add hello.py git commit -m &quot;Modify hello.py in feature branch&quot; # 切换回主分支 git checkout master # 合并 feature 分支到主分支 git merge feature Git能干什么？ Git 是一个强大的版本控制系统，用于管理和跟踪代码的变化。 版本控制 Git 主要用于版本控制，它可以帮助你跟踪代码的每一个变化，包括新增、修改和删除文件。这使得你可以轻松地回溯到以前的版本。 # 创建一个新的 Git 仓库 git init # 添加文件到仓库 git add filename # 提交文件到仓库并添加提交消息 git commit -m &quot;Initial commit&quot; 多人协作 Git 允许多个开发人员同时在一个项目上工作，他们可以在本地修改代码，然后将更改推送到共享的远程仓库。 # 从远程仓库克隆项目 git clone remote_repository_url # 拉取最新的代码变更 git pull # 推送本地更改到远程仓库 git push 分支管理 Git 允许你创建和管理分支，这是独立的代码开发线。你可以在分支上进行实验、添加新功能，然后将它们合并回主分支。 # 创建一个新分支 git branch new_branch # 切换到新分支 git checkout new_branch # 合并分支到主分支 git merge new_branch 解决代码冲突 当多个开发人员修改相同文件的相同部分时，可能会发生代码冲突。Git 提供了工具来解决这些冲突。 # 检查文件中的冲突 git status # 手动编辑文件以解决冲突 # 添加解决后的文件 git add conflicted_file # 提交解决冲突的更改 git commit -m &quot;Resolve conflict&quot; 查看历史记录 可以查看项目的完整历史记录，包括每个提交的详细信息。 # 查看提交历史 git log # 查看特定文件的历史记录 git log filename 撤销更改 如果你错误地进行了一些更改，Git 允许你撤销它们，回到之前的状态。 # 撤销对文件的更改 git checkout filename # 撤销对提交的更改 git reset commit_hash 标签和发布 你可以创建标签来标记项目的重要状态，例如版本发布。 # 创建一个标签 git tag v1.0 # 推送标签到远程仓库 git push --tags Git仓库 仓库简介 Git 仓库可以分为两种主要类型： 本地仓库（Local Repository）和远程仓库（Remote Repository）。 本地仓库（Local Repository） 本地仓库是存储在你的计算机上的 Git 仓库，用于管理和跟踪项目的代码变化。它允许你在本地进行代码的修改、提交和版本控制。你可以通过以下步骤创建和管理本地仓库： 步骤 1：初始化本地仓库 # 在命令行中进入项目目录 cd project_directory # 初始化本地仓库 git init 步骤 2：添加和提交代码变更 # 添加文件到暂存区 git add filename # 提交文件到本地仓库 git commit -m &quot;Commit message&quot; 远程仓库（Remote Repository） 远程仓库是存储在网络上的 Git 仓库，通常用于多人协作和备份代码。它允许团队成员共享代码、跟踪项目状态，并协同工作。以下是一些关于远程仓库的重要信息： 步骤 1：克隆远程仓库到本地 # 克隆远程仓库到本地 git clone remote_repository_url 步骤 2：推送本地更改到远程仓库 # 推送本地提交到远程仓库 git push origin master 步骤 3：拉取远程仓库的更改到本地 # 拉取远程仓库的最新更改 git pull origin master 通过本地仓库和远程仓库的结合使用，你可以在本地进行开发和测试，然后将更改推送到共享的远程仓库，以便与团队成员共享。这有助于确保代码的稳定性和一致性。 以下是一个示例场景，演示了本地仓库和远程仓库之间的交互： 初始化本地仓库 # 在命令行中进入项目目录 cd project_directory # 初始化本地仓库 git init 添加和提交代码变更到本地仓库 # 创建一个新文件 hello.py echo &quot;print('Hello, Git!')&quot; &gt; hello.py # 添加文件到暂存区 git add hello.py # 提交文件到本地仓库 git commit -m &quot;Add hello.py&quot; 关联远程仓库 # 关联本地仓库与远程仓库 git remote add origin remote_repository_url 推送代码到远程仓库 # 推送本地代码到远程仓库的 master 分支 git push origin master 从远程仓库拉取更改 # 拉取远程仓库的最新更改到本地 git pull origin master 通过这些步骤，你可以将本地仓库与远程仓库连接起来，实现代码的共享和协作。无论你是独自开发还是与团队协作，这种仓库结构都能有效地管理和跟踪你的代码变化。 工作区、暂缓区、版本库 工作区（Working Directory） 工作区是你正在工作的目录，其中包含了你项目的实际文件。这是你创建、编辑和删除文件的地方。工作区的内容可以包括源代码、文本文件、图像等所有项目文件。 暂存区（Staging Area 或 Index） 暂存区是位于本地仓库内部的一个临时区域，它用来存储将要提交到版本库的更改。在这个区域中，你可以选择性地添加和管理哪些更改将包含在下一次提交中。暂存区允许你将工作区中的更改分成逻辑单元，并为它们创建清晰的提交。 版本库（Repository） 版本库是 Git 的核心部分，它存储着项目的完整历史记录，包括所有的提交、分支、标签等信息。版本库通常分为两个部分： 本地仓库（Local Repository）： 位于你的计算机上，包含完整的项目历史和文件快照。你可以在本地仓库中执行各种操作，如查看历史记录、创建分支、合并更改等。 远程仓库（Remote Repository）： 位于网络上的服务器或托管服务（如GitHub、GitLab、Bitbucket等），允许多个开发人员协同工作并共享代码。远程仓库是团队成员之间同步代码的中心存储库。 工作流程 1. 创建一个新的 Git 仓库并添加文件到工作区： # 初始化新的 Git 仓库 git init # 创建一个新文件并将其添加到工作区 echo &quot;Hello, Git!&quot; &gt; hello.txt 2. 将文件从工作区添加到暂存区： # 将 hello.txt 文件添加到暂存区 git add hello.txt 3. 提交更改到版本库： # 提交暂存区中的更改到版本库 git commit -m &quot;Add hello.txt to the repository&quot; 现在，hello.txt 文件已经从工作区添加到了版本库中。工作区中的更改首先被暂存（通过 git add），然后提交到版本库（通过 git commit）。 4. 查看版本库的状态： # 查看版本库的提交历史 git log # 查看工作区、暂存区和版本库的状态 git status 这些命令可以让你了解工作区、暂存区和版本库之间的状态以及提交历史。 5. 修改文件并重新提交： # 修改 hello.txt 文件 echo &quot;Hello, Git! This is a modification.&quot; &gt; hello.txt # 再次将文件添加到暂存区 git add hello.txt # 重新提交更改 git commit -m &quot;Modify hello.txt&quot; 工作区中文件的状态 在 Git 中，工作区中的文件可以处于以下几种状态之一： 未跟踪（Untracked）： 这是文件的初始状态，表示 Git 不跟踪该文件的更改。这些文件不会包括在版本控制中。要将文件从未跟踪状态添加到 Git 中，需要使用 git add 命令。 已修改（Modified）： 这表示文件在工作区中已经发生了更改，但尚未被添加到暂存区。要将已修改的文件添加到暂存区，需要使用 git add 命令。 已暂存（Staged）： 这表示文件已经被添加到了暂存区，准备好被提交到本地仓库。使用 git commit 命令可以将已暂存的文件提交到本地仓库。 已提交（Committed）： 这表示文件的更改已经被成功提交到本地仓库。这些文件的状态是最新的，可以在提交历史中找到。提交是永久性的，除非你进行新的提交，否则它们不会改变。 已忽略（Ignored）： 这表示文件已被添加到 .gitignore 文件中，因此 Git 将忽略对这些文件的任何更改。通常，生成的临时文件、编译输出和敏感信息等文件应该被添加到 .gitignore 中。 你可以使用以下命令来查看工作区文件的状态： git status：这个命令将显示工作区中所有文件的状态，包括未跟踪、已修改和已暂存的文件。 在使用 Git 进行版本控制时，了解和管理工作区文件的状态非常重要，以确保正确地跟踪、提交和忽略文件。 Git 常用命令 命令 描述 示例 git init 初始化仓库 git init git clone 克隆仓库 git clone &lt;repository_url&gt; git add 添加文件到暂存区 git add &lt;file_name&gt; git commit 提交更改 git commit -m &quot;Commit message&quot; git log 查看提交历史 git log git diff 查看文件更改 git diff git pull 拉取远程更改 git pull origin &lt;branch_name&gt; git push 推送更改到远程仓库 git push origin &lt;branch_name&gt; git branch 创建分支 git branch &lt;branch_name&gt; git checkout 切换分支 git checkout &lt;branch_name&gt; git merge 合并分支 git merge &lt;branch_name&gt; git remote 查看远程仓库 git remote -v git checkout -b 克隆远程分支并创建本地分支 git checkout -b &lt;new_branch_name&gt; origin/&lt;remote_branch_name&gt; .gitignore 文件 忽略文件 创建 .gitignore 文件并添加要忽略的文件/目录 1. 初始化仓库（git init）： 这个命令用于将当前目录转换为一个 Git 仓库，从而开始跟踪项目文件。 # 初始化一个新的 Git 仓库 git init 2. 克隆仓库（git clone）： 用于从远程仓库克隆一个副本到本地计算机。 # 从远程仓库克隆一个项目 git clone &lt;repository_url&gt; 3. 添加文件到暂存区（git add）： 将工作区中的更改添加到暂存区，准备进行提交。 # 添加一个文件到暂存区 git add &lt;file_name&gt; 4. 提交更改（git commit）： 将暂存区中的更改提交到本地仓库，并附上一条提交消息。 # 提交暂存区中的更改到本地仓库 git commit -m &quot;Commit message&quot; 5. 查看提交历史（git log）： 查看项目的提交历史记录，包括提交者、日期和提交消息。 # 查看提交历史 git log 6. 查看文件更改（git diff）： 查看工作区和暂存区之间的文件更改。 # 查看文件更改 git diff 7. 拉取远程更改（git pull）： 从远程仓库获取最新更改并合并到当前分支。 # 拉取远程仓库的最新更改 git pull origin &lt;branch_name&gt; 8. 推送更改到远程仓库（git push）： 将本地分支的更改推送到远程仓库。 # 推送本地分支的更改到远程仓库 git push origin &lt;branch_name&gt; 9. 创建分支（git branch）： 创建一个新的分支，用于开发新功能或修复 bug。 # 创建一个新的分支 git branch &lt;branch_name&gt; 10. 切换分支（git checkout）： 切换到不同的分支。 # 切换到另一个分支 git checkout &lt;branch_name&gt; 11. 合并分支（git merge）： 将一个分支的更改合并到当前分支。 # 合并分支 git merge &lt;branch_name&gt; 12. 查看远程仓库（git remote）： 查看当前项目关联的远程仓库。 # 查看远程仓库 git remote -v 13. 克隆远程分支（git checkout -b）： 创建并切换到一个新分支，同时从远程仓库克隆分支。 # 创建并切换到新分支，同时克隆远程分支 git checkout -b &lt;new_branch_name&gt; origin/&lt;remote_branch_name&gt; 14. 忽略文件（.gitignore）： 创建一个名为 .gitignore 的文件，用于指定不应跟踪的文件和目录。 # 创建 .gitignore 文件，并添加要忽略的文件/目录 touch .gitignore 本地仓库 命令 描述 git init 初始化一个新的 Git 仓库。 git clone &lt;仓库URL&gt; 克隆远程仓库到本地。 git add &lt;文件名&gt; 将文件添加到暂存区。 git commit -m &quot;提交信息&quot; 提交暂存区的更改到本地仓库，并附带一条描述性的提交信息。 git status 查看工作区和暂存区的文件状态。 git log 查看提交历史。 git diff 查看当前工作区中文件的更改。 git branch 查看本地分支列表。 git checkout &lt;分支名&gt; 切换到指定分支。 git merge &lt;分支名&gt; 将指定分支的更改合并到当前分支。 git reset &lt;文件名&gt; 从暂存区中移除文件，但保留在工作区中的更改。 git rm &lt;文件名&gt; 从 Git 中删除文件，并将这个删除操作添加到暂存区。 远程仓库 命令 描述 git remote add &lt;远程仓库名称&gt; &lt;远程仓库URL&gt; 将远程仓库添加到本地仓库的配置中。 git remote -v 查看当前本地仓库配置的所有远程仓库及其URL。 git clone &lt;远程仓库URL&gt; 克隆远程仓库到本地。 git pull &lt;远程仓库名称&gt; &lt;分支名&gt; 从远程仓库拉取最新的更改并合并到当前分支。 git push &lt;远程仓库名称&gt; &lt;本地分支&gt;:&lt;远程分支&gt; 推送本地分支的更改到远程仓库的指定分支。 git fetch &lt;远程仓库名称&gt; 拉取远程仓库的最新更改，但不自动合并。 git remote rename &lt;旧远程仓库名称&gt; &lt;新远程仓库名称&gt; 重命名已配置的远程仓库的名称。 git remote remove &lt;远程仓库名称&gt; 从本地仓库配置中移除指定的远程仓库。 git remote set-url &lt;远程仓库名称&gt; &lt;新的远程仓库URL&gt; 更改已配置的远程仓库的URL。 git remote show &lt;远程仓库名称&gt; 查看有关指定远程仓库的更多详细信息，包括分支跟踪情况等。 补充 --allow-unrelated-histories 是 Git 命令中的一个选项，通常用于合并两个不相关的代码历史。在某些情况下，当你尝试合并两个不同的 Git 仓库或两个没有共同历史的分支时，Git 会拒绝合并操作。这时，你可以使用 --allow-unrelated-histories 选项来告诉 Git 允许合并不相关的历史。 1. 用法： 要在 Git 合并操作中使用 --allow-unrelated-histories 选项，可以在执行 git pull 或 git merge 命令时添加这个选项，如下所示： git pull origin main --allow-unrelated-histories 或者 git merge other-branch --allow-unrelated-histories 2. 场景： 合并两个不同的 Git 仓库： 一种常见的情况是，你有两个不同的 Git 仓库，它们可能是从不同的源克隆而来，或者是两个独立的项目。如果你想将它们合并到一个新的仓库中，你可能需要使用 --allow-unrelated-histories。 合并两个没有共同历史的分支： 另一个场景是，你有一个项目的两个分支，它们没有共同的提交历史，但你希望将它们合并到一个分支中。这时，也需要使用 --allow-unrelated-histories。 3. 注意事项和最佳实践： 慎重使用： 这个选项应该谨慎使用，因为它允许合并没有共同历史的代码。确保你真的需要将这些不相关的历史合并在一起，而不是创建一个新的分支或仓库来管理它们。 解决冲突： 合并没有共同历史的代码可能会导致冲突。你需要准备好解决可能出现的冲突，这可能需要手动编辑文件以解决冲突。 审查合并前的更改： 在执行合并操作之前，建议先仔细审查将要合并的更改，以确保不会引入不必要的问题。 文档记录： 如果使用了 --allow-unrelated-histories，建议在合并提交消息中记录合并的原因，以便其他开发者了解为什么会合并不相关的历史。 备份： 在执行不相关历史的合并操作之前，最好进行备份，以防合并出现问题。 4. 示例： 下面是一个简单的示例，展示了如何使用 --allow-unrelated-histories 合并两个没有共同历史的分支： # 创建一个新的 Git 仓库并添加一些提交 git init touch file1.txt git add file1.txt git commit -m &quot;Initial commit in main branch&quot; # 创建一个新的分支并添加一些提交 git checkout -b feature-branch touch file2.txt git add file2.txt git commit -m &quot;Initial commit in feature-branch&quot; # 尝试将两个分支合并，使用 --allow-unrelated-histories git checkout main git merge feature-branch --allow-unrelated-histories 这个示例中，我们在两个分支中都创建了不同的提交历史，然后使用 --allow-unrelated-histories 合并了它们。 总之，--allow-unrelated-histories 是一个用于合并没有共同历史的代码的 Git 选项。它在某些情况下非常有用，但需要小心使用，并遵循上述注意事项和最佳实践，以确保合并操作的顺利进行。 Git 分支操作 Git 分支基础 创建分支： 使用 git branch &lt;branch-name&gt; 命令可以创建一个新的分支。例如，git branch feature-branch 将创建名为 &quot;feature-branch&quot; 的新分支。 切换分支： 使用 git checkout &lt;branch-name&gt; 命令可以切换到指定的分支。例如，git checkout feature-branch 将切换到 &quot;feature-branch&quot; 分支。 创建并切换分支： 使用 git checkout -b &lt;branch-name&gt; 命令可以创建并切换到新的分支。例如，git checkout -b bug-fix 将创建并切换到名为 &quot;bug-fix&quot; 的新分支。 查看分支： 使用 git branch 命令可以查看当前仓库中的所有分支。当前分支会有一个 * 标记。 合并分支 合并分支： 使用 git merge &lt;branch-name&gt; 命令可以将指定分支的更改合并到当前分支。例如，git merge feature-branch 将合并 &quot;feature-branch&quot; 分支的更改到当前分支。 解决冲突： 如果合并操作中出现冲突，需要手动解决冲突，编辑文件以保留需要的更改，并使用 git add 标记文件为已解决冲突。然后再次运行 git merge。 删除分支 删除本地分支： 使用 git branch -d &lt;branch-name&gt; 命令可以删除本地分支。例如，git branch -d feature-branch 将删除 &quot;feature-branch&quot; 分支。 强制删除分支： 使用 git branch -D &lt;branch-name&gt; 命令可以强制删除本地分支，即使该分支上有未合并的更改。慎用这个命令。 远程分支操作 推送分支： 使用 git push origin &lt;branch-name&gt; 命令可以将本地分支推送到远程仓库。例如，git push origin feature-branch 将推送 &quot;feature-branch&quot; 分支到远程仓库。 拉取远程分支： 使用 git fetch 命令可以拉取远程仓库的最新分支信息。然后，可以使用 git checkout 或 git merge 来处理远程分支。 删除远程分支： 使用 git push origin --delete &lt;branch-name&gt; 命令可以删除远程分支。例如，git push origin --delete old-feature 将删除名为 &quot;old-feature&quot; 的远程分支。 分支策略和最佳实践 主分支（通常是 master 或 main）： 主分支应该是稳定的，只包含已发布或即将发布的代码。不要在主分支上直接开发新功能或修复问题。 特性分支： 为每个新功能或修复问题创建一个独立的特性分支。这样可以保持代码的可维护性。 合并前测试： 在合并分支之前，确保新的更改通过了测试。避免将未测试或有问题的更改合并到主分支。 定期合并主分支： 定期将主分支的更改合并到特性分支，以确保你的特性分支保持最新。 代码审查： 进行代码审查以确保代码质量和一致性。代码审查可以在特性分支开发期间进行，也可以在合并到主分支之前进行。 注意事项 谨慎使用强制操作： 强制删除分支或使用强制合并选项时要小心，这可能会导致数据丢失或不可逆的更改。 定期备份： 定期备份你的仓库，以防止意外的数据丢失。 避免直接在主分支上工作： 避免在主分支上直接开发，以免影响稳定版本的代码。 清理不必要的分支： 定期清理已合并或不再需要的分支，以保持仓库的整洁。 Git 标签操作 创建标签 创建轻量标签： 使用 git tag &lt;tag-name&gt; 命令可以创建一个轻量标签。例如，git tag v1.0 将创建一个名为 &quot;v1.0&quot; 的轻量标签，它只是一个指向特定提交的引用。 创建带注释的标签： 使用 git tag -a &lt;tag-name&gt; -m &quot;标签注释&quot; 命令可以创建一个带注释的标签。例如，git tag -a v1.0 -m &quot;版本 1.0 发布&quot; 将创建一个带注释的 &quot;v1.0&quot; 标签。 查看标签 查看所有标签： 使用 git tag 命令可以列出所有标签。例如，git tag 将列出所有存在的标签。 查看特定标签的信息： 使用 git show &lt;tag-name&gt; 命令可以查看特定标签的详细信息。例如，git show v1.0 将显示 &quot;v1.0&quot; 标签的相关提交信息和注释。 删除标签 删除本地标签： 使用 git tag -d &lt;tag-name&gt; 命令可以删除本地标签。例如，git tag -d v1.0 将删除名为 &quot;v1.0&quot; 的本地标签。 删除远程标签： 删除远程标签需要使用 git push 命令。首先，使用 git tag -d &lt;tag-name&gt; 删除本地标签，然后使用 git push origin :refs/tags/&lt;tag-name&gt; 命令删除远程标签。例如，删除远程的 &quot;v1.0&quot; 标签可以使用 git push origin :refs/tags/v1.0。 共享标签 共享本地标签： 使用 git push origin &lt;tag-name&gt; 命令可以将本地标签推送到远程仓库。例如，git push origin v1.0 将 &quot;v1.0&quot; 标签推送到远程仓库。 共享所有标签： 使用 git push origin --tags 命令可以将所有本地标签推送到远程仓库。 注意事项 语义化版本号： 推荐使用语义化版本号（Semantic Versioning）作为标签名称，例如 &quot;v1.0.0&quot;、&quot;v2.1.3&quot;，以便更清晰地标识版本。 不要在分支上创建标签： 标签应该基于具体的提交，而不是分支。避免在分支上创建标签，以免造成混淆。 不要轻易删除标签： 删除标签后，相关的提交仍然存在于仓库中，但可能不容易找到。因此，不要轻易删除已发布的标签。 共享标签前小心谨慎： 在将标签推送到远程仓库之前，确保标签的名称和注释是正确的，因为标签一旦发布，通常不应更改。 使用带注释的标签： 对于重要的版本发布或里程碑，推荐使用带注释的标签，以提供更多的信息和上下文。 备份标签信息： 如果有重要的标签信息，最好将标签信息备份到文档或数据库中，以防止意外丢失。 最佳实践 假设您有一个Git仓库，并且已经在其中进行了一些提交。以下是一个简单的演示： 步骤 1：创建标签 首先，让我们创建一个新的标签，假设您的项目已经准备好发布版本1.0： # 创建带注释的标签 git tag -a v1.0 -m &quot;版本 1.0 发布&quot; 步骤 2：查看标签 查看已创建的标签： # 查看所有标签 git tag 您将看到列出的标签列表，其中包括我们刚刚创建的 &quot;v1.0&quot; 标签。 步骤 3：推送标签到远程仓库 如果要将标签共享到远程仓库，可以使用以下命令： # 推送特定标签到远程仓库 git push origin v1.0 如果要推送所有标签： # 推送所有标签到远程仓库 git push origin --tags 步骤 4：删除标签 如果需要删除标签，可以使用以下命令： # 删除本地标签 git tag -d v1.0 # 删除远程标签（先删除本地标签，然后推送删除到远程仓库） git tag -d v1.0 git push origin :refs/tags/v1.0 请谨慎操作删除标签，因为一旦删除，可能不容易恢复。 切换标签 Git中切换标签（Switching Tags）通常用于将工作目录切换到特定标签所代表的快照状态，以查看或测试该标签所对应的代码版本。 在Git中，标签是用于标识特定提交（commit）的人可读的名称，通常用于表示软件版本或里程碑。 切换标签的基本命令 要切换到特定标签，您可以使用以下基本命令： git checkout &lt;tag-name&gt; 这会将您的工作目录切换到与标签 &lt;tag-name&gt; 关联的提交，您可以在其中查看或测试特定版本的代码。 注意事项 在切换标签时，有一些需要注意的事项和最佳实践： 只读状态: 切换到标签后，您的工作目录将处于只读状态，即您不能在该状态下进行提交或修改代码。标签是不可变的，它们代表的是历史的快照。 不要在标签上进行开发: 标签通常用于查看历史版本或发布版本。不要试图在标签上进行开发工作，因为无法提交更改到标签。 新标签的创建: 如果需要切换到尚不存在的标签，首先需要确保标签已经存在。您可以使用以下命令创建一个新的标签并切换到它： git checkout -b &lt;new-branch&gt; &lt;commit&gt; 这将创建一个新分支（基于指定提交）并将工作目录切换到该分支。 标签命名规范: 给标签取一个有意义的名称，通常是与版本号或里程碑相关的名称，以便团队成员能够理解其含义。 切换回分支: 如果您在标签上查看完特定版本后，要切换回分支，请使用以下命令： git checkout &lt;branch-name&gt; 切换标签的应用场景 查看历史版本: 您可以使用标签切换到历史版本以查看特定时间点的代码状态，这对于故障排除或比较不同版本之间的差异非常有用。 发布管理: 在软件开发中，标签通常用于标识发布版本，切换到标签可以查看和测试发布的稳定版本。 回滚代码: 如果在某个标签版本中发现了问题，您可以切换回之前的标签版本来回滚代码。 IDEA 中使用Git 使用步骤 步骤1：在IDEA中配置Git 在IDEA中配置Git非常简单。请确保您已经安装了Git，并按照以下步骤操作： 打开IDEA，进入“File”（文件）菜单，选择“Settings”（设置）。 在左侧面板中，展开“Version Control”（版本控制）并选择“Git”。 在右侧面板中，确保Git可用，并配置Git的全局用户信息，包括您的用户名和电子邮件地址。 步骤2：在IDEA中初始化Git仓库 要在项目中使用Git，您需要初始化一个Git仓库。请按照以下步骤操作： 打开IDEA，并在您的项目中右键单击，选择“Git” &gt; “Initialize Repository”（初始化仓库）。 按照提示选择要将项目添加到Git仓库的目录，并单击“Initialize”（初始化）。 步骤3：进行提交、推送和拉取更改 现在，您已经初始化了Git仓库，可以开始进行提交、推送和拉取更改了。 提交更改：在IDEA的Git工具窗口中，选择要提交的文件，输入提交消息，然后单击“Commit”（提交）按钮。 推送更改：使用“VCS” &gt; “Git” &gt; “Push”（推送）将本地更改推送到远程存储库。 拉取更改：使用“VCS” &gt; “Git” &gt; “Pull”（拉取）从远程存储库获取最新更改。 步骤4：处理分支和合并操作 在软件开发中，分支和合并操作是非常重要的，因为它们允许多个开发者同时在项目中工作而不互相干扰。下面是处理分支和合并操作的详细步骤。 创建分支 在IDEA中，打开Git工具窗口。 单击“Branches”（分支）选项卡，然后单击“New Branch”（新建分支）按钮。 输入新分支的名称，并选择基于哪个分支创建它。通常，您会基于主分支（通常是master或main）创建新分支。 切换分支 在Git工具窗口的“Branches”选项卡中，双击要切换到的分支名称。 您现在位于所选分支上，可以开始在该分支上进行工作。 合并分支 首先，确保您位于要合并到的目标分支上（通常是主分支）。 在Git工具窗口的“Branches”选项卡中，右键单击要合并的分支，然后选择“Merge into Current”（合并到当前分支）。 解决任何合并冲突，如果有的话。 提交合并后的更改。 步骤5：解决冲突 在多人协作开发中，冲突可能会发生，特别是当多个开发者同时修改相同文件的相同部分时。解决冲突的步骤如下： 在IDEA中，打开包含冲突的文件。 您将看到冲突的标记，通常以&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======和&gt;&gt;&gt;&gt;&gt;&gt;&gt;之类的符号表示。 编辑文件以解决冲突，保留您需要的更改，删除不需要的部分。 保存文件并进行提交，以完成冲突解决。 步骤6：回滚更改 如果您需要回滚到以前的版本，可以使用Git的版本控制功能。在IDEA中，可以使用以下步骤回滚更改： 打开Git工具窗口。 在“Log”选项卡中，查找您要回滚到的提交。 右键单击该提交，并选择“Reset Current Branch to Here...”（将当前分支重置到此处）。 选择要执行的重置操作类型，通常选择“Hard”（强制）以回滚到选定提交。 注意事项 定期提交代码： 不要等到整个功能或任务完成后再提交代码，而是应该频繁地提交小的更改。这有助于保持版本历史的清晰度和可追踪性。 有意义的提交消息： 每次提交都应该附带一个有意义的提交消息，简要描述您的更改内容。这有助于团队成员理解您的工作，也方便将来查看提交历史。 合并前进行代码审查： 如果您在团队中工作，尤其是在多人协作项目中，建议进行代码审查。这可以帮助发现潜在的问题和改进代码质量。 定期拉取最新更改： 在开始工作之前，确保从远程存储库拉取最新更改，以避免冲突和与团队保持同步。 分支命名规范： 使用清晰的分支命名规范，例如feature/your-feature-name或bugfix/issue-number。这有助于标识分支的目的。 小心使用强制推送： 避免在共享分支上使用强制推送，以免不小心删除其他人的更改。只在自己的私有分支上使用强制推送。 备份和恢复： 定期备份您的本地工作和重要的Git仓库。在发生问题时，可以轻松恢复数据。 学习解决冲突： 学习如何解决Git合并冲突，因为这是协作开发中常见的情况。了解如何手动解决冲突将是一个巨大的优势。 版本号管理： 如果您的项目需要版本号管理，请使用Git的标签来标识重要版本。这有助于追踪项目的版本历史。 使用.gitignore文件： 创建一个.gitignore文件，以排除不需要跟踪的临时文件、编译文件和敏感信息。 备份敏感信息： 不要将敏感信息（如API密钥或密码）存储在Git存储库中。使用环境变量或专门的密钥管理工具。 ","tags":[{"name":"Tools","slug":"N-VG7_vaJ","used":true,"link":"https://riftrays.github.io/N-VG7_vaJ/"}],"title":"Git","feature":"","link":"https://riftrays.github.io/git/","stats":{"text":"35 min read","time":2091000,"words":9400,"minutes":35},"date":"2019-10-15 17:12:54","dateFormat":"2019-10-15 17:12:54"},{"abstract":"","content":"主要区别 方法定义：接口只能定义抽象方法，没有实现代码；抽象类可以包含抽象方法和具体方法（有方法体）。 访问修饰符：接口中的方法默认是public修饰，不能使用其他访问修饰符；抽象类的抽象方法可以使用public、protected和default修饰符。 继承：类可以同时实现多个接口（多实现），但只能继承一个抽象类（单继承）。 构造器：接口不能有构造器，抽象类可以有构造器。 成员变量：接口中只能定义静态常量，不能定义普通成员变量；抽象类可以有普通成员变量。 如何选择 当需要定义一组规范、制定标准时，应该使用接口。 当有一部分代码需要复用，并且存在一些公共方法可以在多个子类中共享时，可以使用抽象类。 如果一个类需要继承多个类或模拟多重继承，应该使用接口。 通常，在设计时，我们先考虑使用接口定义规范，并让不同的实现类来实现这些接口。如果发现有一些共用的方法和字段，可以将它们抽取到抽象类中，供实现类继承和复用。这样的设计可以充分利用Java的多态性和灵活性。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"接口和抽象类","feature":"","link":"https://riftrays.github.io/etv3uE4Pw/","stats":{"text":"2 min read","time":71000,"words":354,"minutes":2},"date":"2019-01-03 23:50:53","dateFormat":"2019-01-03 23:50:53"},{"abstract":"","content":"多态是面向对象编程中的一个重要概念，它允许在运行时根据实际对象的类型来调用相应的方法，从而实现同一操作作用于不同对象，产生不同执行结果的效果。 在Java中，多态的实现需要满足三个条件： 继承或接口实现：需要存在类之间的继承关系或类实现接口。 方法重写：子类必须重写父类的方法，即在子类中对父类的方法进行重新实现，从而改变了方法的行为。 父类引用指向子类对象：通过父类的引用指向子类的对象，可以实现在运行时根据实际对象类型来调用方法。 以下是一个简单示例来说明多态的使用： class Animal { void makeSound() { System.out.println(&quot;Animal makes a sound&quot;); } } class Dog extends Animal { @Override void makeSound() { System.out.println(&quot;Dog barks&quot;); } } class Cat extends Animal { @Override void makeSound() { System.out.println(&quot;Cat meows&quot;); } } public class Main { public static void main(String[] args) { Animal animal1 = new Dog(); Animal animal2 = new Cat(); animal1.makeSound(); // Output: Dog barks animal2.makeSound(); // Output: Cat meows } } 在上述示例中，Animal类是父类，而Dog和Cat是继承自Animal的子类。在main方法中，animal1和animal2是Animal类型的引用，但它们分别指向了Dog和Cat的实例。通过调用makeSound方法，实际上是在运行时根据对象的实际类型来决定调用哪个类的makeSound方法，从而实现了多态。 总结起来，多态允许将同一操作应用于不同类型的对象，从而实现代码的灵活性和复用性。在Java中，通过继承和方法重写来实现多态，使得代码更加灵活、可扩展，并能适应不同的业务需求。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Java中的多态","feature":"","link":"https://riftrays.github.io/RCbbZbScS/","stats":{"text":"2 min read","time":102000,"words":446,"minutes":2},"date":"2019-01-02 23:51:37","dateFormat":"2019-01-02 23:51:37"},{"abstract":"","content":"为什么Java不支持多继承？ Java不支持多继承的主要原因是为了避免菱形继承（Diamond Problem）的问题，同时保持代码的简洁性和清晰性。 菱形继承问题（Diamond Problem） 菱形继承问题是指一个子类继承自两个（或更多）父类，而这些父类又共同继承自同一个父类，形成了一个菱形的继承体系。 当子类调用共同父类的方法时，由于存在多条继承路径，就产生了歧义，不知道应该调用哪个父类的方法。 A / \\ / \\ B C \\ / \\ / D 在上面的示意图中，类A是一个父类，类B和类C都继承自A，而类D继承自B和C。这样就形成了一个菱形继承体系。当类D尝试调用来自A的方法时，由于存在多条继承路径，就会产生歧义，不知道应该调用B的A方法还是C的A方法。这就是菱形继承问题所在。 在Java中，由于不支持多继承，可以避免菱形继承问题的出现。类D只能继承一个父类，无法同时继承B和C，从而解决了菱形继承问题。如果需要同时继承多个接口中有相同方法名的默认方法，实现类必须显式地重写该方法以消除冲突。 Java的多继承问题 Java不支持多继承，一个类只能继承一个父类，这样可以避免菱形继承问题的发生。 Java通过接口（Interface）来实现多继承的灵活性。一个类可以实现多个接口，从而获得多个接口中定义的抽象方法的具体实现。 在Java 8之前，接口中不能包含具体的方法实现，因此多接口的实现没有冲突。但在Java 8之后，接口中可以包含默认方法（default method），如果多个接口中有相同的默认方法，实现类就必须显式地重写该方法来解决冲突。 Java通过不支持多继承，并使用接口来实现多继承的灵活性，保持了代码的清晰性和可维护性，同时避免了菱形继承问题的困扰。开发者可以根据具体需求选择接口的组合来实现类的功能扩展。 在Java 8中，引入了默认方法（default method）的概念，使得接口中可以包含带有方法体的方法。这样一来，一个类可以同时实现多个接口，并从这些接口中继承多个默认方法。 然而，Java 8并没有解决菱形继承问题。当一个类实现了多个接口，并且这些接口中有相同的默认方法时，编译器无法自动决定应该调用哪个默认方法，从而导致了歧义问题。为了解决这个问题，Java 8强制要求实现类必须显式地重写这个冲突的默认方法。 这样的设计保留了接口的灵活性，允许类从多个接口中继承方法，但也强迫开发人员在发生冲突时做出明确的决策。通过重写方法，开发人员可以自己解决菱形继承问题，从而确保代码的正确性和可维护性。这种方式既保持了Java的简洁性和清晰性，又允许类实现多个功能接口，是一种折中的设计。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"为什么Java不支持多继承","feature":"","link":"https://riftrays.github.io/kFq__aKRr/","stats":{"text":"4 min read","time":184000,"words":891,"minutes":4},"date":"2019-01-02 16:50:03","dateFormat":"2019-01-02 16:50:03"},{"abstract":"","content":"负数取绝对值结果不一定是正数 在Java中，对负数取绝对值时，使用 Math.abs() 方法可能会得到一个负数的情况。这是因为 int 的取值范围是从 -2^31 到 (2^31) - 1，即 -2147483648 到 2147483647。当要取绝对值的数字是 -2147483648 时，其绝对值为 2147483648，但超过了 int 的取值范围，导致发生越界，进而得到了负数。 这种情况虽然发生概率较低，但需要注意。为了解决这个问题，我们可以将 int 类型的数字转换为 long 类型，然后再进行绝对值运算。这样可以避免越界问题。 以下是可执行的完整代码示例，演示了如何解决这个问题： public class AbsoluteValueExample { public static void main(String[] args) { int orderId = -2147483648; // 错误示例：直接使用 Math.abs() int wrongAbs = Math.abs(orderId); // 正确示例：将 int 转换为 long，再使用 Math.abs() long longOrderId = (long) orderId; long correctAbs = Math.abs(longOrderId); // 打印结果 System.out.println(&quot;Wrong Abs: &quot; + wrongAbs); // 错误结果：-2147483648 System.out.println(&quot;Correct Abs: &quot; + correctAbs); // 正确结果：2147483648 } } 在上述代码中，我们将 -2147483648 这个负数作为 orderId，并展示了两种情况。首先，直接使用 Math.abs() 方法得到了错误的绝对值 -2147483648，然后我们将 orderId 转换为 long 类型后再使用 Math.abs() 方法，得到了正确的绝对值 2147483648。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"负数取绝对值结果不一定是正数","feature":"","link":"https://riftrays.github.io/OFZTTPDRB/","stats":{"text":"2 min read","time":82000,"words":348,"minutes":2},"date":"2019-01-02 07:33:35","dateFormat":"2019-01-02 07:33:35"},{"abstract":"","content":"为什么不能用浮点数表示金额？ 浮点数在计算机中是以二进制表示的，但是很多十进制的小数（如0.1、0.01等）在二进制中无法精确表示，因为它们的二进制表示是无限循环的。 例如，0.1在二进制表示中是0.00011001100110011...（无限循环），由于计算机的存储是有限的，所以在存储和计算过程中会进行截断，导致精度丢失。这样，进行一系列浮点数运算后，可能得到的结果会存在舍入误差，从而导致计算结果与预期不符。 这种舍入误差在数值计算中是非常危险的，尤其在涉及金额和金融计算时更为严重。小的舍入误差可能在单个计算中不明显，但在大量的计算中会累积起来，导致计算结果出现较大的偏差，影响到财务数据的准确性和可靠性。 为了避免在金额计算中产生舍入误差，更好的做法是使用整数类型（如整型或长整型）来表示金额，或者使用专门的高精度计算库（如Java中的BigDecimal类），这样可以确保金额计算的精确性。这些方法在进行金融和货币计算时更为可靠，避免了因浮点数运算而产生的不确定性。 使用BigDecimal类进行高精度运算时，可以设置精确的小数位数、进行四舍五入等操作，确保计算结果的准确性和可靠性。对于涉及金额等重要数据的计算，建议始终使用BigDecimal来进行处理，从而避免由于浮点数带来的不确定性和精度丢失问题。这样可以保证在金融等关键领域的应用中数据的准确性和可信度。 十进制转换为二进制 十进制整数转换为二进制整数的方法是“除2取余，逆序排列”法。 用2整除十进制整数，得到一个商和余数，再用2去除商，继续得到商和余数，直到商为小于1时停止。将先得到的余数作为二进制数的低位有效位，后得到的余数作为高位有效位，依次排列起来。 十进制小数转换为二进制小数的方法是“乘2取整，顺序排列”法。 用2乘十进制小数，得到一个积，将积的整数部分取出，再用2乘余下的小数部分，继续得到积，再取出积的整数部分。如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位，或者达到所要求的精度为止。 举例： 十进制整数127转换成二进制为1111111。 十进制小数0.625转换成二进制为0.101。 不是所有数都能用二进制表示 在计算机中，浮点数的表示是有限的，而不是精确的。无论是单精度浮点数（float）还是双精度浮点数（double），它们都是采用有限的位数来表示小数部分的。因此，对于某些十进制小数，其在二进制表示中会产生无限循环的情况，从而无法精确地表示。 0.1 的二进制表示是无限循环的，即 (0.1)10 = (0.000110011001100…)2。由于计算机的浮点数表示是有限的，它只能取近似值来表示这种无限循环的小数。因此，对于像 0.1 这样的小数，计算机无法精确地表示它，而只能使用近似值来表示，从而导致精度丢失。 在实际编程中，特别是涉及到涉及到金融和精确计算的场景，我们应该避免直接使用浮点数进行高精度运算，因为会导致精度丢失。而应该使用专门的精确计算类，如 Java 中的 BigDecimal，来进行高精度的计算，从而避免精度丢失的问题。 IEEE 754 IEEE 754标准定义了浮点数的表示方法，它通过三元组{S, E, M}来表示一个浮点数N，其中： S（sign）表示N的符号位，对应值s满足：N &gt; 0时，s = 0；N ≤ 0时，s = 1。 E（exponent）表示N的指数位，位于S和M之间的若干位。对应值e值也可正可负。 M（mantissa）表示N的尾数位，恰好位于N末尾。M也叫有效数字位（significand）、系数位（coefficient），甚至被称作“小数”。 根据IEEE 754标准，浮点数的实际值n由下方的式子表示： n = (-1)^s * (1.M) * 2^(e - Bias) 其中，Bias是一个偏移值，它在单精度浮点数中为127，在双精度浮点数中为1023。这样，通过浮点数的表示方式，计算机可以用有限的位数来表示一个范围更大的数，并提供一定的精度。 然而，正如您指出的，由于浮点数表示的精度是有限的，对于某些小数，特别是无限循环的二进制数，计算机无法精确地表示它们。这导致在浮点数运算中可能会出现一些精度丢失的情况。 为了避免精度丢失，特别是在涉及到金额等精确计算的场景，我们应该使用专门的精确计算类，如Java中的BigDecimal，来进行高精度的计算。BigDecimal能够提供更高的精度，从而避免了浮点数运算带来的精度问题。 为什么不能用BigDecimal的equals方法做等值比较？ 在Java中，对于比较浮点数，包括BigDecimal，不能简单地使用equals()方法进行等值比较，这是因为浮点数是近似值的表示，在进行浮点数运算时可能会存在精度损失。这个问题同样适用于使用double或float进行浮点数运算。 在BigDecimal中，equals()方法是继承自Object类的方法，它用于比较对象的引用是否相等，而不是比较数值是否相等。如果要在BigDecimal中比较数值是否相等，应该使用compareTo()方法或equals()方法的重载版本。 例如，BigDecimal的compareTo()方法用于比较两个BigDecimal对象的数值是否相等，它返回一个整数值，表示两个数值的大小关系。如果返回值为0，则表示两个BigDecimal对象的数值相等。 示例： BigDecimal num1 = new BigDecimal(&quot;0.1&quot;); BigDecimal num2 = new BigDecimal(&quot;0.100&quot;); if (num1.equals(num2)) { System.out.println(&quot;num1 and num2 are equal using equals() method.&quot;); } else { System.out.println(&quot;num1 and num2 are not equal using equals() method.&quot;); } if (num1.compareTo(num2) == 0) { System.out.println(&quot;num1 and num2 are equal using compareTo() method.&quot;); } else { System.out.println(&quot;num1 and num2 are not equal using compareTo() method.&quot;); } 输出： num1 and num2 are not equal using equals() method. num1 and num2 are equal using compareTo() method. 在上面的示例中，equals()方法返回false，因为它比较的是对象的引用，而不是数值。而compareTo()方法返回0，表示num1和num2的数值是相等的。 因此，要在BigDecimal中比较数值是否相等，应该使用compareTo()方法或equals()方法的重载版本，并根据具体情况选择适当的精度来比较数值。例如，可以使用compareTo()方法来判断两个BigDecimal对象的数值是否相等，或使用setScale()方法设置精度后再使用equals()方法进行比较。 Compares this BigDecimal with the specified Object for equality. Unlike compareTo, this method considers two BigDecimal objects equal only if they are equal in value and scale (thus 2.0 is not equal to 2.00 when compared by this method) BigDecimal 类的标度问题确实是一个相对复杂的主题。标度代表着小数部分的位数。 首先，我们来解释一下 BigDecimal 构造方法的标度问题： BigDecimal(int val) 和 BigDecimal(long val)：这两个构造方法用于创建整数类型的 BigDecimal 对象，所以它们的标度都是0。 BigDecimal(double val)：使用 BigDecimal(double) 构造方法时，由于 double 类型本身就是近似值，创建出来的 BigDecimal 对象也会是近似值。比如，new BigDecimal(0.1) 所创建的 BigDecimal 值并不是精确的0.1，而是近似值0.1000000000000000055511151231257827021181583404541015625。这样的近似值决定了标度是这个近似值的位数，即55。 现在，让我们通过代码示例来验证上述描述： import java.math.BigDecimal; public class BigDecimalScaleExample { public static void main(String[] args) { // 使用BigDecimal(int)构造方法 BigDecimal intValue = new BigDecimal(100); System.out.println(&quot;整数的标度：&quot; + intValue.scale()); // 输出：整数的标度：0 // 使用BigDecimal(long)构造方法 BigDecimal longValue = new BigDecimal(1000000000000L); System.out.println(&quot;长整数的标度：&quot; + longValue.scale()); // 输出：长整数的标度：0 // 使用BigDecimal(double)构造方法 BigDecimal doubleValue1 = new BigDecimal(0.1); BigDecimal doubleValue2 = new BigDecimal(0.10); System.out.println(&quot;double值1的标度：&quot; + doubleValue1.scale()); // 输出：double值1的标度：55 System.out.println(&quot;double值2的标度：&quot; + doubleValue2.scale()); // 输出：double值2的标度：55 } } 小贴士： 输出的结果中，整数类型的标度都是0，而使用 BigDecimal(double) 构造方法创建的 BigDecimal 对象的标度都是55，因为它们的近似值都是含有55位小数。 BigDecimal(double)和BigDecimal(String)有什么区别？ BigDecimal(double) 和 BigDecimal(String) 构造方法之间有着明显的区别。 BigDecimal(double) 构造方法： 由于 double 类型是不精确的，当我们使用 BigDecimal(double) 构造方法来创建 BigDecimal 对象时，得到的结果也是不精确的。这是因为 double 只能表示一个近似值，而不能精确表示某个具体的数字。 例如，当我们使用 new BigDecimal(0.1) 创建一个 BigDecimal 对象时，实际上创建出来的值并不等于精确的0.1。而是近似值：0.1000000000000000055511151231257827021181583404541015625。这种近似值是由 double 类型本身决定的。 BigDecimal(String) 构造方法： 与使用 BigDecimal(double) 构造方法不同，当我们使用 BigDecimal(String) 构造方法来创建 BigDecimal 对象时，我们可以确切地指定要表示的数值。这是因为使用字符串来表示数值时不会引入浮点数的近似问题，字符串中的每个字符都会被精确地转换为相应的数字。 例如，当我们使用 new BigDecimal(&quot;0.1&quot;) 创建一个 BigDecimal 对象时，创建出来的值正好等于精确的0.1。 现在，让我们来通过代码示例来验证上述描述： import java.math.BigDecimal; public class BigDecimalComparisonExample { public static void main(String[] args) { // 使用BigDecimal(double)构造方法 BigDecimal doubleValue = new BigDecimal(0.1); System.out.println(&quot;BigDecimal(double)值：&quot; + doubleValue); // 输出：BigDecimal(double)值：0.1000000000000000055511151231257827021181583404541015625 // 使用BigDecimal(String)构造方法 BigDecimal stringValue = new BigDecimal(&quot;0.1&quot;); System.out.println(&quot;BigDecimal(String)值：&quot; + stringValue); // 输出：BigDecimal(String)值：0.1 } } 在以上代码示例中，我们使用了 BigDecimal(double) 和 BigDecimal(String) 构造方法分别创建了两个 BigDecimal 对象，并打印出它们的值。可以看到，使用 BigDecimal(double) 构造方法创建的值是近似值，而使用 BigDecimal(String) 构造方法创建的值是精确的。 BigDecimal 确实是通过一个 &quot;无标度值&quot; 和一个 &quot;标度&quot; 来表示一个数的。无标度值表示数字的实际值，而标度表示小数部分的位数。 在 BigDecimal 中，无标度值的表示方式取决于实际情况： 当无标度值超过阈值（默认为 Long.MAX_VALUE）时，使用 BigInteger 类型的 intVal 字段存储无标度值，并且 intCompact 字段存储 Long.MIN_VALUE。这是因为无标度值过大无法用 long 类型完整表示，所以使用 BigInteger 进行存储。 否则，当无标度值在可用的 long 范围内时，对无标度值进行压缩存储在 long 类型的 intCompact 字段中，用于后续计算，而 intVal 字段为空。 下面是对你提供的 BigDecimal 类的简化代码片段，用于说明 intVal、scale 和 intCompact 字段： import java.math.BigDecimal; import java.math.BigInteger; public class BigDecimalExplanation { public static void main(String[] args) { // 示例：使用BigDecimal表示数值 BigInteger intVal = new BigInteger(&quot;12345678901234567890&quot;); int scale = 6; long intCompact = Long.MIN_VALUE; BigDecimal bigDecimalWithBigInt = new BigDecimal(intVal, scale); BigDecimal bigDecimalWithCompact = new BigDecimal(intCompact, scale); System.out.println(&quot;BigDecimal with BigInteger: &quot; + bigDecimalWithBigInt); System.out.println(&quot;BigDecimal with long (compact): &quot; + bigDecimalWithCompact); } } 在上面的代码示例中，我们创建了两个不同的 BigDecimal 对象：一个使用 BigInteger 的 intVal 字段表示无标度值，另一个使用 long 类型的 intCompact 字段表示无标度值。两个 BigDecimal 对象都具有相同的标度 scale。 请注意，为了简化代码示例，我们直接创建了 BigInteger 和 long 类型的值，实际情况中，这些值通常是由其他计算过程或者输入得到的。 BigDecimal(double)有什么问题 使用 BigDecimal(double) 构造方法来创建 BigDecimal 对象时，由于双精度浮点数的不精确性，会导致精度损失的问题。为了解决这个问题，我们应该使用 BigDecimal(String) 构造方法来确保精确表示。 下面是一个示例代码，演示了使用 BigDecimal(String) 构造方法来避免精度损失的情况： import java.math.BigDecimal; public class BigDecimalDoubleIssue { public static void main(String[] args) { double doubleValue = 0.1; String stringValue = &quot;0.1&quot;; BigDecimal bdFromDouble = new BigDecimal(doubleValue); BigDecimal bdFromString = new BigDecimal(stringValue); System.out.println(&quot;BigDecimal from double: &quot; + bdFromDouble); System.out.println(&quot;BigDecimal from String: &quot; + bdFromString); } } 在上述代码中，我们分别使用 BigDecimal(double) 和 BigDecimal(String) 构造方法创建了两个 BigDecimal 对象，并打印出了它们的值。请注意，当使用 BigDecimal(double) 构造方法时，精度损失会导致结果不准确，而使用 BigDecimal(String) 构造方法则可以确保精确表示。 输出结果为： BigDecimal from double: 0.1000000000000000055511151231257827021181583404541015625 BigDecimal from String: 0.1 如你所见，使用 BigDecimal(String) 构造方法创建的 BigDecimal 对象确保了精确表示，而使用 BigDecimal(double) 构造方法则引起了精度损失。 为了避免精度损失，我们应该始终使用 BigDecimal(String) 构造方法，将双精度浮点数转换为字符串后再进行构造。 使用BigDecimal(String)创建 对于 BigDecimal(String) 构造方法，我们可以通过传入一个字符串来精确地表示小数。例如，使用 new BigDecimal(&quot;0.1&quot;) 就可以创建一个精确表示为0.1的 BigDecimal，其标度为1。 然而，需要注意的是，new BigDecimal(&quot;0.10000&quot;) 和 new BigDecimal(&quot;0.1&quot;) 这两个数的标度分别是5和1。如果我们使用 BigDecimal 的 equals 方法进行比较，得到的结果是 false，因为标度不同。 为了创建一个精确表示0.1的 BigDecimal，我们可以使用以下两种方式： 使用 BigDecimal(String) 构造方法： BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;); 使用 BigDecimal.valueOf(double) 方法： BigDecimal recommend2 = BigDecimal.valueOf(0.1); 现在，让我们来解释一下 BigDecimal.valueOf(0.1) 是如何保证精确性的。 解释: BigDecimal.valueOf(double) 方法是 BigDecimal 类的一个静态工厂方法。当我们调用 BigDecimal.valueOf(0.1) 时，它会将 double 类型的参数转换为字符串，然后再使用 BigDecimal(String) 构造方法来创建 BigDecimal 对象。 在这个过程中，有一个关键点是：BigDecimal 的 BigDecimal(String) 构造方法能够确保精确地表示字符串中的小数。尽管传入的参数是一个 double 类型的近似值，但在转换为字符串时，它会保留足够的位数，从而确保精确性。 以下是可执行的完整代码示例来展示 BigDecimal.valueOf(0.1) 是如何保证精确性的： import java.math.BigDecimal; public class BigDecimalExample { public static void main(String[] args) { // 使用 BigDecimal(String) 构造方法创建精确表示0.1的 BigDecimal BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;); // 使用 BigDecimal.valueOf(double) 方法创建精确表示0.1的 BigDecimal BigDecimal recommend2 = BigDecimal.valueOf(0.1); // 打印结果 System.out.println(&quot;Recommended 1: &quot; + recommend1); System.out.println(&quot;Recommended 2: &quot; + recommend2); // 使用 equals 方法进行比较 System.out.println(&quot;Equals: &quot; + recommend1.equals(recommend2)); } } 输出结果为： Recommended 1: 0.1 Recommended 2: 0.1 Equals: true 如你所见，通过 BigDecimal.valueOf(0.1) 方法创建的 BigDecimal 精确地表示了0.1，并且与使用 BigDecimal(String) 构造方法创建的 BigDecimal 是相等的。 总结: 计算机采用二进制表示数据，而很多十进制小数（如0.1）在二进制中是无限循环小数，因此无法精确表示。为了处理这个问题，计算机引入了单精度浮点数（float）和双精度浮点数（double）等近似表示方法。 这样的近似表示导致了精度损失，因此在进行计算时，得到的结果也可能不是完全准确的。 为了避免精度损失，我们应该使用 BigDecimal(String) 构造方法来创建 BigDecimal 对象，从而确保精确表示小数。 下面是一个可执行的完整代码示例，展示了如何使用 BigDecimal(String) 构造方法创建 BigDecimal 对象，并进行精确的计算： import java.math.BigDecimal; public class BigDecimalExample { public static void main(String[] args) { // 使用 BigDecimal(String) 构造方法创建 BigDecimal 对象 BigDecimal decimalValue = new BigDecimal(&quot;0.1&quot;); BigDecimal otherValue = new BigDecimal(&quot;0.2&quot;); // 精确计算 BigDecimal sum = decimalValue.add(otherValue); BigDecimal product = decimalValue.multiply(otherValue); // 打印结果 System.out.println(&quot;BigDecimal 1: &quot; + decimalValue); System.out.println(&quot;BigDecimal 2: &quot; + otherValue); System.out.println(&quot;Sum: &quot; + sum); System.out.println(&quot;Product: &quot; + product); } } 在上述代码中，我们使用 BigDecimal(String) 构造方法来创建两个 BigDecimal 对象，分别表示0.1和0.2。然后，我们使用 add 方法对它们进行相加，并使用 multiply 方法进行乘法运算。由于使用了 BigDecimal(String) 构造方法，保证了精确表示，因此得到的结果是准确的。 输出结果为： BigDecimal 1: 0.1 BigDecimal 2: 0.2 Sum: 0.3 Product: 0.02 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Java中的金额表示与计算","feature":"","link":"https://riftrays.github.io/ktE-o0PoG/","stats":{"text":"18 min read","time":1050000,"words":4456,"minutes":18},"date":"2019-01-01 23:53:01","dateFormat":"2019-01-01 23:53:01"},{"abstract":"","content":"为什么 在Java中，包装类是为了将基本数据类型转换为对象的一种机制。虽然Java提供了基本数据类型（如int、double、boolean等），但有时候需要将这些基本数据类型作为对象来处理，这就需要用到包装类。主要的原因有以下几点： 泛型支持： 泛型要求使用对象类型，而不支持基本数据类型。如果需要在泛型中使用基本数据类型，就需要使用对应的包装类来代替。 集合框架支持： Java的集合框架（如List、Set、Map等）只能存储对象类型，不能直接存储基本数据类型。因此，当我们需要将基本数据类型存储在集合中时，需要使用对应的包装类。 面向对象特性： Java是一门面向对象的编程语言，它将所有数据视为对象。为了统一处理基本数据类型和对象，Java提供了包装类，使得基本数据类型也能像对象一样进行操作。 提供更多功能： 包装类除了可以将基本数据类型转换为对象外，还提供了很多实用的方法，比如数值转换、字符串转换等功能。 空值表示： 基本数据类型不能表示空值（null），而包装类可以通过赋值为null来表示空值。 例如，我们可以使用Integer包装类来将int类型转换为对象： int num = 42; // 基本数据类型 Integer objNum = Integer.valueOf(num); // 使用包装类将基本类型转换为对象 总之，包装类提供了将基本数据类型转换为对象的功能，并且在Java中使用包装类可以更好地支持泛型、集合框架和面向对象编程的特性。 区别 默认值不同：基本类型有固定的默认值，如int类型默认为0，boolean类型默认为false，char类型默认为'\\u0000'，而包装类的默认值是null。 初始化方式不同：基本类型不需要使用new进行初始化，可以直接赋值，例如：int x = 5; 而包装类需要使用new关键字进行初始化，例如：Integer y = new Integer(5); 但是Java 5之后引入了自动装箱和拆箱机制，使得包装类的初始化更加方便，可以直接使用基本类型的值来初始化包装类，例如：Integer z = 5; 存储方式不同：基本类型的值直接存储在栈上，而包装类的对象存储在堆上（通常情况下，在没有JIT优化栈上分配时）。这意味着基本类型的操作更加高效，因为它们直接在栈上进行，而包装类的操作可能需要在堆上进行，涉及到更多的内存管理和额外的开销。 总的来说，基本类型和包装类型在使用上有一些区别，但Java中的自动装箱和拆箱机制使得两者之间的转换更加方便，可以在需要使用对象的地方直接使用基本类型，并且Java编译器会自动进行相应的转换。这样使得基本类型和包装类型在代码编写和使用上更加灵活和方便。 如何理解自动拆装箱 自动拆箱与自动装箱是Java为了减少开发人员的工作量而提供的便捷功能。 自动装箱：当需要使用包装类对象的地方直接使用基本类型，Java会自动将基本类型转换成对应的包装类对象。例如：Integer i = 10; 这里就发生了自动装箱，将int类型的基本数据10转换成了Integer包装类对象。 自动拆箱：当需要使用基本类型的地方直接使用包装类对象，Java会自动将包装类对象转换成对应的基本类型。例如：int b = i; 这里就发生了自动拆箱，将Integer包装类对象转换成了int类型的基本数据。 这样的特性在编程中非常方便，省去了手动进行装箱和拆箱的繁琐过程。 自动拆装箱的原理是通过相应的包装类的valueOf()方法来实现自动装箱，通过包装类对象的xxxValue()方法来实现自动拆箱。 例如，对于Integer类来说，自动装箱是通过Integer.valueOf()方法实现的，自动拆箱是通过integer.intValue()方法实现的。 这种自动拆装箱特性使得基本类型和包装类型之间的转换变得非常便捷，使得代码编写更加简洁和灵活。 自动拆装箱原理 自动装箱和自动拆箱的原理是通过包装类的valueOf()方法和相应的包装类对象的xxxValue()方法来实现的。 自动装箱： 当将基本类型赋值给对应的包装类对象时，Java会调用包装类的valueOf()方法，将基本类型转换成对应的包装类对象。例如： int num = 10; Integer i = Integer.valueOf(num); // 自动装箱 在这里，Integer.valueOf(num)将基本类型num转换成了Integer包装类对象。 自动拆箱： 当将包装类对象赋值给对应的基本类型时，Java会调用包装类对象的xxxValue()方法，将包装类对象转换成对应的基本类型。例如： Integer i = 20; int num = i.intValue(); // 自动拆箱 在这里，i.intValue()将Integer包装类对象i转换成了基本类型num。 这种自动拆装箱的特性在编程中非常有用，它使得基本类型和包装类型之间的转换更加方便，同时也让代码更加简洁和易读。 需要注意的是，虽然自动拆装箱提供了便利性，但在一些性能敏感的场景中，过多地进行自动拆装箱可能会导致性能问题，因此需要谨慎使用。 实用场景 将基本数据类型放入集合类 当将基本数据类型放入集合类（如List、Set、Map等）中时，会自动进行装箱操作，将基本数据类型转换成对应的包装类对象。这是因为集合类只能存储对象类型，不能存储基本数据类型。 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); // 自动装箱，等价于 list.add(Integer.valueOf(1)); 包装类型和基本类型的大小比较 在包装类型和基本类型进行大小比较时，会自动进行拆箱操作，将包装类对象转换成对应的基本数据类型，然后进行比较。这样可以直接比较它们的值。 Integer num = 10; int value = 5; if (num &gt; value) { // 自动拆箱，等价于 if (num.intValue() &gt; value) // 执行代码块 } 包装类型的运算 当两个包装类型进行运算（如加法、减法等）时，会自动进行拆箱操作，将包装类对象转换成对应的基本数据类型，然后进行运算。最后的结果会自动装箱为包装类对象。 Integer num1 = 5; Integer num2 = 10; Integer result = num1 + num2; // 自动拆箱和装箱，等价于 Integer.valueOf(num1.intValue() + num2.intValue()) 三目运算符的使用 在三目运算符中，如果其中的第二个操作数是基本数据类型，而第三个操作数是包装类对象，会进行自动拆箱操作。如果第二个操作数是包装类对象，而第三个操作数是基本数据类型，会进行自动装箱操作。 boolean flag = true; Integer i = 0; int j = 1; int k = flag ? i : j; // 自动拆箱，等价于 int k = flag ? i.intValue() : j; 函数参数与返回值 当函数的参数或返回值是包装类型时，可以自动进行装箱和拆箱操作。这样使得方法的参数和返回值更加灵活，可以接收基本数据类型或包装类对象。 // 自动拆箱 public int getNum1(Integer num) { return num; // 等价于 return num.intValue(); } // 自动装箱 public Integer getNum2(int num) { return num; // 等价于 return Integer.valueOf(num); } 自动拆装箱机制让基本数据类型和包装类型之间的转换更加方便，使得代码更加简洁和易读。 但是在性能敏感的场景中，需要注意过多地进行自动拆装箱可能会导致性能问题，需要谨慎使用。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"为什么需要包装类","feature":"","link":"https://riftrays.github.io/61iwbB9aB/","stats":{"text":"8 min read","time":459000,"words":2140,"minutes":8},"date":"2019-01-01 23:52:15","dateFormat":"2019-01-01 23:52:15"},{"abstract":"","content":"概述 面向对象和面向过程是两种不同的编程范式，用于解决问题和组织代码的不同方式。 面向过程 面向过程是一种基于过程的编程范式，它将问题分解成一系列的步骤，每个步骤用函数或过程（procedure）来实现，然后按照顺序依次调用这些函数来解决问题。 面向过程的代码通常会使用大量的函数调用、条件语句（如if-else）、循环（如for、while）等来处理问题，逐步地执行任务。 典型的面向过程编程语言是C。 面向对象 面向对象是一种基于对象的编程范式，它将问题分解成一系列的对象，并将对象的属性（数据）和方法（行为）封装在一起，通过对象之间的交互来解决问题。 面向对象的代码通常会定义类（Class）来描述对象的属性和方法，并创建对象（Instance）来表示真实世界中的实体，通过调用对象的方法来完成任务。 面向对象的编程强调封装、继承和多态等概念，使得代码更加灵活、易于维护和扩展。 典型的面向对象编程语言是Java、C++、Python等。 区别 面向过程是以步骤为中心，强调按顺序执行任务，更加直接简单，适用于较为简单的问题。 面向对象是以对象为中心，强调将问题分解成相互协作的对象，更加灵活复杂，适用于大型复杂的软件系统。 举例 考虑一个计算机游戏的例子： 面向过程：分别编写处理游戏角色移动、攻击、跳跃等动作的函数，然后按照玩家输入的动作顺序依次调用这些函数。 面向对象：定义游戏角色类，包含属性（位置、状态等）和方法（移动、攻击、跳跃等），玩家操作的角色是该类的实例，通过调用角色对象的方法来实现游戏逻辑。 面向对象编程有三大基本特征：封装、继承和多态。 封装 封装是将对象的状态（数据）和行为（方法）封装在一个单一的实体（类）中，使得对象的内部细节对外部是不可见的。 通过封装，对象可以隐藏其实现细节，只对外部暴露必要的接口，从而保证了数据的安全性和完整性。 继承 继承是面向对象编程的重要特征，它允许一个类（子类）继承另一个类（父类）的属性和方法。 子类可以继承父类的特性，并且可以在此基础上扩展自己的属性和方法，实现代码的复用和扩展。 多态 多态是指同一个方法或属性在不同的对象上可以有不同的表现形式。 通过继承和方法重写，子类可以重写父类的方法，使得父类引用可以在运行时指向子类的对象，并调用子类的方法，实现多态性。 继承和实现 面向对象编程的两种关键机制，它们用于组织类之间的关系和代码复用。 继承 继承是指一个类（子类）可以继承另一个类（父类）的属性和方法。 Java支持单继承，即一个类只能继承一个父类，这是为了避免菱形继承问题。 子类通过使用关键字extends来继承父类，从而可以获得父类的属性和方法，并且可以在此基础上进行扩展。 继承可以实现代码的复用和继承体系的层次结构。 实现 实现是指一个类（实现类）可以实现一个或多个接口，从而获得接口中定义的抽象方法的具体实现。 Java支持多实现，一个类可以实现多个接口，通过使用关键字implements来实现接口。 类实现接口后，必须实现接口中定义的所有抽象方法，否则该类必须声明为抽象类。 接口的实现允许多个类实现相同的接口，从而实现了接口的多态性。 在使用继承和实现时，开发者需要根据具体需求和设计考虑，合理组织类之间的关系，以达到代码的可维护性和可扩展性。继承和实现是Java面向对象编程中非常重要的特性，它们可以帮助构建灵活且可扩展的应用程序。 面向对象编程五大基本原则（SOLID原则） 五大基本原则（SOLID原则）： 单一职责原则（Single-Responsibility Principle） 一个类应该只有一个单一的功能或职责，即一个类只负责完成一个特定的功能。 这个原则要求将不同的功能分离成独立的类，使得每个类的职责清晰明确，降低类的复杂性，增强代码的可读性和维护性。 开放封闭原则（Open-Closed Principle） 软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。 意味着在修改现有代码之前，我们应该尽量通过扩展来实现新功能，而不是直接修改已有的代码，从而避免影响原有功能的稳定性。 里氏替换原则（Liskov Substitution Principle） 子类必须能够替换其基类，即子类对象可以在不影响程序正确性的情况下替换基类对象。 子类应该遵循基类的契约和行为，不应该破坏继承体系的一致性。 依赖倒置原则（Dependency Inversion Principle） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。 抽象不应该依赖于细节，细节应该依赖于抽象。 该原则鼓励使用抽象类或接口来实现高层模块和低层模块之间的解耦，增强代码的灵活性和可维护性。 接口隔离原则（Interface Segregation Principle） 使用多个小的专门的接口，而不要使用一个大的总接口。 客户端不应该依赖它不需要的接口，避免接口的臃肿和冗余。 遵循这些基本原则可以帮助开发者设计出高内聚、低耦合、易扩展的面向对象系统，提高代码质量和可维护性。这些原则在面向对象设计和架构中起到了重要的指导作用。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"面向对象和面向过程","feature":"","link":"https://riftrays.github.io/12f0O6Nr1/","stats":{"text":"6 min read","time":341000,"words":1680,"minutes":6},"date":"2019-01-01 23:49:00","dateFormat":"2019-01-01 23:49:00"},{"abstract":"","content":"String有长度限制吗？是多少？ 在Java中，String对象的长度是有限制的。String类的长度限制取决于Java虚拟机（JVM）的实现和系统内存的限制。在实际开发中，String对象的长度限制通常会受到以下两个方面的影响： JVM堆内存大小：String对象存储在堆内存中，因此其长度受到JVM堆内存大小的限制。如果String对象的长度超过了JVM堆内存的可用空间，就会抛出OutOfMemoryError异常。 操作系统内存限制：在使用大量字符串的场景中，还需要考虑操作系统对进程可用内存的限制。如果字符串的总长度超过了操作系统内存限制，可能会导致程序崩溃。 具体来说，对于32位JVM，一个String对象的长度最大限制约为2GB，因为32位操作系统对单个进程可用内存通常有限制，不可能分配超过2GB的连续内存空间。 对于64位JVM，理论上它可以支持更大的字符串长度，但仍然受到可用内存和操作系统限制。在实际应用中，如果要处理非常大的字符串，可能需要特殊的技术和工具来管理内存，避免内存溢出等问题。 现在，我们来通过一个简单的代码示例来演示在不同情况下String对象的长度限制。 public class StringLengthDemo { public static void main(String[] args) { // 创建一个较小的字符串 String smallString = &quot;This is a small string.&quot;; System.out.println(&quot;Length of smallString: &quot; + smallString.length()); // 创建一个较大的字符串 StringBuilder largeStringBuilder = new StringBuilder(); for (int i = 0; i &lt; 1000000; i++) { largeStringBuilder.append(&quot;a&quot;); } String largeString = largeStringBuilder.toString(); System.out.println(&quot;Length of largeString: &quot; + largeString.length()); } } 输出结果可能为： Length of smallString: 24 Length of largeString: 1000000 在这个示例中，我们首先创建了一个较小的字符串smallString，其长度是24。接着，我们使用StringBuilder来创建一个包含100万个字符的较大字符串largeString，并打印其长度。在这里，我们并没有遇到任何长度限制，因为100万个字符的字符串对于现代计算机来说并不算特别大。 然而，请注意这只是一个简单的示例。在实际应用中，可能会遇到更大的字符串或者系统资源受限的情况，因此需要根据具体情况进行合理规划和管理内存。如果需要处理特别大的数据量，可能需要考虑使用其他数据结构或技术来优化和分割字符串处理的过程。 编译期和运行期不一样！ 编译期和运行期对字符串长度的限制有所不同，让我们逐步详细解释： 编译期： 在Java编译期，字符串常量的值需要用CONSTANT_Utf8_info结构来表示。这个结构包含两个字段： length字段：这是一个2字节的无符号整数，用于表示bytes数组中的字节数。 bytes数组字段：这是一个字节数组，用于存储字符串的UTF-8编码形式。 CONSTANT_Utf8_info结构的长度限制是65535字节，这意味着一个字符串常量的内容不能超过65535个字节。如果字符串的UTF-8编码形式长度超过了这个限制，编译器将无法创建对应的常量，可能会导致编译错误。 让我们通过一个简单的示例来演示编译期对字符串长度的限制： public class CompileTimeStringLimitationDemo { public static void main(String[] args) { // 创建一个较短的字符串 String shortString = &quot;Hello, World!&quot;; System.out.println(&quot;Length of shortString: &quot; + shortString.length()); // 创建一个较长的字符串，长度超过65535字节 StringBuilder longStringBuilder = new StringBuilder(); for (int i = 0; i &lt; 70000; i++) { longStringBuilder.append(&quot;a&quot;); } String longString = longStringBuilder.toString(); System.out.println(&quot;Length of longString: &quot; + longString.length()); } } 输出结果为： Length of shortString: 13 Length of longString: 70000 在这个示例中，我们创建了一个较短的字符串shortString，其长度是13。接着，我们使用StringBuilder创建了一个包含70000个字符的较长字符串longString，并打印了其长度。由于编译期对字符串长度没有限制，因此longString的长度可以超过65535。 运行期： 在Java运行期，String类的length方法用于获取字符串的字符数（长度）。String的length参数是int类型的，int类型的最大范围值由java.lang.Integer.MAX_VALUE定义，其最大值是2^31 - 1，即2147483647。 这意味着在运行期，一个String对象的长度不能超过2147483647个字符。 让我们通过代码示例来演示运行期对String长度的限制： public class RuntimeStringLengthLimitationDemo { public static void main(String[] args) { // 创建一个较短的字符串 String shortString = &quot;Hello, World!&quot;; System.out.println(&quot;Length of shortString: &quot; + shortString.length()); // 创建一个较长的字符串，长度超过int类型的最大值 StringBuilder longStringBuilder = new StringBuilder(); for (int i = 0; i &lt; Integer.MAX_VALUE + 100; i++) { longStringBuilder.append(&quot;a&quot;); } String longString = longStringBuilder.toString(); System.out.println(&quot;Length of longString: &quot; + longString.length()); } } 输出结果为： Length of shortString: 13 Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit at java.base/java.util.Arrays.copyOf(Arrays.java:3745) at java.base/java.util.Arrays.copyOf(Arrays.java:3671) at java.base/java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:146) at java.base/java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:506) at java.base/java.lang.StringBuilder.append(StringBuilder.java:184) at RuntimeStringLengthLimitationDemo.main(RuntimeStringLengthLimitationDemo.java:11) 在这个示例中，我们首先创建了一个较短的字符串shortString，其长度是13。接着，我们使用StringBuilder创建了一个包含超过int类型最大值的字符数的较长字符串longString，这导致了OutOfMemoryError异常，因为超过了运行期的字符串长度限制。 综上所述，编译期使用CONSTANT_Utf8_info结构来表示字符串常量的值，它有一个长度限制为65535字节。而在运行期，String的length方法用于获取字符串的字符数，其参数是int类型，因此String对象的长度最大不能超过int类型的最大值，即2147483647个字符。在实际应用中，需要根据具体场景和需求来处理和管理字符串的长度，避免超出限制导致的问题。 常量池限制 常量数量限制：每个类（Class）的常量池都有一个最大容量，它是由CONSTANT_Utf8_info、CONSTANT_Integer_info、CONSTANT_Float_info、CONSTANT_Long_info、CONSTANT_Double_info、CONSTANT_String_info、CONSTANT_Class_info等常量项构成。 常量大小限制：每个常量项在常量池中都占用一定的空间大小，其中CONSTANT_Utf8_info用于存储字符串常量，其长度限制是65535字节，这意味着一个字符串常量的内容不能超过65535个字节。 代码示例： 下面我们通过代码示例来演示常量池的限制。在示例中，我们会尝试创建大量的字符串常量，以验证常量池的数量限制和字符串常量的大小限制。 public class ConstantPoolLimitationDemo { public static void main(String[] args) { // 创建大量字符串常量并存储在常量池中 for (int i = 0; i &lt; 100000; i++) { String str = &quot;ConstantPoolLimitationDemo_&quot; + i; } } } 在上面的示例中，我们创建了100000个字符串常量，每个常量都是以&quot;ConstantPoolLimitationDemo_&quot;为前缀，并加上一个递增的数字。这些字符串常量会被存储在常量池中。由于这些字符串常量的内容不同，它们都会被视为不同的常量项。 在运行示例代码时，会发现没有出现任何错误。这是因为在这个简单的示例中，100000个不同的字符串常量并未超过常量池的容量限制，也没有超过字符串常量的大小限制。 为了验证常量池的数量限制，我们可以在示例中创建更多的字符串常量。然而，值得注意的是，由于常量池的限制，一旦达到最大容量，就会出现编译错误，如： Error: constant pool overflow 这是由于常量池已经达到了最大容量，无法再存储更多的常量项。 综上所述，常量池是Java中用于存储字面量和符号引用的数据结构，它有一定的限制，包括常量数量限制和字符串常量的大小限制。在实际应用中，我们需要根据常量池的限制来合理管理和使用常量，避免超出限制导致的问题。 运行期限制 1. 内存限制： Java应用程序在运行期间需要使用内存来执行代码和存储数据。Java虚拟机（JVM）负责管理内存，并为每个应用程序实例分配一定的堆内存。在运行Java程序时，有几个内存限制需要注意： 堆内存限制： 堆内存是用于存储对象实例的地方。JVM在启动时会为每个Java应用程序实例分配一定大小的堆内存。通过-Xms和-Xmx参数可以设置堆内存的初始大小和最大大小。 -Xms参数设置JVM的初始堆内存大小。 -Xmx参数设置JVM的最大堆内存大小。 例如，可以使用以下命令来设置初始堆内存大小为512MB，最大堆内存大小为2GB： java -Xms512m -Xmx2g YourJavaProgram 当Java程序在运行时需要更多的内存时，JVM会动态地增加堆内存的大小，直到达到最大堆内存大小为止。如果程序超出了最大堆内存限制，会导致OutOfMemoryError异常。 栈内存限制： 栈内存用于存储方法调用和局部变量。每个线程在运行时都有一个对应的栈，栈内存大小是固定的。栈内存的大小由JVM在启动时通过-Xss参数设置，默认值通常较小。 java -Xss256k YourJavaProgram 当程序的方法调用层级较深，或者方法中使用了大量的局部变量，会导致栈空间不足，从而引发StackOverflowError异常。 方法区（永久代）限制： 方法区（在Java 8及之前版本称为永久代，Java 8以后称为元空间）用于存储类的结构信息、常量池、静态变量等数据。方法区的大小也是有限制的，可以通过-XX:PermSize和-XX:MaxPermSize参数（Java 8之前）或-XX:MetaspaceSize和-XX:MaxMetaspaceSize参数（Java 8以后）来设置初始大小和最大大小。 2. 数据类型的取值范围： 在Java中，不同的数据类型有不同的取值范围，这也是运行期限制的一部分。 例如，Java中的基本数据类型byte、short、int、long、float和double，它们的取值范围如下： byte：-128 到 127 short：-32,768 到 32,767 int：-2^31 到 2^31-1 （约 -2.1 亿到 2.1 亿） long：-2^63 到 2^63-1 （约 -9.2 京到 9.2 京） float：IEEE 754单精度浮点数，取值范围约在 -3.4E38 到 3.4E38 之间 double：IEEE 754双精度浮点数，取值范围约在 -1.7E308 到 1.7E308 之间 当使用超出数据类型取值范围的值时，可能会导致数据溢出或损失精度。 下面是一个简单的代码示例，演示了一些数据类型的取值范围限制： public class DataTypeLimitationDemo { public static void main(String[] args) { byte byteValue = 127; short shortValue = 32767; int intValue = 2147483647; long longValue = 9223372036854775807L; float floatValue = 3.4E38f; double doubleValue = 1.7E308; System.out.println(&quot;byteValue: &quot; + byteValue); System.out.println(&quot;shortValue: &quot; + shortValue); System.out.println(&quot;intValue: &quot; + intValue); System.out.println(&quot;longValue: &quot; + longValue); System.out.println(&quot;floatValue: &quot; + floatValue); System.out.println(&quot;doubleValue: &quot; + doubleValue); } } 输出结果为： byteValue: 127 shortValue: 32767 intValue: 2147483647 longValue: 9223372036854775807 floatValue: 3.4028235E38 doubleValue: 1.7976931348623157E308 在这个示例中，我们分别声明并初始化了各种基本数据类型的变量，保证它们都在其取值范围内。输出结果表明这些变量都处于有效的取值范围内。 综上所述，运行期限制主要涉及内存限制和数据类型的取值范围。在编写Java程序时，需要考虑这些限制，避免超出限制导致的问题，同时合理设计和管理数据以确保程序的正确性和性能。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"String有长度限制吗？是多少？","feature":"","link":"https://riftrays.github.io/ORcmOqbrY/","stats":{"text":"12 min read","time":705000,"words":3049,"minutes":12},"date":"2019-01-01 23:08:15","dateFormat":"2019-01-01 23:08:15"},{"abstract":"","content":"在Java中，String对象是不可变的，即一旦创建后，其内容不能被修改。对于字符串对象的比较，使用==比较的是引用地址，而使用.equals()方法比较的是字符串的内容。现在让我们来详细解释下这个问题，并结合代码进行演示。 public class StringComparisonDemo { public static void main(String[] args) { String a = &quot;ab&quot;; // 在编译时常量池中创建 &quot;ab&quot; 字符串对象 String b = &quot;a&quot; + &quot;b&quot;; // 在编译时常量池中创建 &quot;ab&quot; 字符串对象 // 判断是否为同一个引用 System.out.println(&quot;a == b: &quot; + (a == b)); // 输出 true，因为 a 和 b 都指向编译时常量池中的同一个对象 // 判断内容是否相同 System.out.println(&quot;a.equals(b): &quot; + a.equals(b)); // 输出 true，因为 a 和 b 的内容都是 &quot;ab&quot; } } 输出结果为： a == b: true a.equals(b): true 从输出结果可以看出，a和b的引用地址是相同的，因此a == b返回true。同时，它们的内容也相同，因此a.equals(b)返回true。 原因解析： 在Java中，字符串连接表达式&quot;a&quot; + &quot;b&quot;会在编译时被优化，将其直接转换为一个字符串常量&quot;ab&quot;。因此，b实际上指向编译时常量池中的&quot;ab&quot;字符串对象，与a指向的对象是同一个。 值得注意的是，如果字符串连接表达式中存在变量，那么在运行时就无法在编译时进行优化了，例如： public class StringComparisonDemo { public static void main(String[] args) { String a = &quot;ab&quot;; // 在编译时常量池中创建 &quot;ab&quot; 字符串对象 String x = &quot;a&quot;; String y = &quot;b&quot;; String b = x + y; // 运行时连接 x 和 y，创建新的字符串对象 // 判断是否为同一个引用 System.out.println(&quot;a == b: &quot; + (a == b)); // 输出 false，a 和 b 的引用地址不同 // 判断内容是否相同 System.out.println(&quot;a.equals(b): &quot; + a.equals(b)); // 输出 true，a 和 b 的内容都是 &quot;ab&quot; } } 输出结果为： a == b: false a.equals(b): true 在这个例子中，由于x和y是变量，因此字符串连接表达式x + y在运行时才能确定结果。所以，b是在堆中新创建的一个字符串对象，其引用地址与a不同。但是由于内容相同，a.equals(b)仍然返回true。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"String a = \"ab\"; String b = \"a\" + \"b\"; a == b 吗？","feature":"","link":"https://riftrays.github.io/UbqLCuphk/","stats":{"text":"3 min read","time":152000,"words":617,"minutes":3},"date":"2019-01-01 22:28:22","dateFormat":"2019-01-01 22:28:22"},{"abstract":"","content":"字面量 在Java中，字面量是指直接使用在代码中的常量值。例如，&quot;Vincent&quot;和&quot;hello&quot;就是字符串字面量，123和3.14则是整型和浮点型字面量。字面量可以直接在代码中使用，不需要使用new关键字来创建对象。 在使用字面量创建字符串时，Java会首先在编译时将这些字符串放入一个特殊的存储区域，这个区域被称为编译时常量池。编译时常量池是每个类的常量池的一部分，用于存储类的静态常量和字面量。 例如，在以下代码中： String str1 = &quot;Vincent&quot;; String str2 = &quot;hello&quot;; 字面量&quot;Vincent&quot;和&quot;hello&quot;在编译时会被放入编译时常量池。在运行时，如果有多个字符串使用相同的字面量，它们会共享同一个在编译时常量池中的对象。 运行时常量池 运行时常量池是在运行时创建的，用于存储在类加载后动态生成的常量。它是在方法区中的一部分，用于存储类的常量、静态变量、字符串字面量等信息。 在运行时常量池中，除了存储字面量外，还可以动态生成其他常量。例如，通过调用intern()方法可以将一个字符串添加到运行时常量池中。 让我们通过代码实现来加深理解： public class RuntimeConstantPoolDemo { public static void main(String[] args) { String str1 = &quot;Vincent&quot;; // 在编译时常量池中创建 &quot;Vincent&quot; 字符串对象 String str2 = &quot;hello&quot;; // 在编译时常量池中创建 &quot;hello&quot; 字符串对象 String str3 = &quot;Vincent&quot;; // 字符串常量&quot;Vincent&quot;已存在于编译时常量池中，直接返回引用 String str4 = new String(&quot;Vincent&quot;); // 在堆中创建一个新的字符串对象 String str5 = str4.intern(); // 将str4字符串对象添加到运行时常量池中，并返回引用 // 判断是否为同一个引用 System.out.println(&quot;str1 == str3: &quot; + (str1 == str3)); // 输出 true，因为它们都是编译时常量池中的同一个对象 System.out.println(&quot;str1 == str4: &quot; + (str1 == str4)); // 输出 false，因为str4在堆中创建了新的对象 System.out.println(&quot;str1 == str5: &quot; + (str1 == str5)); // 输出 true，因为str5是从运行时常量池中返回的引用 // 判断内容是否相同 System.out.println(&quot;str1.equals(str4): &quot; + str1.equals(str4)); // 输出 true，因为内容相同 } } 输出结果为： str1 == str3: true str1 == str4: false str1 == str5: true str1.equals(str4): true 从输出结果可以看出： str1和str3是同一个引用，因为它们都指向编译时常量池中的同一个对象。 str1和str4不是同一个引用，因为new String(&quot;Vincent&quot;)在堆中创建了新的对象。 str1和str5是同一个引用，因为str5是从运行时常量池中返回的引用。 总结： 字面量是直接使用在代码中的常量值，例如字符串字面量：&quot;Vincent&quot;和&quot;hello&quot;。 编译时常量池是在编译时存储字面量的特殊存储区域，用于存储类的静态常量和字面量，它属于类的一部分。 运行时常量池是在运行时动态生成的，用于存储类的常量、静态变量、字符串字面量等信息，它属于方法区的一部分。 运行时常量池中的字符串对象可以通过调用intern()方法将对象添加到其中，从而实现共享字符串对象的效果。 intern() intern()是一个方法，定义在java.lang.String类中。它的作用是将字符串对象添加到运行时常量池中，并返回运行时常量池中该字符串的引用。如果运行时常量池中已经存在相同内容的字符串，则直接返回该字符串的引用。 intern()方法的工作原理 当调用intern()方法时，JVM首先检查该字符串是否已经在运行时常量池中。如果在运行时常量池中找到了相同内容的字符串，则直接返回该字符串在常量池中的引用。 如果运行时常量池中没有找到相同内容的字符串，JVM会将该字符串添加到运行时常量池中，并返回新添加的字符串在常量池中的引用。 代码实现 让我们通过代码来演示intern()方法的使用和效果： public class InternMethodDemo { public static void main(String[] args) { String str1 = &quot;hello&quot;; // 字符串&quot;h&quot;添加到运行时常量池 String str2 = new String(&quot;hello&quot;); // 在堆中创建新的字符串对象 String str3 = str2.intern(); // 将str2所引用的字符串对象添加到运行时常量池，并返回常量池中的引用 // 判断是否为同一个引用 System.out.println(&quot;str1 == str2: &quot; + (str1 == str2)); // 输出 false，str1指向常量池，str2指向堆 System.out.println(&quot;str1 == str3: &quot; + (str1 == str3)); // 输出 true，str3是从运行时常量池中返回的引用 // 判断内容是否相同 System.out.println(&quot;str1.equals(str2): &quot; + str1.equals(str2)); // 输出 true，内容相同 System.out.println(&quot;str1.equals(str3): &quot; + str1.equals(str3)); // 输出 true，内容相同 } } 输出结果为： str1 == str2: false str1 == str3: true str1.equals(str2): true str1.equals(str3): true 从输出结果可以看出： str1和str2不是同一个引用，因为str2使用new关键字在堆中创建了新的对象。 str1和str3是同一个引用，因为str3是从运行时常量池中返回的引用。 str1和str2的内容相同，因为它们都是&quot;hello&quot;这个字符串。 str1和str3的内容相同，因为它们都是&quot;hello&quot;这个字符串。 总结： intern()方法将字符串对象添加到运行时常量池，并返回常量池中该字符串的引用。 如果运行时常量池中已经存在相同内容的字符串，则直接返回该字符串的引用。 intern()方法可以用于节省内存，因为共享相同内容的字符串可以在运行时常量池中重用。但过度使用intern()方法也可能导致运行时常量池过大，从而影响性能。因此，应谨慎使用该方法，只在有必要时使用。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"字面量和运行时常量池","feature":"","link":"https://riftrays.github.io/Zk1wdwEX1/","stats":{"text":"7 min read","time":366000,"words":1603,"minutes":7},"date":"2019-01-01 22:23:07","dateFormat":"2019-01-01 22:23:07"},{"abstract":"","content":"String str=new String(&quot;Vincent&quot;)创建了几个对象？ 当执行String str = new String(&quot;Vincent&quot;);这行代码时，会创建两个对象： 常量池中的字符串对象：&quot;Vincent&quot;会首先被放入常量池中，如果常量池中已经存在相同内容的字符串，则直接返回该对象的引用；否则，会在常量池中创建一个新的字符串对象。在这个例子中，&quot;Vincent&quot;是一个常量字符串，如果常量池中没有相同内容的字符串，则会在常量池中创建一个新的字符串对象。 堆中的字符串对象：使用new String(&quot;Vincent&quot;)会在堆中创建一个新的字符串对象。即使常量池中已经存在相同内容的字符串，使用new关键字也会在堆中创建一个新的字符串对象，而不是在常量池中引用已有的字符串。 现在，让我们通过代码实现来加深理解： public class StringObjectCreation { public static void main(String[] args) { String str1 = &quot;Vincent&quot;; // 在常量池中创建 &quot;Vincent&quot; 对象，如果常量池中已存在则直接返回引用 String str2 = new String(&quot;Vincent&quot;); // 在堆中创建一个新的字符串对象，即使常量池中已存在相同内容的字符串 System.out.println(&quot;str1: &quot; + str1); System.out.println(&quot;str2: &quot; + str2); System.out.println(&quot;str1 == str2: &quot; + (str1 == str2)); // 判断两个对象是否为同一个引用，返回 false System.out.println(&quot;str1.equals(str2): &quot; + str1.equals(str2)); // 判断两个对象内容是否相同，返回 true } } 在上面的代码中，我们分别使用&quot;Vincent&quot;和new String(&quot;Vincent&quot;)创建了两个字符串对象str1和str2。我们使用==运算符判断两个对象是否为同一个引用，返回false，说明它们在堆中创建了两个不同的对象。然后，我们使用equals()方法判断两个对象的内容是否相同，返回true，说明它们的内容是相同的。 总结： 使用new String(&quot;Vincent&quot;)会在堆中创建一个新的字符串对象，不论常量池中是否已经存在相同内容的字符串。 常量池中的字符串对象会被重复利用，如果常量池中已经存在相同内容的字符串，则直接返回该对象的引用。这种字符串对象的创建是更为高效的方式，因为它可以避免重复创建相同内容的字符串。 为什么创建的对象数应该是1个或者2个？ 当执行String str = new String(&quot;Vincent&quot;);这行代码时，实际上会创建1个或者2个对象，具体取决于常量池中是否已经存在相同内容的字符串。 情况一：常量池中不存在相同内容的字符串 首先，&quot;Vincent&quot;会被放入常量池中，因为常量池中还没有相同内容的字符串，所以会在常量池中创建一个新的字符串对象。 然后，new String(&quot;Vincent&quot;)会在堆中创建一个新的字符串对象，因为new关键字强制在堆中创建一个新的对象。 在这种情况下，总共会创建2个对象：一个在常量池中，一个在堆中。str引用将指向堆中的对象。 情况二：常量池中已存在相同内容的字符串 首先，&quot;Vincent&quot;会被放入常量池中，因为常量池中已经存在相同内容的字符串，所以不会再在常量池中创建新的对象，而是直接返回常量池中已有的字符串对象的引用。 然后，new String(&quot;Vincent&quot;)会在堆中创建一个新的字符串对象，因为new关键字强制在堆中创建一个新的对象。 在这种情况下，总共会创建1个对象：一个在堆中。str引用将指向堆中的对象。 下面是具体的代码实现，用于验证上述情况： public class StringObjectCreation { public static void main(String[] args) { String str1 = &quot;Vincent&quot;; // 在常量池中创建 &quot;Vincent&quot; 对象，如果常量池中已存在则直接返回引用 String str2 = new String(&quot;Vincent&quot;); // 在堆中创建一个新的字符串对象，即使常量池中已存在相同内容的字符串 // 获取常量池中的字符串对象 String str3 = &quot;Vincent&quot;; // 判断str1和str2是否为同一个引用 System.out.println(&quot;str1 == str2: &quot; + (str1 == str2)); // 由于str2使用new关键字，在堆中创建了新的对象，返回false // 判断str1和str3是否为同一个引用 System.out.println(&quot;str1 == str3: &quot; + (str1 == str3)); // 由于str3直接引用了常量池中的对象，返回true // 判断str1和str2的内容是否相同 System.out.println(&quot;str1.equals(str2): &quot; + str1.equals(str2)); // 由于内容相同，返回true // 判断str1和str3的内容是否相同 System.out.println(&quot;str1.equals(str3): &quot; + str1.equals(str3)); // 由于内容相同，返回true } } 输出结果为： str1 == str2: false str1 == str3: true str1.equals(str2): true str1.equals(str3): true 根据输出结果，可以看到： str1和str2不是同一个引用，因为new String(&quot;Vincent&quot;)在堆中创建了一个新的对象。 str1和str3是同一个引用，因为str3直接引用了常量池中的对象。 str1和str2的内容相同，因为它们都是&quot;Vincent&quot;这个字符串。 str1和str3的内容相同，因为它们都是&quot;Vincent&quot;这个字符串。 总结： 在使用new String(&quot;Vincent&quot;)时，如果常量池中已存在相同内容的字符串，会在堆中创建一个新的对象，并将引用指向该对象。 如果常量池中不存在相同内容的字符串，会在常量池中创建一个新的字符串对象，并在堆中创建另一个新的对象，并将引用指向堆中的对象。 因此，总共会创建1个或者2个对象，具体取决于常量池中是否已经存在相同内容的字符串。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"String str=new String(\"Vincent\")创建了几个对象？","feature":"","link":"https://riftrays.github.io/_DPLlghy6/","stats":{"text":"6 min read","time":351000,"words":1539,"minutes":6},"date":"2019-01-01 22:20:33","dateFormat":"2019-01-01 22:20:33"},{"abstract":"","content":"区别 String: String是Java中用于表示不可变字符串的类。一旦创建了一个String对象，它的内容就不能被改变。如果对String进行任何修改，都会生成一个新的String对象。 String str = &quot;Hello&quot;; str = str + &quot; World&quot;; // This creates a new String object, &quot;Hello World&quot;, and assigns it to the variable str. 由于String是不可变的，每次对String进行修改，都会导致创建新的String对象，这在频繁的字符串操作时可能会导致性能问题。 StringBuilder: StringBuilder是Java中用于表示可变字符串的类。它允许我们对字符串进行添加、插入、删除等操作，而不会每次都创建新的对象。因此，在需要频繁进行字符串操作的情况下，使用StringBuilder通常是更高效的选择。 StringBuilder sb = new StringBuilder(); sb.append(&quot;Hello&quot;); sb.append(&quot; World&quot;); // The same StringBuilder object is used to perform both append operations. String result = sb.toString(); // Convert StringBuilder to a String when needed. StringBuffer: StringBuffer与StringBuilder类似，也是用于表示可变字符串的类。主要区别在于StringBuffer是线程安全的，而StringBuilder不是。这意味着在多线程环境下，使用StringBuffer是安全的，而StringBuilder可能会导致数据不一致或竞态条件。 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;Hello&quot;); stringBuffer.append(&quot; World&quot;); // The same StringBuffer object is used to perform both append operations. String result = stringBuffer.toString(); // Convert StringBuffer to a String when needed. 综上所述： 使用String类适用于不需要频繁修改字符串的场景，例如字符串常量或配置信息等。 使用StringBuilder类适用于单线程环境下频繁进行字符串操作的场景，可以提高性能。 使用StringBuffer类适用于多线程环境下频繁进行字符串操作的场景，保证线程安全。 小贴士 如果在单线程环境下进行字符串操作，并且对线程安全没有特殊要求，建议使用StringBuilder，因为它比StringBuffer稍微更高效。例如，多数情况下，StringBuilder是更常见的选择。 String的不可变性 String的不可变性是指一旦创建了一个String对象，它的内容就不能被改变。无论是通过修改还是追加，任何对String对象的操作都会生成一个新的String对象，而原来的String对象保持不变。这意味着String对象的内容在创建后是固定的，不能再被修改。 为了更好地理解String的不可变性，我们可以通过代码实例来演示： public class ImmutableStringExample { public static void main(String[] args) { // 创建一个字符串&quot;Hello&quot;，并将其赋值给str1 String str1 = &quot;Hello&quot;; // 尝试在原字符串上追加&quot; World&quot;，实际上是创建了一个新的String对象，并将其赋值给str2 String str2 = str1 + &quot; World&quot;; // 输出结果 System.out.println(&quot;str1: &quot; + str1); // Output: str1: Hello System.out.println(&quot;str2: &quot; + str2); // Output: str2: Hello World // str1并没有改变，仍然是&quot;Hello&quot; System.out.println(&quot;After concatenation:&quot;); System.out.println(&quot;str1: &quot; + str1); // Output: str1: Hello System.out.println(&quot;str2: &quot; + str2); // Output: str2: Hello World // 尝试修改str1的值 str1 = &quot;Hi&quot;; // 输出结果 System.out.println(&quot;After modification:&quot;); System.out.println(&quot;str1: &quot; + str1); // Output: str1: Hi System.out.println(&quot;str2: &quot; + str2); // Output: str2: Hello World // str2仍然保持不变，仍然是&quot;Hello World&quot; } } 在上面的代码中，我们首先创建一个String对象str1并赋值为&quot;Hello&quot;。然后，我们尝试在str1的基础上追加&quot; World&quot;，得到一个新的String对象，并将其赋值给str2。可以看到，str1并没有改变，仍然是&quot;Hello&quot;，而str2是新的String对象&quot;Hello World&quot;。 接下来，我们尝试修改str1的值为&quot;Hi&quot;，再次输出str1和str2的值。可以看到，str1被修改为&quot;Hi&quot;，但str2仍然保持不变，仍然是&quot;Hello World&quot;。这就是String的不可变性的体现。 String的不可变性带来了一些优势： 线程安全：由于String是不可变的，多线程环境下多个线程可以共享同一个String对象，而不需要额外的同步操作，从而提高了线程安全性。 缓存Hash值：String的不可变性使得它的哈希值（Hash值）在创建后就可以被缓存，提高了字符串的哈希查找效率。 安全性：字符串常量池中存储的是不可变的字符串，防止了对字符串的修改导致数据不一致问题。 小贴士： 尽管String的不可变性带来了这些优势，但也需要注意，当进行大量字符串拼接时，频繁创建新的String对象可能会导致性能下降。在这种情况下，应该考虑使用StringBuilder或StringBuffer来进行字符串操作，以避免不必要的对象创建。 为什么设计成不可变的 设计字符串为不可变的有多个原因，其中包括以下几个主要方面： 线程安全性：字符串常量池中存储的是不可变的字符串。如果字符串是可变的，那么在多线程环境下可能会引发线程安全问题。因为多个线程可以同时修改可变字符串的值，导致数据不一致或竞态条件。通过将字符串设计为不可变的，可以避免这些问题，保证线程安全性。 缓存Hash值：String的不可变性使得它的哈希值（Hash值）在创建后就可以被缓存。这意味着一旦计算了字符串的哈希值，就不需要重新计算。这在哈希查找等操作中可以提高性能，因为不需要每次都重新计算哈希值。 字符串池：Java中的字符串池（String Pool）是一种字符串常量的缓存机制。当创建一个字符串时，如果字符串池中已经存在相同内容的字符串，那么就会直接返回池中的对象，而不是创建新的对象。这样可以节省内存空间，避免创建大量相同内容的字符串对象。 安全性：字符串作为参数传递给方法时，如果是可变的，那么在方法内部可能会被修改，导致意外的副作用。通过将字符串设计为不可变的，可以确保方法内部无法修改传入的字符串参数，增加代码的稳定性和可预测性。 下面我们通过代码来演示String的不可变性和它所带来的好处： public class ImmutableStringExample { public static void main(String[] args) { // 创建一个字符串&quot;Hello&quot;，并将其赋值给str1 String str1 = &quot;Hello&quot;; // 尝试修改str1的值 str1 = &quot;Hi&quot;; // This creates a new String object &quot;Hi&quot; and assigns it to the variable str1. // 输出结果 System.out.println(&quot;str1: &quot; + str1); // Output: str1: Hi // 创建一个字符串&quot;Hello&quot;，并将其赋值给str2 String str2 = &quot;Hello&quot;; // 尝试在原字符串上追加&quot; World&quot;，实际上是创建了一个新的String对象，并将其赋值给str2 str2 = str2 + &quot; World&quot;; // 输出结果 System.out.println(&quot;str2: &quot; + str2); // Output: str2: Hello World // str1并没有改变，仍然是&quot;Hi&quot; System.out.println(&quot;After modification:&quot;); System.out.println(&quot;str1: &quot; + str1); // Output: str1: Hi } } 在上面的代码中，我们首先创建一个String对象str1并赋值为&quot;Hello&quot;，然后尝试修改str1的值为&quot;Hi&quot;。可以看到，str1被修改为&quot;Hi&quot;，但是并没有影响到原来的&quot;Hello&quot;字符串对象。这说明String是不可变的，修改字符串实际上是创建了一个新的String对象。 接着，我们再创建一个String对象str2并赋值为&quot;Hello&quot;，然后尝试在str2的基础上追加&quot; World&quot;。可以看到，虽然str2的值变成了&quot;Hello World&quot;，但是并没有改变原来的&quot;Hello&quot;字符串对象。 这些例子展示了String的不可变性，每次修改String都会生成一个新的String对象，原来的String对象保持不变。这种设计带来了安全性、线程安全性以及哈希查找等方面的优势。在Java中，String的不可变性是一个重要的设计决策，有助于确保代码的稳定性和可预测性。 String的&quot;+&quot;是如何实现的 在Java中，使用+操作符可以用于字符串的连接（字符串拼接）。当使用+操作符连接两个字符串时，实际上是通过Java编译器进行了优化，转换为使用StringBuilder或StringBuffer来进行字符串拼接。 字符串连接优化：在Java中，对于字符串连接操作，编译器会将其转换为StringBuilder或StringBuffer的append()方法调用，然后通过toString()方法获取最终的连接结果。 String vs. StringBuilder vs. StringBuffer： String：字符串是不可变的，每次对字符串进行连接操作时都会创建新的String对象。如果在循环中频繁使用+进行字符串拼接，会导致不断创建新的字符串对象，可能会造成性能问题。 StringBuilder：StringBuilder是可变的字符串类，适用于大量字符串拼接操作。它的append()方法可以在原字符串上追加内容，并不会创建新的对象。因此，使用StringBuilder可以避免不必要的对象创建，提高性能。 StringBuffer：与StringBuilder类似，StringBuffer也是可变的字符串类。不同的是，StringBuffer的方法是线程安全的，适用于多线程环境下的字符串操作，但相比StringBuilder，StringBuffer的性能较差，因为它使用了同步机制来保证线程安全。 下面是一个示例代码，演示了+操作符是如何通过StringBuilder实现字符串连接： public class StringConcatenationExample { public static void main(String[] args) { String str1 = &quot;Hello&quot;; String str2 = &quot; World&quot;; // 使用 + 操作符进行字符串连接，实际上编译器会进行优化，转换为 StringBuilder 的 append 方法 String result = str1 + str2; // 编译器优化后的实际操作相当于下面的代码： // StringBuilder sb = new StringBuilder(); // sb.append(str1); // sb.append(str2); // String result = sb.toString(); System.out.println(&quot;Result: &quot; + result); // Output: Result: Hello World } } 在上面的代码中，我们首先定义了两个字符串str1和str2，然后使用+操作符将它们连接起来并赋值给result变量。实际上，编译器会将这个操作转换为StringBuilder的append()方法调用，然后通过toString()方法获取最终的连接结果。 当使用+操作符进行字符串连接时，如果连接操作在循环中频繁执行，建议使用StringBuilder来代替+操作符，以避免不必要的字符串对象创建，提高性能。例如： public class StringConcatenationLoopExample { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 10; i++) { sb.append(&quot;Number: &quot;).append(i).append(&quot;\\n&quot;); } String result = sb.toString(); System.out.println(result); } } 在上面的代码中，我们使用StringBuilder在循环中进行字符串拼接，避免了不断创建新的字符串对象，提高了性能。 StringBuffer和StringBuilder StringBuffer和StringBuilder都是用于进行字符串操作的可变字符串类，它们提供了一系列方法来添加、修改、删除和查询字符串内容。它们的主要区别在于线程安全性和性能方面。 StringBuffer: StringBuffer是线程安全的，适用于多线程环境下的字符串操作。在每个方法上都使用了synchronized关键字来实现线程同步，保证了多个线程对StringBuffer对象的操作不会引发线程安全问题。 由于线程安全性带来了额外的开销，StringBuffer的性能相对较低，不适合在单线程环境下进行频繁的字符串操作。 StringBuilder: StringBuilder是非线程安全的，适用于单线程环境下的字符串操作。它没有像StringBuffer一样使用synchronized关键字来实现线程同步，因此没有线程安全的保障。 由于没有线程同步的开销，StringBuilder的性能相对较高，适合在单线程环境下进行频繁的字符串操作。 由于StringBuilder的性能优于StringBuffer，在单线程环境下建议使用StringBuilder来进行字符串操作。而在多线程环境下，如果需要线程安全性，可以选择使用StringBuffer，但如果不需要线程安全性，则更推荐使用StringBuilder以获得更好的性能。 下面是使用StringBuffer和StringBuilder的示例代码： StringBuffer示例代码： public class StringBufferExample { public static void main(String[] args) { // 创建一个StringBuffer对象 StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;); // 在原字符串上追加&quot; World&quot; stringBuffer.append(&quot; World&quot;); // 将&quot; World&quot;替换为&quot; Java&quot; stringBuffer.replace(6, 11, &quot; Java&quot;); // 在字符串&quot;Hello Java&quot;的索引位置5处插入&quot; beautiful&quot; stringBuffer.insert(5, &quot; beautiful&quot;); // 删除字符串&quot;Hello beautiful Java&quot;的索引位置0到5（不包含5）的部分 stringBuffer.delete(0, 6); // 输出最终的结果 System.out.println(stringBuffer.toString()); // Output: beautiful Java } } 在上面的代码中，我们首先创建了一个StringBuffer对象，并使用append()方法在原字符串上追加了&quot; World&quot;，然后使用replace()方法将&quot; World&quot;替换为&quot; Java&quot;。接着使用insert()方法在索引位置5处插入&quot; beautiful&quot;，最后使用delete()方法删除了索引位置0到5（不包含5）的部分，得到最终的结果&quot;beautiful Java&quot;。 StringBuilder示例代码： public class StringBuilderExample { public static void main(String[] args) { // 创建一个StringBuilder对象 StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;); // 在原字符串上追加&quot; World&quot; stringBuilder.append(&quot; World&quot;); // 将&quot; World&quot;替换为&quot; Java&quot; stringBuilder.replace(6, 11, &quot; Java&quot;); // 在字符串&quot;Hello Java&quot;的索引位置5处插入&quot; beautiful&quot; stringBuilder.insert(5, &quot; beautiful&quot;); // 删除字符串&quot;Hello beautiful Java&quot;的索引位置0到5（不包含5）的部分 stringBuilder.delete(0, 6); // 输出最终的结果 System.out.println(stringBuilder.toString()); // Output: beautiful Java } } 在上面的代码中，我们同样使用了StringBuilder对象，进行了与StringBuffer相同的字符串操作，得到了相同的最终结果&quot;beautiful Java&quot;。 无论是StringBuffer还是StringBuilder，它们都提供了类似的方法来进行字符串操作，区别主要在于线程安全性和性能方面的考虑。根据使用场景选择适合的可变字符串类，可以帮助我们更高效地处理字符串操作。在单线程环境下，建议优先使用StringBuilder，在多线程环境下，如果需要线程安全性，可以选择StringBuffer。 不要在for循环中使用+拼接字符串 当在for循环中频繁使用+操作符进行字符串拼接时，会导致性能问题。这是因为在Java中，字符串是不可变的，每次进行字符串连接操作都会创建一个新的字符串对象。在循环中重复创建字符串对象会导致大量的对象生成和销毁，对内存和性能造成负面影响。 为了解决这个性能问题，我们可以使用StringBuilder（或在多线程环境下使用StringBuffer）来优化字符串拼接操作。StringBuilder是可变的字符串类，它允许在原始字符串上进行追加、插入、替换和删除等操作，避免了不必要的字符串对象创建和销毁，从而提高了性能。 下面是一个示例代码，演示了在for循环中使用StringBuilder进行字符串拼接的优化： public class StringBuilderInLoopExample { public static void main(String[] args) { int n = 10000; String result = &quot;&quot;; // 使用 + 操作符拼接字符串，在循环中频繁创建新的字符串对象 long startTime1 = System.currentTimeMillis(); for (int i = 0; i &lt; n; i++) { result += &quot; &quot; + i; } long endTime1 = System.currentTimeMillis(); // 使用 StringBuilder 进行字符串拼接，避免了不必要的对象创建 long startTime2 = System.currentTimeMillis(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { sb.append(&quot; &quot;).append(i); } String optimizedResult = sb.toString(); long endTime2 = System.currentTimeMillis(); // 输出运行时间 System.out.println(&quot;Using + operator: &quot; + (endTime1 - startTime1) + &quot; milliseconds&quot;); System.out.println(&quot;Using StringBuilder: &quot; + (endTime2 - startTime2) + &quot; milliseconds&quot;); } } 在上面的代码中，我们分别使用+操作符和StringBuilder来拼接10000个整数到一个字符串中，并记录运行时间。你会发现，使用+操作符进行字符串拼接会耗费更多的时间，而使用StringBuilder则会更加高效。 通过上面的示例，可以清楚地看到在循环中频繁使用+操作符进行字符串拼接的性能问题，以及使用StringBuilder优化字符串拼接的效果。因此，建议在循环中进行频繁的字符串拼接操作时，使用StringBuilder来提高性能，避免不必要的对象创建。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"String、StringBuilder和StringBuffer的区别？","feature":"","link":"https://riftrays.github.io/4eYhFaRS0/","stats":{"text":"17 min read","time":994000,"words":4223,"minutes":17},"date":"2019-01-01 21:54:07","dateFormat":"2019-01-01 21:54:07"},{"abstract":"","content":"整型的取值范围在Java中是由其数据类型所决定的，每个类型都有不同的表示范围。 public class IntegerRange { public static void main(String[] args) { // byte类型的取值范围演示 byte minValueByte = Byte.MIN_VALUE; byte maxValueByte = Byte.MAX_VALUE; System.out.println(&quot;byte类型的范围：&quot; + minValueByte + &quot; 到 &quot; + maxValueByte); // short类型的取值范围演示 short minValueShort = Short.MIN_VALUE; short maxValueShort = Short.MAX_VALUE; System.out.println(&quot;short类型的范围：&quot; + minValueShort + &quot; 到 &quot; + maxValueShort); // int类型的取值范围演示 int minValueInt = Integer.MIN_VALUE; int maxValueInt = Integer.MAX_VALUE; System.out.println(&quot;int类型的范围：&quot; + minValueInt + &quot; 到 &quot; + maxValueInt); // long类型的取值范围演示 long minValueLong = Long.MIN_VALUE; long maxValueLong = Long.MAX_VALUE; System.out.println(&quot;long类型的范围：&quot; + minValueLong + &quot; 到 &quot; + maxValueLong); // 溢出问题演示 int i = Integer.MAX_VALUE; int j = Integer.MAX_VALUE; int k = i + j; System.out.println(&quot;i (&quot; + i + &quot;) + j (&quot; + j + &quot;) = k (&quot; + k + &quot;)&quot;); } } 这段代码会输出整型各个数据类型的范围，并且还会演示一个可能导致溢出的情况。在运行时，你会看到输出结果为： byte类型的范围：-128 到 127 short类型的范围：-32768 到 32767 int类型的范围：-2147483648 到 2147483647 long类型的范围：-9223372036854775808 到 9223372036854775807 i (2147483647) + j (2147483647) = k (-2) 在这个例子中，我们可以看到整型的取值范围和超出范围的情况。记得要在程序中特别注意数据溢出的问题，谨慎处理计算。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"整型的取值范围","feature":"","link":"https://riftrays.github.io/g2cX6NjvR/","stats":{"text":"2 min read","time":94000,"words":355,"minutes":2},"date":"2019-01-01 21:50:07","dateFormat":"2019-01-01 21:50:07"},{"abstract":"","content":"编程范式 C++支持过程式编程和面向对象编程，允许在同一个程序中使用两种风格。 Java则主要支持面向对象编程，强制使用面向对象的设计和编程方式。 编译和解释 C++是编译型语言，源代码被编译成机器码，并且在特定平台上执行。这意味着在不同平台上编译后的程序可能不兼容。 Java是半编译、半解释型语言。Java源代码首先被编译成字节码，然后在Java虚拟机(JVM)上解释执行。这使得Java程序在不同平台上具有跨平台性能。 平台相关性 C++是平台相关的，编译后的代码通常与特定操作系统和硬件相关，因此需要为每个平台单独编译。 Java是平台无关的，Java程序首先被编译成字节码，然后由Java虚拟机(JVM)在各个平台上解释执行，因此不需要重新编译。 数字类型的范围限制 C++中，数字类型的范围和字节长度通常由编译器和操作系统决定，可能在不同平台上有所不同。 Java在所有平台上对所有的基本数据类型都有标准的范围限制和字节长度，这是由Java虚拟机规范所决定的，保证了跨平台的一致性。 兼容性 C++在很大程度上与C语言兼容，这意味着大部分C代码可以直接在C++中使用。 Java没有对任何之前的语言向前兼容，但在语法上受到C/C++的影响很大，因此熟悉C/C++的开发人员在学习Java时可能会有一些优势。 调用本地系统库 C++允许直接调用本地系统库，这使得C++可以与操作系统底层进行更直接的交互。 Java要调用本地系统库，需要使用JNI（Java Native Interface）或JNA（Java Native Access）等技术，这增加了一些复杂性。 内存管理 C++需要手动管理内存，开发人员负责分配和释放内存。这可以给程序员更多控制，但也容易导致内存泄漏和悬挂指针等问题。 Java具有自动垃圾回收机制，它负责自动释放不再使用的内存。这样减轻了开发人员的负担，并减少了内存泄漏的可能性。 多继承 C++支持多重继承，一个类可以从多个父类继承属性和方法。 Java仅支持单一继承，一个类只能继承一个父类，但可以实现多个接口。 引用和指针 C++允许使用指针来直接操作内存地址和数据。这样的灵活性也可能导致潜在的问题，如空指针引用等。 Java没有指针的概念，只有引用。引用指向对象在堆上的地址，但程序员无法直接访问内存地址。 标准库和第三方库 C++标准库相对较小，它提供了一些基本的数据结构和算法。开发人员通常需要依赖第三方库来获得更多功能。 Java标准库较为丰富，提供了大量的类和方法，涵盖了许多常见的任务。Java社区也有大量的第三方库可供选择。 ","tags":[{"index":5,"name":"interview","slug":"tag-Interview","used":true,"link":"https://riftrays.github.io/tag-Interview/"},{"index":-1,"name":"C++","slug":"tag-C++","used":true,"link":"https://riftrays.github.io/tag-C++/"},{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"Java和C++的区别","feature":"","link":"https://riftrays.github.io/dfa12esad/","stats":{"text":"4 min read","time":181000,"words":866,"minutes":4},"date":"2019-01-01 13:46:26","dateFormat":"2019-01-01 13:46:26"},{"abstract":"","content":"Java名称的由来 在最初，Java语言是叫做oak（橡树）。是因为刚开始公司门口有一颗橡树。所以就叫做橡树。然后发现oak已经被美国橡树公司注册了，就不能再继续使用了。所以需要改名。而程序员最爱喝的是咖啡，盛产咖啡的 岛叫做爪哇岛，由此语言就叫做Java了。 Java语言概述 语言：人与人交流沟通的表达方式 计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言 Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言，后被Oracle公司收购。 Java 早期称为Oak(橡树)，后期改名为Java。 Java之父：詹姆斯·高斯林（James Gosling） Java语言发展史 1995年Sun公司推出Java语言 1996年发布Java 1.0版本 1997年发布Java 1.1版本 1998年发布Java 1.2版本 2000年发布Java 1.3版本 2002年发布Java 1.4版本 2004年发布Java 5.0版本 2006年发布Java 6.0版本 2009年Oracle甲骨文公司收购Sun公司 2011年发布Java 7.0版本 2014年发布Java 8.0版本 2017年9月发布Java 9.0版本 2018年3月发布Java 10.0版本 2018年9月发布Java 11.0版本 2019年3月发布Java 12.0版本 2019年9月发布Java 13.0版本 2020年3月发布Java 14.0版本 … 小贴士： Java5.0：里程碑性质的版本，也是第一个大版本号更新。 Java8.0：企业中用的最多的版本。 Java三大技术平台 技术平台 说明 Java SE(Java Standard Edition) 标准版 用于桌面应用的开发，是其他两个版本的基础。 Java技术的核心和基础，是学习Java EE，JavaME的基础，也是近期重点学习的技术。支持开发桌面级应用（如Windows下的应用程序）的Java平台 Java EE(Java Enterprise Edition) 企业版 用于企业应用开发，包括 Web 方向开发。为开发企业环境下的应用程序提供的一套解决方案，主要针对于Web应用程序开发，多用于大型网站开发，是后期重点学习的技术。 Java ME(Java Micro Edition) 小型版 用于嵌入式电子设备或者小型移动设备。是为机顶盒、移动电话和PDA之类嵌入式消费电子设备提供的Java语言平台，现在移动终端基本上都是使用Android和IOS的技术平台了。 Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台，此技术也被广泛运用在SIM卡、提款卡上。 Java语言的优点 世界上最流行的编程语言之一，在国内使用最为广泛的编程语言。 可移植性、安全可靠、性能较好。做到一次编写，到处运行，跨平台 开发社区最完善，功能最为丰富。 Java语言跨平台原理 平台：指的是操作系统（Windows、Mac、Linux） 跨平台：Java程序可以在任意操作系统上运行（一次编译，处处可用） 跨平台原理：在需要运行Java应用程序的操作系统上，安装一个与操作系统对应的Java虚拟机JVM（Java Virtual Machine）即可。 Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。 Java程序开发运行流程 public class HelloWorld{ public static void main(String[] args){ // main方法或者叫主方法，java中所有程序执行的入口 System.out.println(&quot;HelloWorld&quot;); //输出语句 用来输出双引号中的内容的 双引号引起来的又叫 字符串 } } //public 是一个修饰符，使用public修饰的类，文件名要和类名一模一样，反之可以不一致，编译不报错。 //class 是一个标识，class是用来定义类，class后面字符串，表示类名 开发Java程序，需要三个步要：编写程序、编译程序、运行程序 注意问题： 编译命令后的java文件名需要带文件后缀.java 运行命令后的class文件名（类名）不带文件后缀.class 常见问题: 非法字符问题。Java中的符号都是英文格式的。 大小写问题。Java语言对大小写敏感（区分大小写） 文件名称。必须与代码的类名称一致 扩展名被隐藏。在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件 补充知识： JDK11新特性 支持java命令直接运行 .java 文件，无需javac .java文件。 乱码问题 原因：编码不一样，导致乱码 在编译时加上当前文件的编码 javac -encoding 编码 Java文件 括号问题 java中的括号都是成对出现的，有左边就有右边 JRE&amp;JDK&amp;JVM 概述 JRE (Java Runtime Environment)：Java程序的运行时环境，包含JVM和运行时所需要的核心类库 类：java文件在代码中的集合体现 类库：存放多个java文件的仓库 理解：在编写代码的过程中，需要用到java已经写好的这些java文件。 要运行一个已有的Java程序，那么只需安装JRE即可 JDK （Java Development Kit）：Java程序开发工具包，包含JRE和开发人员使用的工具和运行工具 （java.exe）其中的开发工具: 编译工具 （javac.exe） 要开发一个全新的Java程序，那么必须安装JDK JDK的版本 2021年9月JDK(17) JDK、JRE和JVM的关系/作用 **集成环境：**把代码编写，编译，运行，调试等多种功能综合到一起的开发工具 JVM（Java Virtual Machine）：Java虚拟机, 真正运行Java程序的地方。 JDK（Java Development Kit）: Java开发工具，包含java编译器、java虚似机、以及java帮写好的程序...等所有java的开发、运行需要的东西。 JRE（Java Runtime Environment）: Java运行时环境，只包含java虚似机、以及java帮写好的程序等java运行所需的东西。 JDK的安装目录介绍 目录名称 说明 bin 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该路径下存放了JDK的相关配置文件。 include 该路径下存放了一些平台特定的头文件。 jmods 该路径下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充JAR包。 JavaEE三层架构 概述 JavaEE（Java Enterprise Edition）是用于开发企业级应用程序的Java平台。JavaEE采用了一种常见的架构模式，即三层架构，也称为分层架构。 三层架构 表示层（Presentation Layer）：表示层是应用程序与用户之间的交互界面。它负责接收用户的请求，并将结果呈现给用户。常见的表示层技术包括JavaServer Pages（JSP）、JavaServer Faces（JSF）、Servlet等。在这一层中，开发人员通常处理用户界面、表单验证、用户输入等任务。 业务逻辑层（Business Logic Layer）：业务逻辑层处理应用程序的核心业务逻辑。它包含了应用程序的业务规则、数据处理和算法等。这一层通常包含各种Java类和组件，用于实现业务逻辑，例如EJB（Enterprise JavaBeans）、Spring框架等。 持久层（Persistence Layer）：持久层处理数据的持久化和访问。它负责与数据库或其他数据存储系统进行交互，从而实现数据的读取、写入和查询等操作。在JavaEE中，最常用的持久化技术是Java Persistence API（JPA），通常与关系型数据库（如MySQL、Oracle等）一起使用。 优点 模块化和可维护性：通过将应用程序分为不同的层次，每个层次专注于特定的功能和责任，使得代码更易于管理和维护。开发人员可以更容易地理解和修改特定层次的代码，而不必关注整个应用程序。 可扩展性：三层架构允许各个层次独立地进行扩展。例如，可以在表示层添加新的用户界面组件，而无需更改业务逻辑层或持久层。这种松耦合的设计使得应用程序更容易扩展以满足不断变化的需求。 可测试性：由于各个层次之间有清晰的边界和责任分配，因此可以更轻松地编写单元测试和集成测试。开发人员可以独立地测试每个层次的功能，从而提高代码质量和可靠性。 可重用性：通过将应用程序分为独立的层次，可以更好地实现代码的重用。例如，业务逻辑层可以被多个表示层共享，从而避免了重复编写相同的业务逻辑代码。这样可以提高开发效率，并减少错误和冗余代码。 并行开发：三层架构允许不同开发人员或团队同时工作在不同的层次上，提高开发效率和并行开发能力。各个层次之间的清晰分离使得团队成员可以并行地开发和测试不同的功能，从而加快项目的交付速度。 框架 概述 Java框架是指为了简化和加快Java应用程序开发过程而设计的软件框架。它们提供了一组预定义的模块和函数，用于处理常见的开发任务，如数据库访问、用户界面设计和网络通信等。一些常见的Java框架包括Spring、Hibernate和Struts等。 作用 Java框架的作用是提供开发者一个可靠的基础结构，以便更快速地构建高质量的Java应用程序。它们通常具有以下作用： 简化开发：Java框架提供了预定义的模块和函数，开发者可以直接使用这些模块，而无需从头开始编写代码。这大大减少了开发时间和工作量。 提高可维护性：框架使用一致的设计模式和最佳实践，使得代码更易于理解和维护。开发者可以遵循框架的规范和约定，减少代码的混乱和错误。 增加可扩展性：Java框架通常提供了可扩展的插件和扩展机制，使开发者能够根据需要添加新功能或修改现有功能，而无需重写整个应用程序。 改善性能：一些Java框架使用了高效的算法和优化技术，以提供更好的性能和响应时间。它们还可以处理并发请求和负载均衡等任务。 常用框架 框架 作用 Spring 提供了轻量级的、灵活的、可扩展的开发框架，用于构建企业级Java应用程序。它包括依赖注入、面向切面编程、事务管理等功能。 Hibernate 用于对象关系映射（ORM），简化了Java应用程序与关系数据库之间的数据持久化操作。它提供了对象到数据库表的映射以及查询和事务管理等功能。 Struts 用于构建基于MVC（模型-视图-控制器）架构的Web应用程序。它提供了处理请求、控制页面导航和数据验证等功能。 JavaServer Faces (JSF) 是Java企业版的用户界面框架，用于构建交互式Web应用程序。它提供了可重用的组件和事件驱动的编程模型。 Apache Tomcat 是一个开源的Web应用程序服务器，用于运行Java Servlet和JavaServer Pages（JSP）。它提供了处理HTTP请求和响应的能力。 JUnit 是一个Java单元测试框架，用于编写和执行测试用例。它提供了断言、测试套件和测试运行器等功能，用于验证代码的正确性。 Log4j 是一个Java日志记录框架，用于记录应用程序的运行日志。它提供了灵活的日志配置和多种日志输出方式，方便开发者进行调试和错误排查。 Apache Kafka 是一个高性能、可扩展的分布式消息队列系统。它用于处理实时数据流，支持高吞吐量和容错性。 Apache Spark 是一个大数据处理框架，提供了分布式数据处理和分析能力。它支持数据流处理、批处理、机器学习和图计算等功能。 BUG 概述 Bug是一个英文单词，中文意思是指【昆虫、小虫、损坏、缺陷等意思】 现在一般是指在程序中，出现的缺陷或问题，简称程序漏洞。 BUG的解决 具备识别BUG的能力：多看 具备分析BUG的能力：多思考，多查资料 具备解决BUG的能力：多尝试，多总结 ","tags":[{"index":3,"name":"Java","slug":"tag-Java","used":true,"link":"https://riftrays.github.io/tag-Java/"}],"title":"JavaOverview","feature":"","link":"https://riftrays.github.io/JavaOverview/","stats":{"text":"12 min read","time":715000,"words":3312,"minutes":12},"date":"2019-01-01 10:00:33","dateFormat":"2019-01-01 10:00:33"},{"abstract":"","content":"显示fastboot设备：fastboot devices 获取手机相关信息：fastboot getvar all 重启手机：fastboot reboot 重启到bootloader：fastboot reboot-bootloader 擦除分区：fastboot erase (分区名) 例：清除system分区：fastboot erase system 刷入分区：fastboot flash (分区名) (分区镜像) 例：将boot镜像 &quot;boot.img&quot; 刷入boot分区：fastboot flash boot boot.img 引导启动镜像：fastboot boot (分区镜像) 例：启动到recovery分区：fastboot boot recovery.img 刷入ROM：fastboot update (刷机包) 例：将 update.zip 刷入：fastboot update update.zip 解锁Bootloader：fastboot oem unlock (参数见视频，视机型而定) 多设备使用：fastboot -s (命令) 通过fastboot devices获取序列号，控制多设备中的一个 例：清除序列号为'abc'设备的system分区：fastboot -s abc erase system ","tags":[{"index":4,"name":"Android","slug":"tag-Android","used":true,"link":"https://riftrays.github.io/tag-Android/"}],"title":"FastBoot常用命令","feature":"","link":"https://riftrays.github.io/fastboot/","stats":{"text":"1 min read","time":47000,"words":184,"minutes":1},"date":"2018-10-09 17:49:53","dateFormat":"2018-10-09 17:49:53"}]}
